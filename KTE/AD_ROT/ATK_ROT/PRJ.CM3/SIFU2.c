
//ДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДД
//
//                Принцип построения СИФУ:
// - ведущее СИФУ формирует ИУ;
// - ведомое формирует ИУ с отставание на 30грд +- дельта от РВТ;
// - ведомое СИФУ имеет свою уставку фазировочного тиристора задаваемую
//   по отношению к фазир.тир-ру ведущего СИФУ, чтобы можно было выдавать ИУ
//   на тиристоры ведомого моста со сдвигом (опережением, отставанием)
//   от ведущего в зависимости от схемы включения обмоток трансформатора.
//
//-----------------------------------

/* Второе СИФУ для 12-ти пульсной схемы. */

word SIFU2_Start ( word num )
{
  // Полная стартовая или частичная послереверсная инициализация.
  if ( num == 0 )   {}
  
  /* Зарядка ЕПА */
  
  // DAN 04.06.2016 - Только Ведущий Роторный Выпрямитель выдаёт СинхроИмпульс на плату энкодера .
  // 31.07.2017 8:44 - Ведомый теперь не может считать ДП и Скорость , т.к. ему уже не передаётся
  //                   синхроимпульс от Ведущего . Вместо этого идёт обмен герконами ...
  //if ( _or.CfgO._.Vedushiy == 1 )
  //{
  S2.NumInt = 1 ;
  //}
  //else S2.NumInt = 2 ;
  
  S2.TZ = timer1 + _Enc_base_time/2 ;
  init_sifu_epa( _sifu2_epa_con ) ;
  _sifu2_epa_time ( S2.TZ );
  
  return 0 ;
}

//         ПРОГРАММА УПРАВЛЕНИЯ СИФУ ВОЗБУДИТЕЛЯ.
//------------------------------------------------------------


// Программа-прерывание управления ведомым СИФУ.

void S2_Interrupt ( void )
{
  enum {i0,i1,i2,i3,i4};
  word ax;
  static word counter;
  
  //---------------------
  pV( 1 ) ;
  // Объектное (под процессор) дополнение для прерываний:
  Sifu_int_drv(_sifu2_epa_con) ;  // сброс запроса прерывания.
  
  //---------------------
#ifdef  mVObj_mask    // Объектное дополнение для прерываний:
  mVObj_mask() ;  // разрешения pts-EPA0 для частотного заполнения.
#endif
  //---------------------
      ax = timer1;
  
  //  разрешить  прерывания для АЦП.
  //  asm_ei() ;
  // asm_di() ;  //Чтобы не влезло левое прерывание
  // DAN 04.06.2016 - Только Ведущий Роторный Выпрямитель выдаёт СинхроИмпульс на плату энкодера .
 // if ( _or.CfgO._.Vedushiy == 1 )
 // {
    
    switch( S2.NumInt )
    {
    case i1 :
      
      asm_di();//Чтобы не влезло левое прерывание
      
      mSET_Q2() ;                       // выдача команды на плату датчика Энкодера для захвата значения положения.
      mUSEL_set();
      
      
      
      // фиксация времени захвата.
      QueryTimeOk = *Timer3 ;
/*      do   { QueryTimeOvr = Timer1_Ovr , Bbx = timer1 ; }  while ( QueryTimeOvr != Timer1_Ovr ) ;
      QueryTimeOvr <<= 12 ;      //  Из четырехбайтного полного значения времени берутся младший полубайт от "Timer1_Ovr"
      QueryTimeOvr  += (Bbx>>4);  //  и старший байт и младший полубайт (старшие разряды) от "Timer1" принимающие
      
      QueryTimeOvrOk = QueryTimeOvr  ;
*/      
      asm_ei() ;
      //S2.TZ += _MkSec(200) ;
      //s2_ax = S2.TZ  ;
      EncoderGray = 0x2000;
      S2.NumInt = i2 ;
      Time_Sifu2[0] = timer1 - ax;
      // перезарядка ЕПА
      _sifu2_epa_time (S2.TZ + _MkSec(100)); // зарядка конца импульса
      counter = 0;
      break;
    
    case i2 :
      asm_di();
      //while (EncoderGray == 0x2000)
      //{
        can_master( _CAN0_Port, 1 );
     // }
      asm_ei();
        //потом убрать
       //
      //S2.TZ += _Enc_base_time/4 ;
      //s2_ax = S2.TZ  ;
      Time_Sifu2[1] = timer1 - ax;
      
      if (EncoderGray == 0x2000 &&  !_or.CfgO._.EnSimulat)
      { 
        //Ждем получения данных. При скорости 250 это около 600 мкс
        //S2.NumInt = i3 ;
        _sifu2_epa_time (timer1 + _MkSec(20));
        if ((*Timer3 - QueryTimeOk > _Enc_base_time-_MkSec(200))||(priznak_CAN2_no == 1) )
        {          
          EncoderGray = 0x0;
        }
        else
        {
          break;
        }
      }
      mUSEL_clr();
/*     else
     {      
      // перезарядка ЕПА
      _sifu2_epa_time (S2.TZ + _MkSec(800)); // зарядка конца импульса
     }
      
      break;      
      
    case i3 :*/
      asm_di();
      //can_master( _CAN0_Port, 1 );
      asm_ei() ; 
      SmulatorDP();
      fr2 = EncoderGray ;
     
      //S2.TZ += _Enc_base_time/4 ;
      //s2_ax = S2.TZ  ;
      
      
/*      S2.NumInt = i4 ;
      Time_Sifu2[1] = timer1 - ax;
     
      // перезарядка ЕПА
      _sifu2_epa_time (S2.TZ + _MkSec(600)); // зарядка конца импульса
      
      break;
      //-------------
      
      
    case i4 :
      
      // DAN 04.06.2016 - Только Ведущий Роторный Выпрямитель выдаёт СинхроИмпульс на плату энкодера .
      // 31.07.2017 8:44 - Ведомый теперь не может считать ДП и Скорость , т.к. ему уже не передаётся
      //                   синхроимпульс от Ведущего . Вместо этого идёт обмен герконами ...
*/
      mCLR_Q2() ; // для контроля цикла ведомого
      //mUSEL_clr();
      
      
      // 31.07.2017 8:44 - Ведомый теперь не может считать ДП и Скорость , т.к. ему уже не передаётся
      //                   синхроимпульс от Ведущего . Вместо этого идёт обмен герконами ...
      //if ( _or.CfgO._.Vedushiy == 0 /*&& noMeandr == 0*/ )
      //{
      //  can_master( _CAN2_Port, 1 )  ;
      //}
      //S2.TZ += _Enc_base_time/4 ;
      //s2_ax = S2.TZ  ;
      //
      //S2.NumInt = 4 ;
      //Time_Sifu2[2] = timer1 - ax;
      
      // перезарядка ЕПА
      //_sifu2_epa_time (s2_ax); // зарядка конца импульса
      
      //break;
      //-------------
      
      
      //mCLR_Q2() ;     
      
      
      // 31.07.2017 8:44 - Ведомый теперь не может считать ДП и Скорость , т.к. ему уже не передаётся
      //                   синхроимпульс от Ведущего . Вместо этого идёт обмен герконами ...
      //if ( _or.CfgO._.Vedushiy == 0 /*&& noMeandr == 0*/ )
      //{
      //  can_master( _CAN2_Port, 1 )  ;
      //}
      DPLrotNrot () ;
      
      //Sled () ;
      
      S2.TZ += _Enc_base_time ;
      
      //s2_ax = S2.TZ  ;
      if ( _or.CfgO._.sld_PWM == 0 ) 
      {       
        Sled () ;
        sled.dt_scan = _Enc_base_time;   
      }
      
      
      
      // DAN 04.06.2016 - Только Ведущий Роторный Выпрямитель выдаёт СинхроИмпульс на плату энкодера .
      // Поэтому ничего не заряжаем , ожидаем прихода СинхроИмпульса от Ведущего ...
      // 31.07.2017 8:44 - Ведомый теперь не может считать ДП и Скорость , т.к. ему уже не передаётся
      //                   синхроимпульс от Ведущего . Вместо этого идёт обмен герконами ...
      //if ( _or.CfgO._.Vedushiy == 1 )
      {
        S2.NumInt = i1 ;
        // перезарядка ЕПА
        _sifu2_epa_time (S2.TZ); // зарядка конца импульса
      }
      Time_Sifu2[3] = timer1 - ax;
      
      break;
      //-------------
      
    }
 /* }
  else
  {
      if ( _or.CfgO._.sld_PWM == 0 ) 
      {       
        Sled () ;
        sled.dt_scan = _Enc_base_time;   
      }
      S2.TZ += _Enc_base_time;
      _sifu2_epa_time (S2.TZ); // зарядка конца импульса
    
  }*/
  pV( 0 ) ;
  
  return;
}
//---------------------------------------------------

void Id2_Izm (void)
{
  return;
}
//---------------------------------------------------

//   Регулятор Выравнивающего Тока

void RVT ( void )
{    // не регистровые, чтобы сохранялись в стеке.
  return ;
}
