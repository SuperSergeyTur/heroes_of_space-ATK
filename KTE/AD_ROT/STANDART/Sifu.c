//------------------------------
// Программа старта роторного СИФУ.

  word SIFU_Start ( void )
  {
    S.NumMost = 0x1 ;

    mPort_Imp(FOR0 [0]) ;

    mVkl_Imp ( _All_imp ) ;  // Otkl_Imp &= ~( 0xFFFFu) очистка регистра снятия импульсов
    mOtkl_Imp ( _Start_imp ) ;  // Otkl_Imp |= ( 0x8000u )программа стартует со снятыми импульсами
    Tpp_3syn = 10000;
    T_60gr = 3333;

    S.flg.all = 0 ;

    VT = VTn = 1 ;

    for ( i = 0 ; i<6 ; i++ )
    {
        L[i] = 0 ;
        L_IU[i] = 0 ;
    }
    //Alfa_kor = 0 ;
    //Alfa_kor_Old = 0 ;
    S.N = _r.S_FazirovVS ;
    
    S.NumInt = 1 ;

    s_cx = _r.S_Alfa_Start ;
    S.Alfa = s_cx ;

      //  Ограничитель угла.
    if ( s_cx > _r.S_Alfa_Max )
      {
        s_cx = _r.S_Alfa_Max;
        S.flg._.Fmax = 1 ;
      }
    else if ( s_cx < _r.S_Alfa_Min )
           {
             s_cx = _r.S_Alfa_Min ;
             S.flg._.Fmin = 1 ;
           }
    S.Alfa_Old = s_cx ;   // раньше это делать нельзя.

    S.Alfa_Old = s_cx ;   // раньше это делать нельзя.

    S.N = _r.S_FazirovVS ;
    N_inv = _r.S_FazirovVS ;

    S.NumInt = 1 ;

    S.NIP = FOR0[0] ;
   // pSyn = &Syn ;// Для начала привязываемся к базовой синхр., а затем,
    pSyn->b_SIv = 0 ; // если есть вторая синхр., то она и разберется...
    flgO._.NewSyn = 0 ;

        s_bx = NS2_rot ;      // пока сихронизация только по одному Uba напряжению ротора
       //s_bx = Usb.NS2 ;      // пока сихронизация только по одному Uba напряжению ротора

        s_bx += (w)((lw)( _r.S_FazirovUgol + s_cx ) * (lw)Tpp_3syn >> 14)  ;  // добавляем  фазировочный угол и угол управлени

       // TZ_sSec = s_bx  ;                // для следа

        DP_TZ  = timer3+ _MkSec(1000); //TZ_sSec << 4 ;                 // теперь переводим в обычный формат
      //S.TZ_msec = TZ_sSec >> 12 ;


   // S.TZ = pSyn->NS2  ; // усредненный момент прихода СИ.
   // S.TZ += (w)( (lw)( _r.S_FazirovUgol + s_cx ) * (lw)Tsyn >> 15 )  ;

    _r_S_ImpLong = _r.S_ImpLong ; // задаем изначально короткие, т.к. и
                                // частот.заполн. настраивается под короткие ИУ.
    /* Конец импульса и номер порта УИ описываются до того, как заряжать EPA */
    /* на случай, если  EPA сработает сразу же после его зарядки             */

    SIFU2_Start (0) ;
    Ud_off = 0, Id_off = 0 ;
          /* Зарядка ЕПА на угол измерения тока */

    init_sifu_epa( _sifu_epa_con ) ;

    _sifu_epa_time ( DP_TZ );
    

    return 0 ;
}

// Программа СИФУ ротора .

void sifu_rot ( void )
{
  byte al ;
  word i ;
  word ax ;
      // Для быстрой отработки аварии даже в цифровом СИФУ :
      if ( Av._.Sdvig_imp == 1 ) S.Alfa_Old = _r.S_Alfa_Max ; // сдвиг импульсов в Альфа_Макс.

      // Не имеет смысла выполнять рассчет ЗИ угла шесть раз за период на каждом пульсе .
      // Т.е. ЗИ угла , если бы был , то выполнялся бы на каждом тиристоре без привязки ко времени ,
      // т.к. частота изменяется .

      //--------------------------------------------------------------------------------------------
      // ВНИМАНИЕ : Во избежание потери ИУ в случае неопределенности , ограничивать Lmin на 5 грд !
      //--------------------------------------------------------------------------------------------

      ax = S.Alfa_Old ;
      if ( ax < _Grad(5.0) ) ax = _Grad(5.0) ;

      //---
      for ( i = 0 ; i<6 ; i++ )
      {
        L[i] = Lrot - i*_Grad(  60 ) ;
        if ( (sw)L[i] < 0 ) L[i] += _Grad( 360 ) ;
        //---
        // Повторяем идею Аналогового СИФУ - рассчет момента выдачи ИУ при пересечении Пилы с Углом Управления :
        L_IU[i] = L[i] - ax ; //S.Alfa_Old ;
      }

      //---
      i = 0 ;
      // Поиск первого положительного сравнения Пилы с Углом Управления и принятие его за Минимальное :
find: if ( (sw)L_IU[i] >= 0 )
      {
        L_iu = L_IU[i] ;  // Принятое Минимальное сравнение .
        VTn = i + 1 ;     // Принятый Рабочий тиристор .
      }
      else
      {
        i++ ;
        goto find ;
      }

      //---
      for ( i = VTn-1 ; i<6 ; i++ )
      {
        //---
        // Поиск минимального положительного сравнения Пилы с Углом Управления :
        if ( (sw)L_IU[i] >= 0 && (sw)L_IU[i] < L_iu )
        {
          L_iu = L_IU[i] ;  // Минимальное сравнение .
          VTn = i + 1 ;     // Рабочий тиристор .
        }
      }

      // Переход только на следующий тиристор .
      // Рассчетный тиристор - это следующий , после рабочего :
      al = VT + 1 ;
      if ( al >= 7 ) al = 1 ;

#ifndef _UPTF // Для АТК :
      // Подтягиваем выдержку времени на длину нулевой полочки тока при Принудительной коммутации :
      if ( flgO._.Prinud_com == 0 || flgO._.trig_Prinud == 0 )
      {
        time_Prinud = timer1 ;   // Подтяжка выдержки .
        mPPG4_set( 1 ) ;         // Нет нулевой полочки .
        flgO._.trig_Prinud = 0 ; // Сброс флага начала нулевой полочки .
      }
#endif
      L_L[0] = al;
      L_L[1] = VTn;

      // Проверяем текущий тиристор на соответствие рассчетному тиристору :
      if ( VTn == al )
      {
#ifndef _UPTF // Для АТК :
       if ( flgO._.Prinud_com == 1 ) // Принудительная коммутации - для оттягивания ИУ ротора на 15 мс , в течении которых
                                     // на плату АР1 инвертора подаётся нулевое задание тока для принудительной коммутации
                                     // тиристоров роторного выпрямителя . Скорость Nw ротора в принудительной коммутации
                                     // не должна быть меньше 80% ! Иначе импульсы будут сбиваться .
       {
               if ( flgO._.trig_Prinud == 0 ) // Для однократности .
               {
                     mPPG4_set( 0 ) ;         // Команда формирования нулевой полочки тока в АР1 .
                     flgO._.trig_Prinud = 1 ; // Флаг начала нулевой полочки .
                     //---
                     // Формируем Задние Фронты :
                   //mFzapoln1_stop() ;         // не снимаем частотное заполнение , чтобы не испортить длинные ИУ из 2х ИУ .
                     if ( flgO._.NeFaznRot == 0 )
                     {
                        mPort_Imp( FOR01 [VTn] ) ; // Импульсы только подтверждающие , без первых .
                     }
                     else
                     {
                        mPort_Imp( FOR21 [VTn] ) ; // Импульсы только первые , без подтверждающих , для нефазности ротора .
                     }
               }
               // Оттягиваем выдачу нового тиристора на 10-20 мс :
               if ( (w)(u)(timer1-time_Prinud) >= _MkSec(15*1000) )
               {
                     VT = VTn ;           // Новый рабочий тиристор .
                     flgO._.new_tyr = 1 ; // флаг разрешения ИУ .
                     //---
                     flgO._.trig_Prinud = 0 ; // сбрасываем флаг начала нулевой полочки .
               }
       }
       else
#endif
       {
        VT = VTn ;           // Новый рабочий тиристор .
        flgO._.new_tyr = 1 ; // флаг разрешения ИУ .
       }
      }

#ifndef _UPTF // Для АТК :
            mPPG1_forsir_set( 0 ); // форсировочный импульс для Выходных каскадов АТК , задний фронт , 250 мкс .
#endif
      //---
            // В АТК выдаём ИУ только при наличии разрешения , не при выходе из режима КЗ ,
            // и , возможно , стоит проверять длину сформированного ИУ :
            // В АТК роторном выпрямителе пока что не проверяем наличие силы ...
            //---
            // 20.06.2022 - В АТК при выходе из режима КЗ не снимаем ИУ , а сразу ставим угол в 170 грд
            //              принудительной коммутации . Однако , здесь , на всякий случай , до проверки
            //              на объекте оставим возможность снять ИУ роторного АР2 .
            if ( Otkl_Imp == 0 && bo_Avar == 0 && flgO._.KZ == 0 /*&& (sw)L_IU[VT-1] <= _Grad( 60 )*/
#ifdef _UPTF // В УПТФ выдаём ИУ только при наличии силы ( или в режиме фазировки , о чем говорит
             // бит Isp._.Predupr ), отключенном КЗ и без Затянувшегося Пуска :
                 && ( bi_QK1 == 1 || Isp._.Predupr == 1 ) && bo_Zatyan_Pusk == 0
#endif
                                                       )
            {
                // Если момент выдачи переднего фронта ИУ прошел - время выдавать очередной ИУ , при условии , что
                // есть флаг отработки ЗИ Угла и флаг нового тиристора показывает , что ИУ еще не был выдан ,
                if ( S.NumMost == 1 /*&& flgO._.zi_ugol == 1*/ && flgO._.new_tyr == 1 )
                                            {
                                              mFzapoln1_stop() ;     // снимаем частотное заполнение.
                                              mFzapoln1_start() ;    // включаем частотное заполнение для синхронизации с передним фронтом ИУ .
                                           #ifndef _UPTF // Для АТК :
                                              if ( flgO._.Sploshnyak == 1 )
                                              {
                                                   mPPG1_forsir_set( 1 ); // передний фронт форсировочного импульса для Выходных каскадов АТК .
                                                   mPort_Imp( 0x40 ) ;    // ИУ сплошные
                                              }
                                              else
                                           #endif
                                              {
                                                 if ( flgO._.NeFaznRot == 0 )
                                                 {
                                                   mPort_Imp( FOR0 [VT] ) ; // ИУ с подтверждающими .
                                                 }
                                                 else // Обратное чередование фаз :
                                                 {
                                                   mPort_Imp( FOR2 [VT] ) ; // ИУ для нефазности с подтверждающими .
                                                 }
                                              }
                                              //-----------------
                                              flgO._.new_tyr = 0 ;   // Снимаем флаг для однократности выдачи ИУ .
                                            //flgO._.zi_ugol = 0 ;   // Снимаем флаг выполнения ЗИ угла .
                                              //---
                                              //Puls_counter++ ; // счетчик Пульсов сделан как и раньше с жесткой привязкой к 3.3 мс для совместимости со всеми программами ...
                                            }
            }
            else // Задние Фронты , как и в Аналоговом СИФУ , будут формироваться новыми ИУ ...
            {
               mFzapoln1_stop() ;     // снимаем частотное заполнение.
               mPort_Imp( FOR0 [0] ) ;
            }
   return;
}

/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/

void  Control_otkr_tir ( word num ) // Заглушка .
  {
    return ;
  }
