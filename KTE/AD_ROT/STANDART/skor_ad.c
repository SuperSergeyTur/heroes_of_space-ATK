
//     ПРОГРАММА ОПРЕДЕЛЕНИЯ СКОРОСТИ АСИНХРОННОГО ДВИГАТЕЛЯ
//--------------------------------------------------------

void  SkorAD_epa_init ( void )
{     //  !!! ОСОБЕННОСТЬ ЕПА В ТОМ ЧТО ОН ПОСТОЯННО СРАБАТЫВАЕТ ПРИ КАЖДОМ
  // ОБОРОТЕ ТАЙМЕРА, ДАЖЕ ЕСЛИ В EPA_TIME НИЧЕГО НЕ ЗАПИСЫВАЛИ.
  //SkorAD_Label = 2 ; // для возможности выхода по default при
  // холостом срабатывания EPA через полный оборот таймера.
  //----
  word i ;
  //----
  
  init_sifu_epa( _revers_epa_con ) ;

  // Зарядка ЕПА :
  _revers_epa_time ( (w)(timer1 + 5 * 55.5) );
  
  // Инициализация переменных :
  IA = 0 , IB = 0 , IC = 0 ;
  Uac= 0 , Uba= 0 ;
  Ux = 0 , Uy = 0 , Ix = 0 , Iy = 0 ;
  
  for ( i = 0 ; i<3 ; i++ )
  {
    Psi_m_X[i] = 0 , Psi_m_Y[i] = 0 ;
  }
  for ( i = 0 ; i<2 ; i++ )
  {
    Psi_X[i] = 0 , Psi_Y[i] = 0 ;
    Slip_f[i] = 0 ;
    Phi_e[i] = 0 ;
  }
  
  Rsigma  = 0 , Xsigma = 0 ;
  Slip = 0 ;
  Lrot = 0 ;
  
  //---
  SkorRot = 0 ;
  OmegaRot = 0 , OmegaNullSynhr = 0 , N_ob_min = 0 ;
  
  // Инициализация коррекции рассчетов :
  trig_first_raschet = 0 ;
  
  Rsigma = 0 ;
  Rsigma_raschet = 0 ;
  Rsigma_korr = 0 ;
  
  Xsigma = 0 ;
  Xsigma_raschet = 0 ;
  Xsigma_korr = 0 ;
  
  nFrot = 0 ;
  Frot = 0  ;
  
  errPhi_e = 0 ; // инициализация ловушки для ошибки рассчета пилы Пси .
  
  return ;
}
void SkorAD_Interrupt ( void )
{
  SkorAD();    
}
//--------------------

// Программа-прерывание отсчета выдержек времени измерений токов и напряжений АД.
//
// Приоритет EPA ( ШИМ , Передний и Задний Фронта ) ниже приоритета прерывания аналогового СИФУ .
// 20.06.2019 - Приоритет аналогового СИФУ , как у геркона , IntPriority(1, 0) .
//              Приоритет EPA - минимальный возможный , IntPriority(2, 0) .
//
void SkorAD( void )
{
  word  bx , cx ;
  enum {i0,i10,i20,i30};
  //---------------------
  pR( 1 ) ; // флаг нахождения в прерывании .
  
  //mUSEL_set();
  bx = timer1; // время входа в прерывание .
  
  // Зарядка ЕПА на следующую серию измерений через 250 мкс ( 4кГц ) :
  _revers_epa_time ( timer1 + _MkSec( 250 ) );
  
  // Объектное (под процессор) дополнение для прерываний:
  Sifu_int_drv(_revers_epa_con) ;  // сброс запроса прерывания.
  
  //-----------
#ifdef  mVObj_mask    // Объектное дополнение для прерываний:
  mVObj_mask() ;  // разрешения pts-EPA0 для частотного заполнения.
#endif
  //---------------------
  //  разрешить  прерывания для АЦП, гашения ИУ .
  //asm_ei() ; //06.05.2019 - перенесено ниже .
  //-----------
  
  asm_di();//Чтобы не влезло левое прерывание
  
  // Масштабирование Роторных Датчиков :
  // 1.7 В - амплитуда действующего тока ротора .
  // 4.0 В - амплитуда действующего напряжения ротора .
  //--------
  // Зарядка измерений :
  mAD_Izm ( Uac_ach , &Uac_full ) ;
  mAD_Izm ( Uba_ach , &Uba_full ) ;
  mAD_Izm ( IA_ach  , &IA_full  ) ;
  mAD_Izm ( IB_ach  , &IB_full  ) ;
  mAD_Izm ( IC_ach  , &IC_full  ) ;
  //--------------------------------------------------------------------------------------------------------------------
  time_zar = timer1- bx;   // время выполнения зарядки пяти измерений .
  
  asm_ei() ;
  
  // Преобразование измерений без ожидания готовности ( т.к. измерение будет готово сразу после выполнения функции ) :
  mIzmData_Conversion ( IA_full  , IA  , IA_ach  ) ;
  mIzmData_Conversion ( IB_full  , IB  , IB_ach  ) ;
  mIzmData_Conversion ( IC_full  , IC  , IC_ach  ) ;
  mIzmData_Conversion ( Uac_full , Uac , Uac_ach ) ;
  mIzmData_Conversion ( Uba_full , Uba , Uba_ach ) ;
  
  // Масштабирование токов .
  // Масштаб тока был вычислен для действующего значения тока ротора :
  // Плата ДТ  аппаратно инвертирует выход , поэтому на стенде восстанавливаем знак тока , а на рабочих
  // агрегатах трансформаторы тока ставятся вверх ногами .
#ifndef _LABOR_STEND
  IA  =    (slw)(sw)IA * (slw)(sw)Mashtab.Irot>>8 ;
  IB  =    (slw)(sw)IB * (slw)(sw)Mashtab.Irot>>8 ;
  IC  =    (slw)(sw)IC * (slw)(sw)Mashtab.Irot>>8 ;
#else
  IA  = - ((slw)(sw)IA * (slw)(sw)Mashtab.Irot)>>8 ;
  IB  = - ((slw)(sw)IB * (slw)(sw)Mashtab.Irot)>>8 ;
  IC  = - ((slw)(sw)IC * (slw)(sw)Mashtab.Irot)>>8 ;
#endif
  
  // Масштабирование напряжений .
  Uac = ((slw)(sw)Uac* (slw)(sw)Mashtab.Ud)>>8 ;
  Uba = ((slw)(sw)Uba* (slw)(sw)Mashtab.Ud)>>8 ;
  
  time_izm = timer1- bx;   // время выполнения пяти измерений .
  cx = timer1;             // время начала математических вычислений .
  
  if ( !_or.CfgO._.Vedushiy)
  {
    
    // В АТК роторном выпрямителе пока что не проверяем наличие силы ...
#ifdef _UPTF
    if ( bi_QK1 == 0 && Isp._.Predupr == 0 ) // При наличии питания статора или в фазировке - рассчитываются I и U :
    {
      Ux = 0 ;
      Ix = 0 ;
      Uy = 0 ;
      Iy = 0 ;
    }
    else
#endif
    {
      // Перевод из трёхфазной системы координат в Декартову :
      if ( flgO._.NeFaznRot == 0 )
      {
        // Прямое чередование фаз - пила Lrot привязана к Uac .
        Ux = (float)(sw)Uac ;
        Ix = (float)(sw)(IA - IC) * _Kmasht ;            // Для рассчетов Грыгорыча приводим номинал к одним единицам .
        Uy = (float)(sw)(Uac + 2*Uba) / _sqr3_mask ;
        Iy = (float)(sw)IB * _sqr3_mask * _Kmasht ;      // Для рассчетов Грыгорыча приводим номинал к одним единицам .
      }
      else // Для коррекции СИФУ под нефазность ротора :
      {
        // Обратное чередование фаз - пила Lrot привязана к Uab .
        Ux = - (float)(sw)Uba ;
        Ix =   (float)(sw)(IA - IB) * _Kmasht ;          // Для рассчетов Грыгорыча приводим номинал к одним единицам .
        Uy = - (float)(sw)(2*Uac + Uba) / _sqr3_mask ;
        Iy =   (float)(sw)IC * _sqr3_mask * _Kmasht ;    // Для рассчетов Грыгорыча приводим номинал к одним единицам .
      }
    }
    
    // Прошлое значение потокосцепления ротора :
    Psi_X[0] = Psi_X[1] ;
    Psi_Y[0] = Psi_Y[1] ;
    
    // Рассчет потокосцепления ротора :
    Psi_X[1] = Psi_X[0] * ( 1 - _Ts/_or.Tf_aper ) + ( Ux + Ix*Rsigma ) * _Ts * OmegaNom ;
    Psi_Y[1] = Psi_Y[0] * ( 1 - _Ts/_or.Tf_aper ) + ( Uy + Iy*Rsigma ) * _Ts * OmegaNom ;
    
    // Прошлое значение потокосцепления ротора с главным магнитным потоком :
    Psi_m_X[0] = Psi_m_X[1] ;
    Psi_m_Y[0] = Psi_m_Y[1] ;
    
    // Рассчет потокосцепления ротора с главным магнитным потоком :
    Psi_m_X[1] = Psi_X[1] + Ix*Xsigma ;
    Psi_m_Y[1] = Psi_Y[1] + Iy*Xsigma ;
    
    //-----------
    
    // ВСЕ ТРИГОНОМЕТРИЧЕСКИЕ ФУНКЦИИ РАБОТАЮТ С РАДИАНАМИ .
    
    // Модуль потокосцепления ротора с главным магнитным потоком :
    if ( (float)Psi_m_X[1] < 0 ) Psi_m_X[2] = - Psi_m_X[1] ;
    else                         Psi_m_X[2] =   Psi_m_X[1] ;
    
    if ( (float)Psi_m_Y[1] < 0 ) Psi_m_Y[2] = - Psi_m_Y[1] ;
    else                         Psi_m_Y[2] =   Psi_m_Y[1] ;
    
    // Прошлое значение вектора потокосцепления ротора по ЭДС ( электрического угла напряжения ротора ) :
    Phi_e[0] = Phi_e[1] ;
    
    // Вектор потокосцепления ротора по ЭДС ( в радианах ) - электрический угол напряжения ротора :
    if      ( ((float)(Psi_m_X[2] - Psi_m_Y[2]) >= 0) && ((float)Psi_m_X[1] <  0) && ((float)Psi_m_Y[1] <= 0) )      //   0 <= phi <=  45 град -> 1 сектор
    {
      Phi_e[1] = atanf( Psi_m_Y[1] / Psi_m_X[1] ) ;
    }
    else if ( ((float)(Psi_m_X[2] - Psi_m_Y[2]) >  0) && ((float)Psi_m_X[1] <  0) && ((float)Psi_m_Y[1] >  0) )      // 315 <  phi <  360 град -> 8 сектор
    {
      Phi_e[1] = atanf( Psi_m_Y[1] / Psi_m_X[1] ) + 2*_PI ;
    }
    else if ( ((float)(Psi_m_X[2] - Psi_m_Y[2]) >= 0) && ((float)Psi_m_X[1] >  0) && ((float)Psi_m_Y[1] <= 0) )      // 135 <= phi <= 180 град -> 4 сектор
    {
      Phi_e[1] = atanf( Psi_m_Y[1] / Psi_m_X[1] ) + _PI ;
    }
    else if ( ((float)(Psi_m_X[2] - Psi_m_Y[2]) >= 0) && ((float)Psi_m_X[1] >  0) && ((float)Psi_m_Y[1] >  0) )      // 180 <  phi <= 225 град -> 5 сектор
    {
      Phi_e[1] = atanf( Psi_m_Y[1] / Psi_m_X[1] ) + _PI ;
    }
    else if ( ((float)(Psi_m_X[2] - Psi_m_Y[2]) <  0) && ((float)Psi_m_X[1] <= 0) && ((float)Psi_m_Y[1] <  0) )      //  45 <  phi <=  90 град -> 2 сектор
    {
      Phi_e[1] = _PI/2 - atanf( Psi_m_X[1] / Psi_m_Y[1] ) ;
    }
    else if ( ((float)(Psi_m_X[2] - Psi_m_Y[2]) <  0) && ((float)Psi_m_X[1] >  0) && ((float)Psi_m_Y[1] <  0) )      //  90 <  phi <  135 град -> 3 сектор
    {
      Phi_e[1] = _PI/2 - atanf( Psi_m_X[1] / Psi_m_Y[1] ) ;
    }
    else if ( ((float)(Psi_m_X[2] - Psi_m_Y[2]) <= 0) && ((float)Psi_m_X[1] <  0) && ((float)Psi_m_Y[1] >  0) )      // 270 <  phi <= 315 град -> 7 сектор
    {
      Phi_e[1] = 3*_PI/2 - atanf( Psi_m_X[1] / Psi_m_Y[1] ) ;
    }
    else if ( ((float)(Psi_m_X[2] - Psi_m_Y[2]) <  0) && ((float)Psi_m_X[1] >= 0) && ((float)Psi_m_Y[1] >  0) )      // 225 <  phi <= 270 град -> 6 сектор
    {
      Phi_e[1] = 3*_PI/2 - atanf( Psi_m_X[1] / Psi_m_Y[1] ) ;
    }
    else errPhi_e ++ ; // ловушка для ошибки...
    
    //---------------- Электрический угол напряжения ротора ------------------------
    // Электрический угол поворота ротора ( вектор потокосцепления ротора по ЭДС в электрических градусах ) :
    // 180 / _PI          - перевод радианов в градусы .
    // _Grad( 360 ) / 360 - перевод в дискреты градуса .
    //
    //         Phi_e[1] * _Grad( 360 ) * 180      Phi_e[1] * _Grad( 360 )
    // Lrot = -------------------------------- = ------------------------- ;
    //                           360   * _PI                2 * _PI
    //
    Lrot = (sw)(float)(Phi_e[1] * _Grad( 360 ) / (2 *_PI) ) ; // Рад -> эл.грд.
    
    if ( Lrot > _Grad( 360 ) )  Lrot -= _Grad( 360 ) ;
    
    
    //-------------------- Рассчеты скольжения и скорости ------------------------------
    
    // Скольжение ротора ( сложная формула ) :
    //Slip = (Psi_m_Y[1]*Psi_m_X[0] - Psi_m_X[1]*Psi_m_Y[0]) / (Psi_m_X[1]*Psi_m_X[1] + Psi_m_Y[1]*Psi_m_Y[1]) / _Ts ;
    
    //if (  flgO._.trig_Pusk == 1 ) // По расшунтировке регуляторов отпускается Slip :
    {
      // приращение пилы за такт ( может быть немного отрицательным ) :
      drad = Phi_e[1] - Phi_e[0] ;
      if      ( (float)drad < -_PI )  drad += 2*_PI ; // Переход пилы через нуль (проверяем уверенный переход , т.к. пила может искривится и угол будет немножко отрицательный ) .
      else if ( (float)drad > drad0 ) drad = drad0  ; // Ограничение максимального приращения .
      //---
      // Скольжение ротора ( рассчет по пиле ротора ) - производная пилы :
      Slip = (float)drad / _Ts ;
    }
    
    // Ограничение Скольжения на круговой частоте :
    if ( (float)Slip > OmegaNom ) Slip = OmegaNom ;
    
    // Прошлое значение фильтрованного скольжения :
    Slip_f[0] = Slip_f[1] ;
    
    // Фильтрация скольжения :
    Slip_f[1] = Slip_f[0] * ( 1 - _Ts/_or.Tfil ) + Slip * _Ts/_or.Tfil ;
    
    // Частота вращения ротора ( в радианах ) :
    OmegaRot = ( OmegaNom - Slip_f[1] ) / (float)(w)Pary_AD ;
    
    // Текущая частота, измеренная каждые 250 мкс , где
    //  - 4000 Гц это перевод мксек в сек ( 1000000 мксек / 250 мксек ) ,
    //  - 360 это основание для частоты .
    nFrot = (w)((float)(drad * 4000 * 360 ) / (2 *_PI)) ; // перевод приращения ( за 250 мкс ) радиан в частоту .
    //------------------------------------------------------------------------------------------------------------------------
    // СИФУ в прерываниях измерений раз в 250 мкс :
    
    
    if ( flgO._.VShunt2)
    {
      flgO._.VShunt2 = 0 ;
    }
    else
    {
      flgO._.VShunt2 = 1 ;
    }
/*  }
  else
  {
     delta_L = (float)(w)((u)(timer1 - Time_DLRot));
     delta_L *= dLdT;
     Lrot = Lrot_dp + (w)delta_L;
     if (Lrot > _Grad(360))
     {
       Lrot -= _Grad(360);
     }

   
  }
*/    
    sifu_rot () ;
  }
  asm_ei();
  //-----------
  // Конфигурационный бит - След для ШИМа или длинный след :
  if ( _or.CfgO._.sld_PWM == 1 )
  {
    Sled () ;   // 23.04.2018 10:23 - 45 мкс при 19 параметрах .
    sled.dt_scan = _MkSec(250);
  }
  //-----------
  //mUSEL_clr() ;
  time_math   = timer1- cx;  // время выполнения математических вычислений .
  TimeAD_Skor = timer1- bx;  // время выполнения всего прерывания .
  //mUSEL_not();
  //-----------
  
  // 19.08.2020 10:00 - Включен FPU , ИУ сняты , вычисления на double - 120 мкс прерывание , 40 мкс измерение 5 каналов .
  // 01.10.2021 8:49  - Включен FPU , ИУ сняты , вычисления на float  - 107 мкс прерывание , 40 мкс измерение 5 каналов .
  
  pR( 0 ) ; // сброс флага нахождения в прерывании .
  
  return;
}
