
//         ПРОГРАММЫ ПРИНЯТИЯ ЗАДАНИЯ НА СКОРОСТЬ
//                И АЛГОРИТМА РАБОТЫ УПТФ .
//------------------------------------------------------------------

//    Программа-диспетчер Выбора Способа ШТАТНОГО Задания Скорости и
//  формирования окончательного Штатного Задания на скорость.

word Shtat_ConfigReg ( word code )
{
  word ax ;
  //---

  // Эмуляция счетчика Пульсов сделана как и раньше с жесткой привязкой к 3.3 мс для совместимости со всеми программами ...
  // Если делать нормальный счетчик пульсов - то при аналоговом СИФУ он будет считать когда есть сила ,
  // а при программном СИФУ в ШИМ - когда есть ИУ ...
/*  if ( (u)((w)(timer1 - time_Puls)) > _MkSec( 1000 ) )
  {
      Puls_counter++ ;
      time_Puls = timer1 ;

      // Конфигурационный бит - След для ШИМа или длинный след :
      if ( _or.CfgO._.sld_PWM == 0 ) 
      {        

      }
  }
*/
  // 06.02.2019 08:40 - Перенесено вверх , чтобы выполнялось даже в наладочном режиме :
    //  Выполняем регуляторы раз в 10мсек
  ax = timer1 - time_Reg ;
  if ( (u)((w)ax) > _MkSec( 10000 ) )
  {
    time_Reg = timer1 ;
    time_Integr = ax ;  // Время интегрирования для Регуляторов .
    
    // Когда нет силы ( т.е. Пуска ), обнуляем переменную для индикации скорости по ШИМ-измерениям :
    if ( flgO._.trig_Pusk == 0 ) Skor_Pusk = 0 ;
    else                         Skor_Pusk = SkorRot ;
    
    // Выбор ОС для включения КЗ и индикации ( универсально для АТК и УПТФ ) :
#ifndef _UPTF // Только для АТК .
    if ( _r.Sk_str._.PDF == 1 )
    {
      Skor = SkorPDF ; // Скорость ПДФ , переданная по сети от АР1( в АТК ) .
    }
    else /*if ( _r.Sk_str._.EDS == 1 )*/
#endif
    {                     // Для УПТФ ОС только по ШИМ-измерениям .
      Skor = Skor_Pusk ; // Скорость по ШИМ-измерениям , обнуленная до подачи Пуска .
    }
    
    Skor_ind = Skor ;   // для индикации нефильтрованной скорости .
    Filtr_Sk ( 1 ) ;    // вызов фильтра скорости .
    
    if ( _r.Sk_str._.Sk_filtr == 1 )  Skor = Skor_f ; // замена ОС на фильтр.
    
#ifdef _UPTF
    //------------------------------- ЗАКАЗЧИКУ - Переменные для индикации ---------------------------------------------------
    // Индикация времени Пуска .
    // Считаем время Пуска , пока КЗ отключен , аварий нет и режим рабочий ( а не Наладка ) :
    if ( flgO._.KZ_command == 0 && bo_Avar == 0 && Isp.all == 0 )
    {
      if ((u)((w)(Timer1_Ovr - Time_Zatyan_Pusk)) > 0 ) Timer_Pusk = Timer1_Ovr - Time_Zatyan_Pusk ;
    }
    //------------------------------------------------------------------------------------------------------------------------
    
    ZIDN = _or.I_Ogr ;  // для индикации , даже когда РТ отключен .
    
    if ( Prg._.RegSk == 1 ) // Работа Регуляторов :
    {
      RegTok () ;  // 110mcs
      RegSk () ;  // 150-210mcs
      Linear () ; // 30mcs
    }
#endif
   
    if ( !_or.CfgO._.Vedushiy)
    {
    //------------------------------------------------------------------------------------------------------
    // Рассчет ЗИ угла выполняется раз в 10 мс ( без привязки к тиристору ) :
    // продумать применение в РС УПТФ флагов S.flg._.Fmax и S.flg._.Fmin
    S.flg._.Fmax = 0 ;
    S.flg._.Fmin = 0 ;
    S.flg._.Fdmin  = 0 ;
    S.flg._.Fdmax  = 0 ;
    
    if ( Av._.Sdvig_imp == 1 ) goto sdv ; // сдвиг импульсов в Альфа_Макс.
    s_cx = S.Alfa ;
    
    
    //   Наступление ограничений по ЗИ и ограничителю угла друг друга
    // взаимоисключают;  по-этому поводу будет ссылка ниже ...
      
      //  Ограничитель угла.
#ifndef _UPTF // Для АТК :
      // Принудительной коммутации - Lmax ИУ ротора ( 170 грд ) .
      // Угол управления сдвигаем в 170 грд сразу при входе в режим КЗ ( т.к. при этом на роторе сплошные ИУ ,
      // то какой там угол нам всё равно ) , таким образом готовимся к последующему режиму выхода из КЗ
      // с принудительной коммутацией . Знак "ИЛИ" нужен , т.к. флаг режима КЗ bo_Vkl_KZ снимется при отключении
      // КЗ , а угол управления 170 грд должен остаться до завершения режима принудительной коммутации :
      if ( bo_Vkl_KZ == 1 || flgO._.Prinud_com == 1 ) // DAN 20.07.2017 9:45 - Принудительная коммутация , диапазон
      {                                               //                       угла принимается от 150 до 170 грд :
        if ( s_cx > _Grad( 170 ) )
        {
          s_cx = _Grad( 170 ) ;
          S.flg._.Fmax = 1;
        }
        else if ( s_cx < _Grad( 150 ) )
        {
          s_cx = _Grad( 150 ) ;
          S.flg._.Fmin = 1;
        }
      }
      else
#endif
      {
        if ( s_cx > _r.S_Alfa_Max) // Рабочий Ограничитель угла :
        {
        sdv: s_cx = _r.S_Alfa_Max;
        S.flg._.Fmax = 1;
        }
        else if ( s_cx < _r.S_Alfa_Min )
        {
          s_cx = _r.S_Alfa_Min ;
          S.flg._.Fmin = 1;
        }
      }
      // ЗИ.
      if ( s_cx < S.Alfa_Old  )
      {
        s_ax = S.Alfa_Old - s_cx ;
        
        if ( s_ax > _r.S_DeltaAlfa_Max)
        {
          s_ax = _r.S_DeltaAlfa_Max;      //   если после ограничителя угол сел на ЗИ,
          s_cx = S.Alfa_Old - s_ax ;    //   то, следовательно, ограничение по _r.Alfa_Min если
          S.flg._.Fdmin = 1 ;   //   и было то отпало само собой и по-этому здесь
          S.flg._.Fmin  = 0 ; // <- признак ограничения _r.Alfa_Min сбрасывается.
        }
      }
      else
      {
        s_ax = s_cx - S.Alfa_Old ;
        // из-за перекрытия ИУ нельзя обходить ЗИ
        if ( Av._.Sdvig_imp == 1 ) goto s2 ; // Обход ЗИ при сдвиге импульсов в Альфа_Макс.
        if ( s_ax > (_r.S_DeltaAlfa_Max*2) )
        {
          s_ax = _r.S_DeltaAlfa_Max*2 ;    // если после ограничителя угол сел на ЗИ,
          s_cx = S.Alfa_Old + s_ax ; // то, следовательно, ограничение по AlfaMax если
          S.flg._.Fdmax = 1 ;                // и было то отпало само собой и по-этому здесь
          S.flg._.Fmax = 0;                  // <- признак ограничения Fmax сбрасывается.
        }
      }
    s2: S.Alfa_Old = s_cx;      // раньше это делать нельзя.
    }
    //------------------------------------------------------------------------------------------------------
  }
  
  /*------------ Тестовая проверка работы PPG4 -----------------------
        //----- написать тестовую проверку в фазировке или в Тесте Двых ----
            //Тестовая проверка выхода PPG4 :
        if ( (u)((w)timer1) < _MkSec( 20000 ) ) mPPG4_set( 0 ) ; //PPG_stop( 4, 0 ) ; // Сигнал "0" - 20 мс .
        else                                    mPPG4_set( 1 ) ; //LPC_GPIO2->SET = (1<<0) ; // Сигнал "1" - 45 мс .
        //------------------------------------------------------------------*/

        if ( Prg._.Cikl == 1 )    Cikl () ;

        IdIzm () ; // измерение мгновенного тока Id_mg_ach в "Id_full" .
        IdConv () ;
        Control_Id_Max ()  ;

      //Usrednitel( &Id_usr, 2);
      //Id_Usr = (slw)(sw)Id_usr_full * (slw)(sw)Mashtab.Id / 256 ;

        FiltrLowFreq ( &Id_flt ); // Фильтр мгновенного тока .

  #ifndef _UPTF
        // Перевод среднего в действующее значение :
        //                 ___
        //                 ы 2
        // Iдействующее = ----- * Id  = 0.816 * Id .
        //                 ы 3
        //
        // Id_deystv = (sw)( (slw)(sw)Id_flt.out * (slw)(sw)(( 0.816 * 256.)) >> 8 ) ;
  #else
     //------------------------------------------------------------------------------------------------------------------------
     // Если есть Реле включения и Реле отключения КЗ , то они управляются в
     // импульсном режиме по 130 мс :
     #ifdef bo_Otkl_Kontaktora_KZ
        if ( flgO._.KZ_command == 0 ) // Команда отключить КЗ :
        {
           timerKZ_on = Timer1_Ovr ; // Подтягиваем выдержку на включение КЗ .
           //---
           if ( flgO._.KZ_trig == 1 ) // Если КЗ был включен , держим реле отключения 130 мс :
           {
                bo_Otkl_Kontaktora_KZ = 1 ;
                if ( (u)((w)(Timer1_Ovr - timerKZ_off)) > 2 ) flgO._.KZ_trig = 0 ;
           }
           else bo_Otkl_Kontaktora_KZ = 0 ;
        }
        else // Команда включить КЗ :
        {
           timerKZ_off = Timer1_Ovr ; // Подтягиваем выдержку на отключение КЗ .
           //---
           if ( flgO._.KZ_trig == 0 ) // Если КЗ был отключен , держим реле включения 130 мс :
           {
                bo_Vkl_Kontaktora_KZ = 1 ;
                if ( (u)((w)(Timer1_Ovr - timerKZ_on)) > 2 ) flgO._.KZ_trig = 1 ;
           }
           else bo_Vkl_Kontaktora_KZ = 0 ;
        }
     #else
        // Одно реле для включения/отключения КЗ :
        if ( flgO._.KZ_command == 0 ) // Команда отключить КЗ :
        {
                flgO._.KZ_trig = 0 ;
                bo_Vkl_Kontaktora_KZ = 0 ;
        }
        else // Команда включить КЗ :
        {
                flgO._.KZ_trig = 1 ;
                bo_Vkl_Kontaktora_KZ = 1 ;
        }
     #endif
  #endif

     //------------------------------------------------------------------------------------------------------------------------
     #ifdef bo_GotovZak
        //  Готовность Заказчика :
        // С этим сигналом необходимо быть осторожным . В порту Южном в 2018 г, АСУшники попросили этот сигал вместо нашей
        // Готовности и получили "звонковый" режим включения/выключения ячейки , т.к. у электриков при снятии нашей
        // Готовности снимался Пуск , а при появлении опять подавался ...
        if ( bo_Gotov == 0 )
        {
               bo_GotovZak = 0 ;
        }
        else
        {
          if ( bi_Pusk_0_1 == 1 || bi_Pusk_1_0 == 1 || flgO._.KZ_command == 1 || bo_Zatyan_Pusk == 1 )
          {
               bo_GotovZak = 0 ;
          }
          else bo_GotovZak = 1 ;
        }
     #endif
     //------------------------------------------------------------------------------------------------------------------------


  if ( code != _Shtat_Init ) // Иниц.Штат.Задания, даже если Штат.Реж. не задан
    {
      // Задан ли штатный режим управления ?
      if ( _r.Cfg._.Shtat_reg == 0 || Isp.all != 0 ) return 0 ;
    }

  //-------------
  switch ( code )
    {
      // Инициализация - стартовая опрограмма для задания начальных условий :
      case _Shtat_Init :

        flgO.all = 0 ;

        Skor_Pusk  = 0 ; // Индикация скорости .
        Time_shunt = Timer1_Ovr ;

        // Для Фильтра Инверторного Тока ( АТК роторный выпрямитель ) или тока ротора ( УПТФ ) :
        Id_flt.in    = &Id_dop_kod ;
        Id_flt.tau   = &_or.T_Id_flt ;
        Id_flt.first =  0 ;

        Time_Pusk = Timer1_Ovr ;

  #ifdef _UPTF
        flgO._.KZ_trig = 1 ; // Состояние КЗ - включен ( на всякий случай , чтобы отключить ) .
        timerKZ_on  = Timer1_Ovr ;
        timerKZ_off = Timer1_Ovr ;

        Z_Skor = 0 ; // Для Задания Скорости :
        Alfa_min_time = Timer1_fSec;

        time_T_izm = Timer1_Ovr ;

        T_zad_vedomiy = Timer1_Ovr ; // Выдержка времени для того, чтобы Ведомый увидел по сети "Питание статора" Ведущего .

        Time_shunt_end = Timer1_Ovr ;
        Time_Zatyan_Pusk  = Timer1_Ovr ;
        Timer_Pusk = 0 ; // Индикация времени Пуска .

        Block_Upravl = 0 ; // Блок Управления для входа в работу (пустая метка) .
  #endif

      break;

      // Штатное Управление :
      default:

        if ( Prg._.Gotovn == 1 ) // В Режиме Сборки Готовности :
        {
            S.NumMost = 1 ;             // Инициализируем номер моста , ранее не было .
            mOtkl_Imp( _VR1_imp ) ;     // снимаем ИУ , ранее инициализации этой переменной нет .
            mVkl_Imp( _All_imp ^ _VR1_imp ) ;
          //S.Alfa = _r.S_Alfa_Start ;  // из-за того, что держим угол, нет входа в фазировку ...
  #ifndef _UPTF
            flgO._.Sploshnyak = 0;
            bo_Vkl_KZ = 0 ;
            flgO._.KZ = 0 ;
            flgO._.Prinud_com = 0;
  #else
            Set_ZI ( &zi_rs , 0 ) ;     // обнулять ЗИ.
            OuIchRS = _r.S_Alfa_Start ;
            OuRegS_dop_kod = _r.S_Alfa_Start ;
            OuRegS  = _r.S_Alfa_Start ;
            ZISkor  = 0 ;
            OIRT  = 0 ;  // интегратор регулятора тока
            SP_stup = 0;
            flgO._.Pusk_OK = 0 ; // Снимаем флаг успешного пуска для УПТФ .
            //---

            //  В случае , если это сброс защит при запущенном и работающем АД , то если "Питание Статора" подано , то
            // отключения контактора КМ1 на работающий двигатель не произойдёт :
            if ( flgO._.KZ_command == 1 && bi_QK1 == 0 )
            {
                // 25.11.2021 - Уставка добавлена на УПТФ ПЭСС ИнГОК по просьбе эксплуатации . Грыгорыч сказал ,
                //              что её можно уменьшать до 1-2 сек , это время необходимо для гашения поля статора ,
                //              во избежание перенапряжения на роторе .
                if ((u)((w)(Timer1_Ovr - Time_shunt_end)) > _or.T_otkl_KZ )//_Sec(60) )
                {
                        flgO._.KZ_command = 0 ;
                        flgO._.KZ = 0 ;
                }
            }

            //---
            Time_Zatyan_Pusk = Timer1_Ovr ;
            bo_Zatyan_Pusk = 0 ;
  #endif
            mFzapoln5_stop() ; // снятие ИУ для шунтирующих тиристоров
            //flgO._.VShunt1 = 0 ;
            //flgO._.VShunt2 = 0 ;
            //flgO._.VShunt3 = 0 ;
            flgO._.V_trig = 0 ;
            mPort_ImpV( 0x3f ) ;
            flgO._.trig_Pusk = 0 ;
            flgO._.NeFaznRot = 0 ;
            Time_Pusk = Timer1_Ovr ;
        }
        else // В Режиме Работа :
        {
  #ifndef _UPTF
           //-----------------------------------------
            // Определение Угла Управления в зависимости от знака Выхода РС :
            if ( KTE2_Zatormogen == 1 ) S.Alfa = _r.S_Alfa_Max ; // При нулевом задании скорости .
            else
            {
               if ( KTE2_F2_Isp == 0 )
               {
                 // Принудительной коммутации - Lmax ИУ ротора ( 170 грд ) .
                 // Угол управления сдвигаем в 170 грд сразу при входе в режим КЗ ( т.к. при этом на роторе сплошные ИУ ,
                 // то какой там угол нам всё равно ) , таким образом готовимся к последующему режиму выхода из КЗ
                 // с принудительной коммутацией . Знак "ИЛИ" нужен , т.к. флаг режима КЗ bo_Vkl_KZ снимется при отключении
                 // КЗ , а угол управления 170 грд должен остаться до завершения режима принудительной коммутации :
                 if ( bo_Vkl_KZ == 1 || flgO._.Prinud_com == 1 ) S.Alfa = _or.S_Alfa_Prinud_com ;  // Угол для принудительной коммутации .
                 else
                 {
    #ifndef _FP_N_to_L
                  if ( KTE2_OuRS == 0 ) S.Alfa = _or.S_Alfa_Dvig ; // Угол для разгона .
                  else                  S.Alfa = _or.S_Alfa_Gen ;  // Угол для торможения .
    #else
                  if (!_or.CfgO._.N_to_L)
                  {
                    if ( KTE2_OuRS == 0 ) S.Alfa = _or.S_Alfa_Dvig ; // Угол для разгона .
                    else                  S.Alfa = _or.S_Alfa_Gen ;  // Угол для торможения .
                  }
                  else
                  {
                    if (_or.CfgO._.RT)
                    {
                      if (Prg._.RegTok)
                      {
                        UniReg ( &RT_Str );
                        S.Alfa = Linear (RT_Str.out);    
                      }
                    }
                    else
                    {
                      // Вызов ФП для Угла Управления в зависимости от Скорости :
                      if ( KTE2_OuRS == 0 ) fp_L = &_or.razgFP_N_to_L [ 0 ] ; // Табличка для разгона .
                      else                  fp_L = &_or.tormFP_N_to_L [ 0 ] ; // Табличка для торможения .
                      FP_L ( ) ;
                      S.Alfa = L_after_FP ;    // Угол из табличек .
                    }
                  }
#endif
                 }
               }
               else S.Alfa = _or.S_Alfa_F2_Isp ; // Угол для исп.режимов АР1 - "СИФУ-рез" или "Циклы РТ" .
            }
           //-----------------------------------------
           // Определяем режим Инвертор/Выпрямитель "в лоб" , это нужно для мгновенного
           // или с выдержкой времени снятия ИУ при Герконе :
           if ( S.Alfa_Old <= _Grad( 90 ) )  S.flg._.Invertor = 0 ;
           else                              S.flg._.Invertor = 1 ;
           //-----------------------------------------

            if ( KTE2_Pusk == 1 )
  #else
            if ( bi_Pusk_0_1 == 1 || bi_Pusk_1_0 == 1 )
  #endif
            {
               if (  flgO._.trig_Pusk == 0 && ( (u)((w)(Timer1_Ovr - Time_Pusk)) > _or.T_zaderg_pusk/2 )  )
                  {
                     // Если попутать фазы на роторе , то пила будет считать назад и скорость будет равна 2 номинала .
                     // Определяется этот режим через половину выдержки на подачу Пуска .
                     // Поэтому уставку выдержки на подачу Пуска обнулять нельзя .
                     //----
                     if ( (sw)SkorRot > _Skor_nom( 1.5 ) ) flgO._.NeFaznRot = 1 ;
                     // Сбрасывать флаг нефазности здесь нельзя , т.к. после применения новой таблички ИУ скорость
                     // будет определяться правильно , и флаг нефазности во второй половине выдержки начнет мельтешить ...
                     //----
                     if ( (u)((w)(Timer1_Ovr - Time_Pusk)) > _or.T_zaderg_pusk ) flgO._.trig_Pusk = 1 ;
                  }
            }
            else
            {
               flgO._.trig_Pusk = 0 ;
               flgO._.NeFaznRot = 0 ;
               Time_Pusk =  Timer1_Ovr ;
            }
            //-------------------------------------------

  #ifdef _UPTF
            // 02.05.2018 10:30 - Если подан "Пуск0.1" - даём задание 0.1 , если подали оба Пуска , - даём задание 1.0 :
            if      ( bi_Pusk_1_0 == 0 && bi_Pusk_0_1 == 1 ) Z_Skor = _or.Pusk_0_1 ;
            else if ( bi_Pusk_1_0 == 1 )                     Z_Skor = _or.Pusk_1_0 ;
            else                                             Z_Skor = 0 ;

            //-------------------------------------------

            if ( (bi_Pusk_0_1 == 1 || bi_Pusk_1_0 == 1) && flgO._.trig_Pusk == 1 ) // пришла команда "Пуск"
            {
                // 05.02.2019 - Свич сделан только для однократности включения ИУ и РС :
                switch ( Block_Upravl )
                {
                  default :
                  case 0 :
                  break;

                  case 3 :
                   // Однократное включение ИУ и РС :
                   if ( Otkl_Imp && bi_QK1 == 1 )   mVkl_Imp( _VR1_imp | _Start_imp ) ;  // включение ИУ
                   Prg.all |=  _RegSk ;     // включаем РC
                   Block_Upravl = 0 ; // переход на пустую метку .
                  break;
                }
                //---
                //    Выдержку времени на Затянувшийся Пуск надо отсчитывать с момента подачи Пуска 1.0 .
                // Контролируем время достижения заданнной скорости :
                if ( bi_Pusk_1_0 == 1 )
                {
                   // 29.03.2020 7:54 - По жалобам из ЦКВЗ , после включения КЗ , через 2 минуты
                   // срабатывает "Затянувшийся пуск" , поэтому добавил контроль выдачи команды включения КЗ
                   // "Затянувшийся пуск" срабатывал по скорости , из-за того , что нули в АЦП не были выставлены ...
                   //---
                   // 30.03.2020 - Грыгорыч сказал , что после того , как мы дали команду на включение КЗ ,
                   // контролировать скорость бессмысленно , а для контроля включения КЗ есть своя отдельная функция :
                   if ( ( (sw)Skor < (sw)(Z_Skor - _r.Ostanov_skor) ) && flgO._.KZ_command == 0 )
                   {
                     if ((u)((w)(Timer1_Ovr - Time_Zatyan_Pusk)) > _or.Time_Zatyan_Pusk )
                     {
                       bo_Zatyan_Pusk = 1 ;
                       mSet_AvarMsg( _Av_Zatyan_pusk ) ;
                     }
                   }
                }
                else Time_Zatyan_Pusk = Timer1_Ovr ;
            }
            else
            {
                if ( !Otkl_Imp )  mOtkl_Imp( _Start_imp ) ;  // снимаем ИУ
                Prg.all &=  ~_RegSk ;     // выключаем РC

                S.Alfa = _r.S_Alfa_Start ;
                Set_ZI ( &zi_rs , 0 ) ;   // обнулять ЗИ.
                OuIchRS = _r.S_Alfa_Start ;
                OuRegS_dop_kod = _r.S_Alfa_Start ;
                OuRegS  = _r.S_Alfa_Start ;
                ZISkor  = 0 ;
                OIRT  = 0 ;  // интегратор регулятора тока

                mFzapoln5_stop() ; // снятие ИУ для шунтирующих тиристоров
                flgO._.VShunt1 = 0 ;
                flgO._.VShunt2 = 0 ;
                flgO._.VShunt3 = 0 ;
                flgO._.V_trig = 0 ;
                mPort_ImpV( 0x3f ) ;
                SP_stup = 0;
                flgO._.Pusk_OK = 0 ; // Снимаем флаг успешного пуска для УПТФ .
                //---
                flgO._.trig_Pusk = 0 ; // Снимаем флаг Пуск , но выдержку не обнуляем , иначе флаг никогда не взведётся .
              //flgO._.NeFaznRot = 0 ; // Нельзя снимать , иначе пила реверснётся одновременно с взведением флага Пуск .
                Time_Zatyan_Pusk = Timer1_Ovr ;
                bo_Zatyan_Pusk = 0 ;
            }

            //  Для случая аварийного отключения в работе , то при пропадании "Питание Статора" ,
            // отключаем контактор КМ1 :
            if ( flgO._.KZ_command == 1 && bi_QK1 == 0 )
            {
                // 25.11.2021 - Уставка добавлена на УПТФ ПЭСС ИнГОК по просьбе эксплуатации . Грыгорыч сказал ,
                //              что её можно уменьшать до 1-2 сек , это время необходимо для гашения поля статора ,
                //              во избежание перенапряжения на роторе .
                if ((u)((w)(Timer1_Ovr - Time_shunt_end)) > _or.T_otkl_KZ )//_Sec(60) )
                {
                        flgO._.KZ_command = 0 ;
                        flgO._.KZ = 0 ;
                }
            }
  #else
            // Пришла команда "Пуск" и нет останова привода :
            if ( KTE2_Pusk == 1 && flgO._.trig_Pusk == 1 && Otkl_Imp != _Ostanov_imp )
              {
                if ( Otkl_Imp )
                {
                    mVkl_Imp( _VR1_imp | _Start_imp ) ;  // включение ИУ
                }
              }
            else
              {
                if ( !Otkl_Imp )  mOtkl_Imp( _Start_imp ) ;  // снимаем ИУ
                S.Alfa = _r.S_Alfa_Start ;

                mFzapoln5_stop() ; // снятие ИУ для шунтирующих тиристоров
                //flgO._.VShunt1 = 0 ;
                //flgO._.VShunt2 = 0 ;
                //flgO._.VShunt3 = 0 ;
                flgO._.V_trig = 0 ;
                mPort_ImpV( 0x3f ) ;
                //---
                flgO._.Sploshnyak = 0;
                bo_Vkl_KZ = 0 ;
                flgO._.KZ = 0 ;
                flgO._.Prinud_com = 0;
                //---
                flgO._.trig_Pusk = 0 ; // Снимаем флаг Пуск , но выдержку не обнуляем , иначе флаг никогда не взведётся .
              //flgO._.NeFaznRot = 0 ; // Нельзя снимать , иначе пила реверснётся одновременно с взведением флага Пуск .
              }
            //-------------------------------------------
  #endif
            if ( flgO._.trig_Pusk == 1 ) Control_Pusk () ; // Шунтирование резисторов в зависимости от скорости .
        }

      break;
    }
  return 0 ;
}

//----------------------------------------------------------------------------------------------

// Выполняется в Работе : функция пуска АД - шунтирование резисторов в зависимости от скорости :
void Control_Pusk ( void )
{
  #ifndef _UPTF
  if ( _or.CfgO._.Vkl_KZ == 1 ) // Если в данном АТК предусмотрено включение КЗ :
  {
    // Включение короткозамыкателя по скорости ротора в Двигательном режиме :
    // Проверяем , что мы не в аварии , т.к. при ОС по ШИМ N = 100% при Uрот = 0 .
    // 15.06.2021 - КЗ можно включать только в Двигательном режиме , т.к. выход из КЗ по замедлению двигателя .
    //              Если включить КЗ в генераторном режиме , из него будет трудно выйти , т.к. под тяжестью
    //              груза двигатель сам не уменьшит свою скорость до скорости выхода из режима КЗ .
    // 18.01.2022 - добавляем разрешение включения КЗ от ШУ ШПМ .
    // 24.05.2022 - проверка на то , что мы не в режиме принудительной коммутации - т.е. что мы не в процессе
    //              выхода из режима КЗ , чтобы не войти в релейный режим выход/вход в режим КЗ .
    // 31.05.2022 - Проверка , что Задание Скорости сравнялось с ЗИ скорости , чтобы включать КЗ только в установившемся
    //              режиме и не войти в релейный режим вкл/выкл КЗ :
    if ( (sw)Skor > (sw)_or.N_min[3] && bo_Vkl_KZ == 0 && bo_Avar == 0 && KTE2_OuRS == 0 &&
          KTE2_dt_Otkl_KZ == 0 && flgO._.Prinud_com == 0 && KTE2_Z_Sk_ZISk == 1 ) // Включаем однократно .
    {
             if ( flgO._.Sploshnyak == 0 ) // Выполняем один раз :
             {
               flgO._.Sploshnyak = 1 ; // Подаём сплошные ИУ .
             //timeSploshnyak = Timer1_Ovr ; // 27.06.2022 - пережиток прошлого .
               bo_Vkl_KZ = 1 ; // Включаем Режим КЗ . Ротор Зашунтирован , и АР1 Инвертор кидаем в Альфа Макс .
             }
    }

    // Режим принудительной коммутации :
    if ( flgO._.Prinud_com == 1 ) // Если КЗ включен и пришла команда его отключать путём принудительной коммутации :
    {
        // Ожидаем от AP1 команду на отключение КЗ .
        if ( bo_Vkl_KZ == 1 ) // Выполняем однократно :
        {
          mFzapoln5_stop() ;      // снимаем ИУ КЗ .
          flgO._.V_trig = 0 ;
          mPort_ImpV( 0x3f ) ;
          //---
          flgO._.Sploshnyak = 0 ; // Принудительная коммутация - снимаем сплошняк на роторе и получаем ИУ ротора в 170 грд .
          //---
          // 18.01.2022 - При Принудительной Коммутации сразу, без ожидания замедления подаём ИУ инвертора :
          bo_Vkl_KZ = 0 ; // Отключаем Режим КЗ . Команда на АР1 Инвертор сняться с Альфа Макс и Расшунтировать Регуляторы .
        }

        // 01.02.2022 - Идёт принудительная коммутация , роторные ИУ поданы в угле 170 грд .
        //              АР1 Инвертор снят с Альфа Макс , Регуляторы Расшунтированы , при этом очередной импульс Ротора
        //              оттягивается на 15 мс и на это время держится нулевая полочка тока инвертора ( заданием ) .
        //
        // Ожидаем уменьшение скорости ротора для отключения режима принудительной коммутации :
        if ( (sw)Skor < ((sw)_or.N_min[3] - _Skor_nom( 0.02 )) ) // Гистерезис 2% , чтобы опять не зашунтировать ротор .
        {
          flgO._.Prinud_com = 0 ; // выходим из режима принудительной коммутации .
        }
    }

    //--------------------------------------------------------------

    // 20.06.2022 - Флаг для снятия ИУ в роторном выпрямителе АР2 flgO._.KZ - пережиток прошлого .
    //              На всякий случай , здесь остаётся заготовка для возможности снятия ИУ при выходе
    //              из режима КЗ - если вдруг пила будет сильно деформирована и подать ИУ в 170 грд
    //              в режиме принудительной коммутации не получится . Разобраться на объекте .
    //-------------
    /* Подготовка к включение КЗ - подтяжка выдержки :
    if ( bo_Vkl_KZ == 0 )
    {
       Time_shunt = Timer1_Ovr ;
       flgO._.KZ = 0 ;
    }
    else // Дана команда включить КЗ : */

    if ( bo_Vkl_KZ == 1 ) // Дана команда включить КЗ :
    {
       // Включение КЗ , выполняем однократно :
       if ( flgO._.V_trig == 0 && flgO._.KZ == 0 )
       {
          mFzapoln5_stop() ;  // снимаем
          mFzapoln5_start() ; // подача ИУ на шунтирующий тиристор
          flgO._.V_trig = 1 ;
       }
          // Включаем все три Шунтирующих Тиристора одновременно :
          mPort_ImpV( 0x30 ) ; //ax = 0x30 ; // 11 0000 - V41 (регистратор) , V31 , V24 , V12 ( тиристоры V29 , V28 , V27 соответственно )

          //----------------- Ожидание отключения КЗ -----------------
          // КЗ включен , при приходе Задания Скорости на торможение или просто отрицательного выхода РС снимаем ИУ :
          if ( KTE2_Shunt_End == 1 || KTE2_OuRS == 1 )
          {
            flgO._.Prinud_com = 1 ; // Команда принудительной коммутации - отключение КЗ путём снятия ИУ КЗ .
          }
          //----------------------------------------------------------
    }

    // Для передачи в плату АР1 для изменения коэффициентов РТ в режиме принудительной коммутации :
    if ( flgO._.Prinud_com == 1 ) bo_canPrinud_com = 1 ;
    else                          bo_canPrinud_com = 0 ;

    // Для передачи в плату АР1 :
    if ( bo_Vkl_KZ == 1 ) bo_canShunt_Rot = 1 ; // Ротор Зашунтирован - Инвертор кидаем в Альфа Макс .
    else                  bo_canShunt_Rot = 0 ;
  }
  else // На всякий случай , при отключенном режиме управления КЗ всё инициализируем :
  {
    flgO._.Sploshnyak = 0 ;
  //timeSploshnyak = Timer1_Ovr ; // 27.06.2022 - пережиток прошлого .
    bo_Vkl_KZ = 0 ;
    flgO._.Prinud_com = 0 ;
    flgO._.V_trig = 0 ;
    flgO._.KZ = 0 ;
  }
    //---
  #else

    //---
    // DAN 26.10.2016 16:00 - Николов сказал , что если мы разогнались до скорости включения КЗ ротора ,
    //                        то на угол можно не смотреть , нужно включать короткозамыкатель даже если
    //                        все остальные ступени еще не включились ...
    if ( ( ( S.Alfa_Old <= _or.Alfa_Min_Shunt && (sw)Skor > (sw)_or.N_min[SP_stup]) || (sw)Skor > (sw)_or.N_min[3] )
             && bo_Avar == 0 ) // Проверяем , что мы не в аварии , т.к. при ОС по ШИМ N = 100% при Uрот = 0 .
    {
       if (  (sw)Skor > (sw)_or.N_min[3] )      // DAN - Включение короткозамыкателя происходит без контроля
       {                                        // включения ступеней . Они могут быть и не включены ...
         if ((u)((w)(Timer1_Ovr - Time_Zatyan_Pusk)) > _or.T_min_Pusk ) //_Sec(35) )
         {   // на всякий случай включаем КЗ не раньше , чем через 35 сек :
           /*22.08.2018 21:56 - Николов сказал , что сплошняк не нужен , т.к. при этом бросает ток до герконовой защиты ...
             if ( flgO._.Sploshnyak == 0 )
             {
               flgO._.Sploshnyak = 1 ; // Подаём сплошные ИУ .
               timeSploshnyak = Timer1_Ovr ;
             }
             //---
             if ((u)((w)(Timer1_Ovr - timeSploshnyak)) > _or.Time_Sploshnyak )*/
             {
               flgO._.KZ_command = 1 ; // Включаем КЗ после выдержки на сплошные ИУ ...
             }
         }
       }
       //----
       else if ((u)((w)(Timer1_fSec-Alfa_min_time)) >= _or.Alfa_min_time)
       {
          Alfa_min_time = Timer1_fSec;
            OuIchRS = _or.Alfa_Shunt ; // DAN 19.06.2019 Интегратор инициализируем только ступеней ,
                                       //                     для КЗ интегратор не инициализием .
            if (!flgO._.VShunt1 )
            {
                OuIchRS = _or.Alfa_Shunt ;  // DAN 19.06.2019 - Грыгорыч попросил для каждой ступени свой интегратор .
                //---
                flgO._.VShunt1 = 1 ;
                SP_stup = 1;
            }
            else if (!flgO._.VShunt2 )
            {
                OuIchRS = _or.Alfa_Shunt2 ; // DAN 19.06.2019 - Грыгорыч попросил для каждой ступени свой интегратор .
                //---
                flgO._.VShunt2 = 1 ;
                SP_stup = 2;
            }
            else if (!flgO._.VShunt3 )
            {
                OuIchRS = _or.Alfa_Shunt3 ; // DAN 19.06.2019 - Грыгорыч попросил для каждой ступени свой интегратор .
                //---
                flgO._.VShunt3 = 1 ;
                SP_stup = 3;
            }
       }
    }
    else
    {
       Alfa_min_time = Timer1_fSec;
    }

    //--------------------------------------------------------------

    // Подготовка к включение КЗ - подтяжка выдержки :
    if ( flgO._.KZ_command == 0 )
    {
       Time_shunt = Timer1_Ovr ;
       flgO._.KZ = 0 ;
    }

    //--------------------------------------------------------------

    // КЗ включен - снимаем ИУ :
    if ( flgO._.KZ_command == 1 && flgO._.KZ == 0 )
    {
       if ( bi_Kontaktor_KZ == 1 ) // Если КЗ включен :
       {
           if ( (u)((w)(Timer1_Ovr - Time_shunt)) > _or.Time_snyatIU_KZ )
           {
             flgO._.KZ = 1 ;         // для задержки на снятия ИУ
           }
       }
    }

    // KVV 25-01-19 Проверка включенности контактора, чтобы не спалить его катушку если он не довключился .
    // DAN 21-08-20 Проверка , что КЗ не отвалился , чтобы выдать аварию и отключить ячейку ( тем самым спасти двигатель ) .
    // Если есть команда на включение КЗ, нет б/к КЗ -> по истечении выдержки отключаем КЗ .
    if ( flgO._.KZ_command == 1 )
    {
      if ( bi_Kontaktor_KZ == 0 ) // Контактор не включился :
      {
        // отключить регуляторы , установить угол Альфа-Макс , отсчитать время , выдать аварию , снять ИУ - стандартное действие .
        if((u)((w)(Timer1_Ovr - Time_shunt)) > _or.T_vkl_KZ)
        {
           flgO._.KZ_command = 0 ;
           flgO._.KZ = 0 ;
           mSet_AvarMsg( _Av_KZ_noVkl ) ;
        }
      }
      else // Контактор включился :
      {
        // По истечении выдержки проверяем , не отключен ли след и отключаем его однократно .
        if ((u)((w)(Timer1_Ovr - Time_shunt)) > (_or.T_vkl_KZ + _Sec(0.3)))
        {
            // Отключаем след только если он еще не отключен чем-то другим :
            if ( flgO._.Pusk_OK == 0 && Prg._.Sled == 1 )
            {
                flgO._.Pusk_OK = 1 ; // Флаг успешного пуска для однократности .
                // Однократно отключаем След , чтобы можно было после Пуска его скачать в течении 10 мин :
                Prg.all &= ~_Sled ;
            }
        }
      }

    }

    //--------------------------------------------------------------

    // Подтягиваем выдержку времени на отключение КЗ :
    if ( flgO._.KZ_command == 1 && bi_QK1 == 1 )
    {
       Time_shunt_end = Timer1_Ovr ;
    }

    //--------------------------------------------------------------

    if ( ( flgO._.VShunt1 == 1 || flgO._.VShunt2 == 1 || flgO._.VShunt3 == 1 ) && flgO._.KZ == 0 )
    {
      if ( flgO._.V_trig == 0 )
      {
          mFzapoln5_stop() ;  // снимаем
          mFzapoln5_start() ; // подача ИУ на шунтирующий тиристор
          flgO._.V_trig = 1 ;
      }

       //ax = 0 ;

       if      ( flgO._.VShunt1 == 1 && flgO._.VShunt2 == 0 && flgO._.VShunt3 == 0 )
         {
           mPort_ImpV( 0x37 ) ; //ax = 0x37 ; // 11 0111 - VT4
         }
       else if ( flgO._.VShunt1 == 1 && flgO._.VShunt2 == 1 && flgO._.VShunt3 == 0 )
         {
           mPort_ImpV( 0x27 ) ; //ax = 0x27 ; // 10 0111 - VT4 , VT5
         }
       else if ( flgO._.VShunt1 == 1 && flgO._.VShunt2 == 1 && flgO._.VShunt3 == 1 )
         {
           mPort_ImpV( 0x07 ) ; //ax = 0x07 ; // 00 0111 - VT4 , VT5 , VT6
         }

       //mPort_ImpV( ax ) ;

    }
    else
    {
          mFzapoln5_stop() ; // снимаем ИУ
          flgO._.V_trig = 0 ;
          mPort_ImpV( 0x3f ) ;
          SP_stup = 0;
    }

  #endif

    //--------------------------------------------------------------

    return  ;
}

/*--------------------------------------------------*/

#ifdef _FP_N_to_L
void FP_L ( void ) //Функциональный преобразователь Скорости в Угол Управления .
{
#define  _Ns      14  //  Количество точек кривой угла.
#define   _delta_Fs  (const w)( (_or.N_rot_reg) / _Ns)

  register word ax, cx, bx ;

    bx = Skor ;
    if ( (sw)bx < 0 )  bx = ~bx + 1 ;

        /* нахождение нужного диапазона сельсина */
    if ( bx >= _or.N_rot_reg )    bx = _or.N_rot_reg , cx = _Ns ;
    else                          cx = bx / _delta_Fs + 1 ;

        /* нахождение коэффициента между точками (линейная аппроксимация) */
  ax = *(fp_L+cx) - *(fp_L+(cx-1))  ;
  bx -= _delta_Fs * (cx-1)  ;
  ax = (sw)ax * (sw)bx / (sw)_delta_Fs ;
  ax += *(fp_L+(cx-1)) ;
  L_after_FP = ax ;

 return ;
}
#endif
//----------------------------------------------------------------------------------------------

// контроль Id_Max

#ifdef _Obj_Id_Max

void Control_Id_Max (void)
  {
    if ( IDV >= _r.Id_Max || Irot >= _r.Id_Max )
    {
        mSet_AvarMsg ( _Av_IdMax ) ;
        //----
        // Сигнал ( если он есть ) для передачи в плату АР1 АТК .
      //mOtkl_Q1 () ; // DAN 07.06.2017 15:20 - Формируем cигнал DI - сказал Грыгорыч .
        mSET_Q1() ;   // 01.08.2017 12:47 - Грыгорыч сказал , что сигнал должен держаться в нуле и не долбать .
        //----
        Av._.Id_max = 1 ; // Только для регистрации в аварийном битовом поле .
        Av._.Sdvig_imp = 1 ;   // Команда на задвигание УИ в АльфаМакс.
        //----
        //if ( IDV1 >= _r.Id_Max )
        //if ( IDV2 >= _r.Id_Max ) mSetF_AvarMsg ( _Av_IdMax ) ;
    }

    // Контроль срыва инвертора :
    // Дельта Инверторного и Роторного токов :
    dIrot = IDV - Irot ;
    if ( (sw)dIrot < 0 ) dIrot = ~dIrot + 1 ;
    //----

    // Если дельта токов больше уставки , то - авария срыва инвертирования . контроль Срыва если Ротор Не Зашунтирован .
    // Если ротор зашунтирован , то контроль отключаем , т.к. Id = 0 .
    if ( (sw)dIrot >= _or.dId_sryv && bo_Vkl_KZ == 0 )
    {
      // Сигнал ( если он есть ) для передачи в плату АР1 АТК .
    //mOtkl_Q1 () ;
      mSET_Q1() ;   // 01.08.2017 12:47 - Грыгорыч сказал , что сигнал должен держаться в нуле и не долбать .
      mSet_AvarMsg ( _Av_GerconSN ) ;
    }

    return;
  }

#endif

//-------------------------------------------------------------------------------------------------
//
//      Измерение задания скорости .
//
//    Весь диапазон - от "N#-4mA" до "N#-20mA" . Поэтому типовые уставки "N#-4mA" = 0% , "N#-20mA" = 100% .
//
//    При обрыве датчика ( 0мА ) индицируется задание , соответствующее 4мА , т.е. не падает
// ниже уставки . Но зато при обрыве срабатывает сообщение об обрыве датчика .
//
//    Настройка этой платы :
//  |------|---------|-----------------|
//  |  мА  |  В, АЦП |   %, зад.скор   |
//  |------|---------|-----------------|
//  |   0  |    0    |                 |
//  |   4  |   0.77  |        0        |
//  |  12  |   2.33  |                 |
//  |  20  |   3.89  |       100       |
//  ------------------------------------
//
void  Zad_Skor_4_20 ( word num )
{
//---
#ifndef  Nzad_4_20_ach
//---
  num = num,  Nzad = 0, Nzad_4_20 = 0 ;
//---
#else
//---
  static word Nzad_full, time_Nzad, Nzad_4_20_drob, time_scan ;

  register word ax ;
  register lword lax ;

  switch ( num )
  {      //  Стартовая инициализация.
    case 0 :  Nzad = 0, Nzad_4_20 = 0, time_Nzad = Timer1_Ovr, Nzad_4_20_drob = 0 ;

     start: Nzad_full = _AD_BUSY ;  //  запуск первого измерения
            AD_Izm ( Nzad_4_20_ach, &Nzad_full ) ;
      break;
         //  Рабочая программа.
    case 1 :
          if ( (w)(u)(timer1-time_scan) >= _MkSec(10*1000) )
          {
            time_scan = timer1 ;
            //---

            if ( Nzad_full != _AD_BUSY )
             {
               mIzmData_Conversion ( Nzad_full, ax, Nzad_4_20_ach ) ;
              ax =(w)((d)ax * _20mA_Nom /(d)(_AD_MAX * 0.8));

                 //---   Фильтруем, т.к. на Белой Церкви на 4-20мА были пульсации 200Гц с амплитудой до 15%.
                     //  Лобода ВД предполагал, что это пульсации ШИМ-регулятора в источнике блока формирующего 4-20.
               lax  = (lw)Nzad_4_20 << 16,    lax += (lw)(w)Nzad_4_20_drob ;
                 lax += (slw)( ((lw)ax << 16) - lax ) / (sw)(_or.Filtr_Param_Nzad * 2)  ;  // *2 - т.к. слишком глубокие пульсаци сигнала.
               Nzad_4_20 = (w)( lax >> 16 ),   Nzad_4_20_drob = (w)lax ;
                 //---

               ax = Nzad_4_20 ;

               //                              Nzad_20mA(%)-Nzad_4mA(%)
               //     Nzad = Nzad_4mA(грд) + ----------------------------  * (I-4mA)
               //                                         16mA

               ax -= _1mA_nom( 4 ) ;
               if ( (sw)ax <= 0 )  ax = 0 ;

               // Задание скорости в "%" :
               Nzad = _or.Nzad_4mA + (w)( (lw)(w)(_or.Nzad_20mA - _or.Nzad_4mA ) * (lw)(sw)ax / _1mA_nom( 16 ) ) ;

            //--------------------

               goto start; //  запуск очередного измерения.
             }
          }
      break;

    case 2 :                                          // Защита от обрыва 4-20мА.
               if ( /*(sw)Nzad >= (sw)_or.Nzad_predupr ||*/ (sw)Nzad_4_20 <= (sw)_1mA_nom( 3 ) )
               {
                 if ( (u)(w)(Timer1_Ovr-time_Nzad) > _Sec( 1.0 ) )
                 {
                   // Для создания "защелки" при обрыве задания :
                   //flgO._.obryv_Nanal = 1 ;
                   mSet_PreduprMsg( _Pr_Nzad_obryv ) ;
                 }
               }
               else
               {
                   //flgO._.obryv_Nanal = 0 ;
                   time_Nzad = Timer1_Ovr ;
               }

      break;
  }
//---
#endif
//---
  return ;
}
