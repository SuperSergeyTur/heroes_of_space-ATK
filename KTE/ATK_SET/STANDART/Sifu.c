
//ДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДД
//
//                Принцип построения СИФУ:
// - СИФУ формирует ИУ с подтверждающими;
// - длина ИУ задается через "#define" либо уставкой либо внешней переменной.
// При задании длины в диапазоне "3грд...(Lизм-2грд)" формируются короткие ИУ.
// При задании длины более "Lизм-2грд" длительность дискретно переключается
// на 120грд (в статике). При коротких ИУ СИФУ специально формирует задний
// фронт ИУ. При длинных ИУ задний фронт специально не формируется, а
// получается сам по себе: i+2й тиристор записывая свой код в регистр ИУ
// затирает ИУ i-того тиристора.
//-----------------------------------
//   Для однофазной схемы (для F16): 27.01.06 10:58 для НТЗ привод подачи станка:
// - в "inc.c" и "inc2.c" перед "include.h" следует задать
//   #define  _SIFU_1Faza;
// - в "obj.h" следует переназначить порт ИУ:
//#undef    mPort_Imp//( data )
//#undef    Port_imp_copy
//#undef    mClr_ImpVozb//()
//#define   mPort_Imp( data )  mPort_ImpTorm( data )
//#define   Port_imp_copy      tPort_imp_copy
//#define   mClr_ImpVozb()     mClr_ImpTorm()
//#undef   mFzapoln1_start//()
//#undef   mFzapoln1_stop//()
//#define  mFzapoln1_start()   mFzapoln2_start()
//#define  mFzapoln1_stop()    mFzapoln2_stop()
//
// - измерения Id, Ud и отработка регуляторов производятся один раз в
//   три пульса - на 1-м и 4-м;
// - задана своя таблица ИУ в sifu.h;
// - на тир-ры должны уходить сигналы с порта в следующем соотв.:
//   D0 - VS1/"A"-катодн.
//   D1 - VS2/"B"-анодн.
//   D2 - VS3/"B"-катодн.
//   D3 - VS4/"A"-анодн.
// - в части реверса ничего не продумывалось.
//
//   Для однофазной схемы следует задать следующие уставки в "ust_cnst.h":
//   /* word  S_Alfa_Start ;  */   _Grad( 170 ) ,
//   /* word  S_Alfa_Max ;    */   _Grad( 170 ) ,
//   /* word  RTMAX;          */   _Grad( 179 ) ,
//
//-----------------------------------

//---
#ifdef  _SIFU_Syn2    // ЕСТЬ ЛИ ОТДЕЛЬНАЯ СИНХРОНИЗАЦИЯ ОТ МОСТА ДЛЯ СИФУ.
//---
word Synch2_Start ( void )
  {
      // настройка EPA - передаем его условный номер.
    init_syn_epa( _synch2_epa_con ) ;

    Syn2.epa_time = (w*)&_synch2_epa_time ;

    Sync_start ( &Syn2 ) ;   // остальная инициализация.

    return  0 ;
  }
//---
//      В КТЭ со второй синхр. со входа моста СИФУ привязано по прежнему
//  к синхр. от блока питания, чтобы было удобно фазироваться (не под силой)
//  и проверять чередование ИУ без силового напряжения.
//      При появлении силового напряжения в этой п.п. производится перерасчет
//  уставок фазировки исходя из того, что если блок питания запитан прямо от
//  силы то его синхр. совпадает с синхр. от силы и подходят подобранные типовые
//  уставки. Если блок питания запитали из-вне, то по отклонению его синхр. от синхр.
//  силы производится перерасчет фазировки, компенсирующий этот сдвиг.
//
//  НУЖНО ЛИ КОРРЕКТИР. ФАЗИРОВКУ ВЕДОМОГО МОСТА ПОКА НЕ РАЗБИРАЛСЯ.
void Correct_Fazir ( word code )
  {
    static word time, fx ;
    static byte       nx ;
    register  word  ax ;
    register lword lax ;

    if ( code == 0 ) // Инициализация.
    {
      pSyn = &Syn ;  // перепривязываемся к базовой синхр.
      nx = _r.S_FazirovVS ;
      fx = _r.S_FazirovUgol ;
      time = Timer1_Ovr ;
      return ;
    }//-----------------------

    if ( Num_obl == 0 ) return ; // ожидаем разблокировки от "АЕ-Зап.Устав" или др.
      //---
    // 24.02.2016 - Проверка отключения автофазировки :
    if ( _r.Cfg2._.SIFU_Syn2 == 0 )
    {
          asm_di();
            pSyn = &Syn ;  // перепривязываемся к базовой синхр.
                           // уставки фазировки больше не перебиваем , нужно фазироваться вручную ...
          Tsyn2 = _MkSec( 20000 ) ; // чтобы не зависло значение периода .
          asm_ei();
      return ;
    }
      //---
    if ( Syn2.b_SIauto == 0 )
    {
      if ( (u)(w)(Timer1_Ovr-time) > 3 )
      {
        //if ( pSyn != &Syn ) чтобы не схватить не пересчитанные уставки.
        //{
          asm_di();
            pSyn = &Syn ;  // перепривязываемся к базовой синхр.
            _r.S_FazirovVS   = nx ;  // с ранее расчитанными
            _r.S_FazirovUgol = fx ;  //               уставками.
          asm_ei();
          Tsyn2 = _MkSec( 20000 ) ; // чтобы не зависло значение периода .
        //}
      }
      return ;
    }
    else
    {
      time = Timer1_Ovr ;
        //---
      //if ( pSyn != &Syn2 )
      {
        asm_di();
          pSyn = &Syn2 ;  // перепривязываемся к синхр. моста
          _r.S_FazirovVS   = _c.S_FazirovVS ;   // с типовыми уставками.
          _r.S_FazirovUgol = _c.S_FazirovUgol ; //
        asm_ei();
      } //---
      if ( Syn.b_SIauto  == 0 )  return ;
    }
 //   Перерасчет уставок фазир. на будущее, когда исчезнет синхр.моста и надо
 //  будет перекл. на синхр. блока питания.
    //if ( Syn.b_SIauto  == 0 || Syn2.b_SIauto == 0 )  return ;
    Syn.b_SIauto  = 0,  Syn2.b_SIauto = 0 ;
      //---------------
  // Zakryvat ot suda i do returna...

  // if ( Num_obl == 0 )      return ; // ожидаем разблокировки от "АЕ-Зап.Устав" или др.
  // if ( Prg._.Gotovn == 0 ) return ;
          // Вычисление интервала от силовой синхр. до синхр.блока питания.
      ax = Syn2.NS2 - Syn.NS2 ; // NS2 - отфильтрованный момент синхроимпульса.
      //Перевод в градусы
      lax = (slw)(sw)ax << 15 ;
      ax = Tsyn ;
      ax = (slw)lax / (sw)ax ;
        //   Если интервал до синхроимп. больше 180грд. то:
      if ( (sw)ax < 0 )
        {
          if ( (u)(w)(~ax + 1) > _Grad( 180 ))  ax +=  _Grad( 360 ) ;
        }
      else
        {
          if ( (u)(w)ax > _Grad( 180 ))         ax -=  _Grad( 360 ) ;
        }
        //--------  Приводим диапазон из 0...+-180грд в 0...+360грд, чтобы
        // было меньше ветвей вычисления коррекции.

      if ( (sw)ax < 0 )  ax += _Grad( 360 ) ;
      nx = _c.S_FazirovVS - ax / _Grad( 60 )  ; // подбор ТЕК.
      fx = ax % _Grad( 60 ) ;
      fx += _c.S_FazirovUgol ;

      if ( fx >= _Grad( 60 ) ) fx -= _Grad( 60 ), nx-- ;
      if ( (sb)nx < 1 ) nx += 6 ;
        //--------
    return  ;
  }
//---
#endif
//------------------------------
// Программа старта СИФУ.

  word SIFU_Start ( void )
  {
    S.NumMost = 0x1 ;
#ifdef _F16e

    mIU_Enable();

    mPort_Imp(FOR0[0][0]) ;

#else

    mPort_Imp(FOR0 [0]) ;

#endif
    mVkl_Imp ( _All_imp ) ;  // Otkl_Imp &= ~( 0xFFFFu) очистка регистра снятия импульсов
    mOtkl_Imp ( _Start_imp ) ;  // Otkl_Imp |= ( 0x8000u )программа стартует со снятыми импульсами

    // 17.08.2010 13:20 - не нужно , все флаги уже проинициализированы .
    //flg_RaTe._.Id_anastr = 0; // инициализация флага дополнительных измерений тока для Автонастройки .

  //   Расчет времени выдачи первого импульса .

    //S.flg._.Revers  = 0 ,  S.flg._.Invertor= 0 ;
    S.flg.all = 0 ;

    s_cx = _r.S_Alfa_Start ;
    S.Alfa = s_cx ;

      //  Ограничитель угла.
    if ( s_cx > _r.S_Alfa_Max )
      {
        s_cx = _r.S_Alfa_Max;
        S.flg._.Fmax = 1 ;
      }
    else if ( s_cx < _r.S_Alfa_Min )
           {
             s_cx = _r.S_Alfa_Min ;
             S.flg._.Fmin = 1 ;
           }
    S.Alfa_Old = s_cx ;   // раньше это делать нельзя.

    S.N = _r.S_FazirovVS  ;

       // здесь используется промежут. ячейка NIP  чтобы сэкономить время в прерывании.
#ifndef _F16e
    S.NIP = FOR0 [0] ;
#else

    S.NIP = FOR0[0][0] ;

#endif
    S.NumInt = 1 ;
    S.Disable  = 0; // для 12-ти пульсного СИФУ , запрет при работе только РТ2 .

   // pSyn = &Syn ;// Для начала привязываемся к базовой синхр., а затем,
    pSyn->b_SIv = 0 ; // если есть вторая синхр., то она и разберется...

    S.TZ = pSyn->NS2  ; // усредненный момент прихода СИ.
    S.TZ += (w)( (lw)( _r.S_FazirovUgol + s_cx ) * (lw)Tsyn >> 15 )  ;

    _r_S_ImpLong = _r.S_ImpLong ; // задаем изначально короткие, т.к. и
                                // частот.заполн. настраивается под короткие ИУ.
    /* Конец импульса и номер порта УИ описываются до того, как заряжать EPA */
    /* на случай, если  EPA сработает сразу же после его зарядки             */

    Ud_off = 0, Id_off = 0 ;
          /* Зарядка ЕПА на угол измерения тока */

    init_sifu_epa( _sifu_epa_con ) ;

    _sifu_epa_time ( S.TZ - (w)( (lw)_r.S_Alfa_IzmDoImp * (lw)Tsyn >> 15 ) );

  #ifdef  _SIFU2_
    SIFU2_Start (0) ;
  #endif
    return 0 ;
}

//         ПРОГРАММА УПРАВЛЕНИЯ СИФУ ПРЕОБРАЗОВАТЕЛЯ.
//------------------------------------------------------------


// Программа-прерывание управления преобразователем.

void S_Interrupt ( void )
  {
     enum {i0,i1,i2,i3};
//---------------------
    pS( 1 ) ;

beg_imp:
       // Объектное (под процессор) дополнение для прерываний:
    Sifu_int_drv(_sifu_epa_con) ;  // сброс запроса прерывания.

//---------------------
#ifdef  mVObj_mask    // Объектное дополнение для прерываний:
    mVObj_mask() ;  // разрешения pts-EPA0 для частотного заполнения.
#endif
//---------------------
  //12.10.2016 - Перенесено в передний фронт ИУ , где ему и место ...
  //S.flg._.BegImp = 1 ;  // 08.08.05 09:36
         //  разрешить  прерывания для АЦП, гашения ИУ .
    asm_ei() ;

  switch( S.NumInt )
  {
  case i1 :
       //Первый заход - задаются измерения до импульса
  #ifdef  Ud_ach
      Ud_full = _AD_BUSY ;
      mAD_Izm (  Ud_ach  , &Ud_full ) ; // ИЗМЕРЕНИЕ  "Ud"
  #endif

#ifdef _AVTONASTR
    if ( flg_RaTe._.Id_anastr != 0 ) // Дополнительные замеры тока сразу после Ud .
    {
      Id_full = _AD_BUSY;
      mAD_Izm (  Id_mg_ach  , &Id_full ) ; // ИЗМЕРЕНИЕ  "Id_Full"
    }
#endif

  #ifdef  Ud_ach // Не выполнять в случае , если нет измерения Ud .
      //    У 590 процессора 2 измерения ( Ud и Id ) , расположенные рядом , правильно не имеряются . Измеряется первое , в
      // данном случае Ud , а  второе ( Id ) измеряется уже после формирования переднего фронта ИУ , т.к. оно просто не
      // успевает выполниться перед ожиданием формирования переднего фронта ИУ . Поэтому здесь ожидаем формирования
      // первого измерения, для того, чтобы второе успело зарядиться до входа в цикл ожидания формирования переднего фронта :
      while ( Ud_full == _AD_BUSY );
  #endif

#ifdef  EDS_ach
      iEDS_full = _AD_BUSY;
      mAD_Izm (  EDS_ach  , &iEDS_full ) ;
#endif

#ifdef _ATK_SET
      // Измерения для определения гранично-непрерывного тока :
      Id_full = _AD_BUSY;
      mAD_Izm (  Id_mg_ach  , &Id_full ) ; // ИЗМЕРЕНИЕ  "Id_Full"
#endif
   //------
    /*      // Переключаем частотное заполнение, как разрешение.
      if ( Otkl_Imp == 0 )
      {
        if      ( S.NumMost == 1 ) {  mFzapoln1_start() ; }
        else if ( S.NumMost == 2 ) {  mFzapoln2_start() ; }
      }*/
   //-----
#if defined( Id_sr_ach ) || ( defined( _CM3_ ) && defined( _KTEV ) && defined( _RVId ) )
    set_strob_usredn() ;
#endif
      //Теперь ожидаем время начала импульса
    asm_di();//Чтобы не влезло левое прерывание

      do  s_ax = S.TZ - timer1 ;
      while ( (u)s_ax < (w)Tsyn  );

 /*     if ( Otkl_Imp == 0 )
      {
        if      ( S.NumMost == 1 ) {  mFzapoln1_start() ; }
        else if ( S.NumMost == 2 ) {  mFzapoln2_start() ; }
      }
 */
#ifdef  _IU_60_Qubler         // Для случаев с программным частотным заполнением ,
  Short_ImpLongQubler ( 0 ) ; // когда нужно менять частотное заполнение в самом ИУ .
#endif
            // Запрет из реверса или запрет при работе только РТ2 .
     if ( S.flg._.ZapretImp == 0 && S.Disable == 0 )
      {
       if ( _r.Cfg._.DZV == 1 )
        {
          if ( S.flg._.Revers == 1 ) // если в ведущем СИФУ сняты подтверждающие,
          {   // то в ведомом снимаем ИУ совсем, как только появился один из ДЗВ.
#ifdef _F16e
            Port_input ( 3 ) ;
            if ( bi_DZVA == 1 || bi_DZVK == 1 ) S.flg._.SnImpVM = 1 ;
#else
            if ( DZVA_Ok() || DZVK_Ok() ) S.flg._.SnImpVM = 1 ;
#endif
          }
          else  S.flg._.SnImpVM = 0 ;
          //---
          if ( S.flg._.SnImpVM == 0 )
          {
            S.flg._.ImpSet1 = 1 ; // для запрета контроля ДЗВ в реверсе.

            //mFzapoln_trg() ;
            if ( Otkl_Imp == 0 )
            {
                if      ( S.NumMost == 1 ) {
                                              mFzapoln1_stop() ;// снимаем оба частотных заполнения.
                                              mFzapoln1_start() ;
                                            }
                else if ( S.NumMost == 2 ) {
                                              mFzapoln2_stop() ;// снимаем оба частотных заполнения.
                                              mFzapoln2_start() ;
                                            }
            }
            else goto xxx ; // При срабатывании геркона Otkl_Imp без выдержек и S.NIP не пишется.
            mPort_Imp(S.NIP) ;
            S.flg._.BegImp = 1 ; //12.10.2016 - Перенесено в передний фронт ИУ , где ему и место ...
          }
        }
        else
        {
          //mFzapoln_trg() ;
         //S.flg._.SnImpVM = 0 ;
            if ( Otkl_Imp == 0 )
            {
                if      ( S.NumMost == 1 ) {
                                              mFzapoln1_stop() ;// снимаем оба частотных заполнения.
                                              mFzapoln1_start() ;
#ifdef _ATK_SET // Форсировочный импульс , передний фронт .
    mPPG1_forsir_set( 1 );
#else
                                            }
                else if ( S.NumMost == 2 ) {
                                              mFzapoln2_stop() ;// снимаем оба частотных заполнения.
                                              mFzapoln2_start() ;
#endif
                                            }
            }
            else goto xxx ; // При срабатывании геркона Otkl_Imp без выдержек и S.NIP не пишется.
            mPort_Imp(S.NIP) ;
            S.flg._.BegImp = 1 ; //12.10.2016 - Перенесено в передний фронт ИУ , где ему и место ...
        }
      }
      else
      {
  xxx:
#ifndef  _F16e
        mFzapoln1_stop() ;// снимаем оба частотных заполнения.
        mFzapoln2_stop() ;// снимаем оба частотных заполнения.
        mPort_Imp( FOR0 [0] ) ;
#else

        mPort_Imp( FOR0[0][0] ) ;

#endif
      }
      //Clr_DZV() ; // очистка ДЗВ по переднему фронту ИУ.
    asm_ei();
   //-----
#if defined( Id_sr_ach ) || ( defined( _CM3_ ) && defined( _KTEV ) && defined( _RVId ) )
    clr_strob_usredn() ;
#endif
   //-----
         //  Расчет времени гашения ИУ: не даем заступить точке гашения за
         // точку измерения.
      s_ax = _r.S_Alfa_IzmId - _Grad( 5.0 );
      if ( _r_S_ImpLong < s_ax )  s_ax = _r_S_ImpLong ;

      s_ax = S.TZ + ( (lw)s_ax * (lw)Tsyn >> 15 ) ;
                 // перезарядка ЕПА
      //_sifu_epa_time (s_ax); // зарядка конца импульса

      S.NumInt = 2 ;
      Puls_counter++ ;
       //-------

      if ( Prg._.Cikl == 1 )    Cikl () ;

      /*if ( _r.Sk_str._.TG == 1 )*/  Izm_TG (1) ;  // 12.04.2011 - чтобы можно было видеть ТГ всегда .

      obj_ConfigReg ( _Obj_N_OS ) ; // Объектная ОС по скорости .

  asm_di() ;
      //---   Проверка на опоздание ИУ. Если опоздал, то переход тут же к началу ИУ.

    s_cx = s_ax - timer1 ;
    if ( (u)s_cx < (w)Tsyn*2  &&  s_cx >= _MkSec( 50 ) )
    {
                 // перезарядка ЕПА
      _sifu_epa_time( s_ax ) ; // зарядка начала импульса

  asm_ei() ;
    }
    else
    {
  asm_ei() ;

      do  s_cx = s_ax - timer1 ;
      while ( (u)s_cx < (w)Tsyn*2  );

      goto end_imp ;
    }

    break;
     //-------------

  case i2 :
end_imp: ;

#ifdef _ATK_SET // Форсировочный импульс , задний фронт , 440 мкс .
      mPPG1_forsir_set( 0 );
#endif
      //   Задний фронт формируем только при коротких ИУ.
      //  При длинных ИУ задний фронт формируется затиранием очередным ИУ
      // предыдущего, т.е. в статике длина ИУ составляет 60 или 120грд.
      s_ax = _r.S_Alfa_IzmId - _Grad( 5.0 );
      //---
      // Политика Партии для КТЭВа и схемы Кюблера :
      //--------------------------------------------
      // 1. Обычная схема КТЭВа - короткие ИУ :
      //    1.1. При флаге реверса (Снятие Подтверждающих Импульсов) .
      //    1.2. При токе большем , чем ток удержания .
      // 2. Схема Кюблера - короткие ИУ при :
      //    2.1. При флаге реверса (Снятие Подтверждающих Импульсов) .
      // В остальных случаях ИУ длинные .
      //---
      // 25.02.2008 19:17 - флаг реверса перенесен в Short_ImpLong(), чтобы не переключать
      // ошибочно на длинные ИУ при реверсе .
      //---
      // При настройке агрегата на 200А на номинал 5А , обратные токи утечки мощных
      // тиристоров составили 3% при нулевом задании на ток "S.flg._.ZadNull" . Это было
      // вызвано длинными ИУ. При коротких ИУ такого эффекта , конечно , нет и при нулевом
      // задании почти нулевой ток . Но такая борьба смысла не имеет и как сказал Виталик -
      // а не надо настраивать 200А агрегат на 5А !
      //---
      if ( Otkl_Imp != 0x0 // || S.flg._.Revers == 1 //|| S.flg._.ZadNull == 1
#ifndef  _IU_60_Qubler
           || _r_S_ImpLong < s_ax
#else
           || Short_ImpLongQubler ( 1 ) == 1 // Пересчитываем скважность ИУ , "1" при реверсе .
#endif
         )
      {
        goto yyy ; // заглушка, чтобы не возмущался компил. на пустую 'yyy:'.
yyy:
#ifndef _F16e
        mPort_Imp(FOR0[0]) ;
        mFzapoln1_stop() ;// снимаем оба частотных заполнения.
        mFzapoln2_stop() ;
#else

        mPort_Imp(FOR0[0][0]) ;

#endif
        S.flg._.ImpSet1 = 0 ; // для разрешения контроля ДЗВ в реверсе.
              // если импульс не был сформирован, то даем накопиться ДЗВ.
#ifndef _F16e
        if ( S.flg._.SnImpVM == 0 ) Clr_DZV() ; // очистка ДЗВ по заднему фронту ИУ.
#endif
      }
#ifdef  _IU_60_Qubler // убираем перекрытие ИУ, но продолж.основной ИУ до 60грд.
      else mPort_Imp( FOR1[S.N] ) ;  // импульсы без подтверждающих
#else    // стоит специально после срезания ИУ, чтобы укоротить текущий длинный ИУ
  #if !(defined(_KTE)) || defined(_ATK_SET) // 29.07.2020 - Вызывается также для реверса АТК .
     if ( Short_ImpLong() == 1 ) goto yyy ; // и начать следующий ИУ уже с новым PPG.
     // 25.02.2008 19:17 - При таком алгоритме переключения длины и скважности ИУ :
     // 1. При переходе с длинных на короткие : первый короткий ИУ будет с заполнением 10х70 ,
     //    а следующие уже с родной скважностью 10х10.
     // 2. При переходе с коротких на длинные : закончится последний начатый короткий ,
     //    произойдет перерасчет длины и скважности на длинные с возвратом "0" , затем
     //    первый длинный ИУ будет с родным заполнением 10х70 .
  #endif
#endif
     //-------------

                // зарядка точки измерения Id.
      s_ax = S.TZ + (w)( (lw)_r.S_Alfa_IzmId * (lw)Tsyn >> 15 )  ;
      _sifu_epa_time( s_ax) ;
    S.NumInt = 3 ;
      //---------
             // проверка готовности изм. Ud.
  #ifdef  Ud_ach
      while ( Ud_full == _AD_BUSY  );
        //Преобразование измеренного напряжения , которое измерялось до импульса
      mIzmData_Conversion ( Ud_full , s_ax ,  Ud_ach   ) ;
      s_ax = (slw)(sw)s_ax * (slw)(sw)Mashtab.Ud / 256 ;
    //s_ax = (sw)( (slw)(sw)s_ax * (slw)(sw)_r.Mashtab_Ud >> 8 ) ;
  #else
      s_ax = 0 ;
  #endif

#ifdef _AVTONASTR
    if ( flg_RaTe._.Id_anastr != 0 ) // Дополнительные замеры тока сразу после Ud .
    {
      while ( Id_full == _AD_BUSY );
      mIzmData_Conversion ( Id_full , Id_AN_imp ,  Id_mg_ach   ) ;
      Id_AN_imp = (slw)(sw)Id_AN_imp * (slw)(sw)Mashtab.Id / 256 ;
    //Id_AN_imp = (sw)( (slw)(sw)Id_AN_imp * (slw)(sw)_r.Mashtab_Id >> 8 ) ;
    }
#endif

#ifdef _ATK_SET
      // Измерения для определения гранично-непрерывного тока :
      while ( Id_full == _AD_BUSY );
      mIzmData_Conversion ( Id_full , Id_IU ,  Id_mg_ach   ) ;
      Id_IU = (slw)(sw)Id_IU * (slw)(sw)Mashtab.Id / 256 ;
      if ( (sw)Id_IU < 0 ) Id_IU = ~Id_IU + 1 ;
      //---
      // Запоминаем предыдущий режим и определяем текущий ( прерывистый или непрерывный ) :
      flgO._.Id_neprer1 = flgO._.Id_neprer ;
      if ( Id_IU < _or.Id_IU )
      {
         i_prer ++ ;
         i_nepr = 0 ;
         if ( i_prer >= _or.i_count )
         {
              i_prer = _or.i_count ;
              flgO._.Id_neprer = 0 ;
         }
      }
      else
      {
         i_nepr ++ ;
         i_prer = 0 ;
         if ( i_nepr >= _or.i_count )
         {
              i_nepr = _or.i_count ;
             flgO._.Id_neprer = 1 ;
         }
      }
#endif

  #ifdef  _SIFU_1Faza
         //Для однофазной схемы ДатЭДС вызывается после 1 и 4 тиристоров
      Ud_off += s_ax ;   // nakaplivaem
             // для рабочего ИУ и пропущенного ИУ: для линейности,
             // т.к. между ИУ Ud затягивается в "-", а сами пики большие.
      if ((S.N != 1 )&&(S.N != 4) ) goto out1 ;
      s_ax = (sw)Ud_off/3, Ud_off = 0 ; // берем среднее Ud
  #endif

      UdSr = s_ax ;

  #ifdef  _RS_10ms_
    if ( PDF[0].flg._.new_izm_pdf == 1 )   //вызывается раз в 10ms
  #endif
     {      /* Выбор типа датчика ЭДС. */
       /*if ( _r.Sk_str._.DatEDS  == 0 )*/  DatEDS_Ud () ; // 120-150mcs 21.01.04 09:21
       //else                               DatEds () ;    // 100-170mcs

       Izm_Skor_EDS () ; // Вычисление рассчетной скорости по ЭДС ( и Потоку ) .
     }
  #ifdef  _SIFU_1Faza
   out1:;
  #endif

  #ifdef  _RS_10ms_
    if ( PDF[0].flg._.new_izm_pdf == 1 )   //вызывается раз в 10ms
  #endif
     {
      //---// Можно перебить все обратные связи объектной :
      if ( obj_ConfigReg ( _Obj_N_OS ) == 0 ) // Объектная ОС по скорости .
      {
       Izm_TG (2) ; // 12.04.2011 - вынесено , чтобы можно было видеть ТГ всегда .
         //  Выбор обратной связи по скорости.
       if ( _r.Sk_str._.TG  == 1 )
        {
          Skor = TG ;
          #ifdef bi_Revers_Polja
            // При реверсе поля меняется только знак обратной связи по скорости
            if ( bi_Revers_Polja == 1 )  Skor = ~Skor + 1 ;
          #endif
        }
/*       else if ( _r.Sk_str._.PDF == 1 ) // 60mcs
        {
          Skor = PDF[0].out_m ;
          #ifdef bi_Revers_Polja
            // При реверсе поля меняется только знак обратной связи по скорости
            if ( bi_Revers_Polja == 1 )  Skor = ~Skor + 1 ;
          #endif
        }*/
       else if ( _r.Sk_str._.EdsIIzona == 1 )
        {
          Skor = Skor_r ; // При реверсе поля ЭДС знак не меняет .
        }
       // При реверсе поля ЭДС знак не меняет
       else/*if( _r.Sk_str._.EDS == 1 )*/ Skor = EDS_dop_kod ;
     /*{                      //05.05.2017 14:12 - по просьбе Тарана , масштабируем ОС по ЭДС для удобства индикации :
          // АППАРАТНЫЙ ДЭДС :
          if ( _r.Sk_str._.EDS_Appar == 1 ) Skor = (sw)( (slw)(sw)EDS_dop_kod * (slw)(sw)_or.Mashtab_N_po_EDS >> 8 ) ;
          // ПРОГРАМНЫЙ ДЭДС :
          else                              Skor = (sw)( (slw)(sw)EDS_dop_kod * (slw)(sw)_or.Mashtab_Npr_po_EDS >> 8 ) ;
       }*/
      }
      //---
       //-----
       Skor_ind = Skor ; // для индикации нефильтрованной скорости .
       Filtr_Sk ( 1 ) ; // вызов фильтра скорости .
       // DAN 23.11.2016 14:15 - Фильтр вводится только для ДС или для аналогового ДЭДС ,
       //                        два раза фильтровать программную ЭДС нельзя !
       // DAN сентябрь 2019 - Клетевой подъем Черемуховская - лучше иметь возможность фильтровать все ОС :
       if ( _r.Sk_str._.Sk_filtr == 1 /*&& (_r.Sk_str._.TG == 1 || _r.Sk_str._.PDF == 1 ||
                                          _r.Sk_str._.EDS_Appar == 1)*/ )  Skor = Skor_f ; // замена ОС на фильтр.
       //-----
     }

    break;
     //-------------

  case i3 :  S.NumInt = 1 ;

      IdIzm () ; // измерение мгновенного тока Id_mg_ach в "Id_full" .

         //--------
  #ifdef  _SIFU_1Faza
         //Для однофазной схемы РТ вызывается после 1 и 4 тиристоров
      if ((S.N != 1 )&&(S.N != 4) )
      {        // usrednyaem tok mezhdu pulsami.
        while ( Id_full == _AD_BUSY );
        mIzmData_Conversion ( Id_full , s_ax ,  Id_mg_ach   ) ;
        s_ax = (slw)(sw)s_ax * (slw)(sw)Mashtab.Id / 256 ;
      //s_ax = (sw)( (slw)(sw)s_ax * (slw)(sw)_r.Mashtab_Id >> 8 ) ;
        if ( (sw)s_ax < 0 ) s_ax = ~s_ax + 1 ;
        Id_off += s_ax ;// nakavlivaem tok.
        goto sifu ;
      }
  #endif
            /*    Измерение среднего тока */
#ifdef  Id_sr_ach
      Id_sr_full = _AD_BUSY;
      mAD_Izm (  Id_sr_ach  , &Id_sr_full ) ;
#endif
          /*    АЦП запущен, пока он считает выполним...
           */

    #ifdef  _RS_10ms_
      if ( PDF[0].flg._.new_izm_pdf == 1 )   //вызывается раз в 10ms
    #endif
       {
        #ifdef _REG_POL // Вычисление ОС нельзя переносить в РП , тк когда он выключен ,
          //---         // угол не будет рассчитываться...
          Ugol_Pol () ;
          //---
          can_ConfigReg ( _CAN_S_Zad ) ;  // CAN-Задание на положение
          obj_ConfigReg ( _Obj_S_Zad ) ;  // Объектное задание перебивает CAN-задание
          //---
          if ( Prg._.RP == 1 )  RegPol () ;
        #else
               Prg._.RP = 0 ;
        #endif

      //#ifdef bi_Fors_Temp - 30.01.2020 функция замены темпов должна работать всегда .
          Fors_Temp () ; // Форсированный темп - замена темпов ЗИ .
      //#endif
         //-----  Формирование задания на скорость.
          if ( Prg._.ZadSkor == 1 )
           {
             can_ConfigReg ( _CAN_N_Zad ) ;  // CAN-Задание на скорость
             obj_ConfigReg ( _Obj_N_Zad ) ;  // Объектное задание перебивает CAN-задание
           }
         //-----
 //         PDF[0].flg._.new_izm_pdf = 0 ; // сброс флага , взведется через 10мс в PDF.C
          if ( Prg._.RegSk  == 1 )  RegSk () ;  // 150-210mcs
       }

       //while ( Id_full == _AD_BUSY ); // 10.11.2008 15:14 - DAN перенесено в функцию IdConv ()
                                        // для того , чтобы удобно было делать объектное
       IdConv () ;                      // преобразование тока .

       Control_Id_Max ()  ;
#ifdef  _KTE
     // 12.08.2010 15:32 Временно , пока Макс не доведёт эту программу до ума :
     //if ( Prg._.Gotovn == 0 )  Control_otkr_tir ( _ConOtkr_Rabota ) ;  // только в "Работе"
#endif
            //---  Расчет РТ или Формирование задания на угол управления.
      if ( can_ConfigReg ( _CAN_Alfa_Zad ) == 0 && obj_ConfigReg ( _Obj_Alfa_Zad ) == 0 )
      {
        #ifdef _Rev_Pola
          Revers_Pola () ;
        #endif
                       //  27.06.2008 10:00 - перенесено из MAIN в СИФУ .
        #ifdef _KTE_GD //  Измерение Ug, Ug8, Udv и Ig.
          Izm_GD () ;  //  А если два двигателя с РВТ , то и Ig1 и Ig2 .
        #endif         //  Проверить , нормально ли будет работать с такой кучей измерений .

         //---------------  Формирование задания на ток.
         // 24.09.2015 - перенесено снизу , чтобы видеть задание в индикации при выключенном РТ :
        can_ConfigReg ( _CAN_Id_Zad ) ; // CAN-Задание на ток
        obj_ConfigReg ( _Obj_Id_Zad ) ; // Объектное задание перебивает CAN-задание
         //---------------
        if ( Prg._.RegTok == 1
#ifdef _KTE_GD // В КТЭ в режиме "РС-Останов" по включенному РН ошибочно вызовется РТ .
                               || Prg._.RN == 1
#endif
                                                )

        {
           //---------------  Формирование задания на ток.
          // 24.09.2015 - перенесено наверх , чтобы видеть задание в индикации при выключенном РТ :
          //can_ConfigReg ( _CAN_Id_Zad ) ; // CAN-Задание на ток
          //obj_ConfigReg ( _Obj_Id_Zad ) ; // Объектное задание перебивает CAN-задание

           //---------------

      #ifndef _KTE_GD
          RegTok () ;  // 110mcs

            //--- переносить эту припарку в РТ нельзя, т.к. он вызывается
            //           в реверсе без этой припарки.
            //   Перерасчет инт.части, если сняты подтверждающие ИУ
            // чтобы она не застревала в угле начально-непрерывного тока
            // и при включении подтверждающих ИУ не было броска тока.
          //if (( S.flg._.Revers == 1 ) || ( Prz._.Revers1 == 1 ))
          //{
          //  Prz._.Revers1 = 0 ; //15.04.2009 14:45 Перенесено в RT.C , в реверсе сделана
          //-----                 //переменная для определения нахождения в прерывании .
          //-----
          //  if ( ( ZIDN1 > IDN ) && ( IDN < 5 ) )
          //  {
          //    s_ax =  ZIDN1 - IDN ;
          //    if ( s_ax > 3 )
          //    {
          //           s_lax = (lw)s_ax * (lw)KRTI ;
          //           if ( s_lax > 0x4000u ) s_lax = 0x4000u ;
          //           s_lax = (lw)OIRT + s_lax ;
          //           if ( (u)(w) s_lax >  _r.RTMAX ) OIRT = _r.RTMAX ;
          //           else                            OIRT = (w) s_lax  ;
          //    }
          //  }
          //}
          //-----
      #else
          if ( Prg._.RegTok == 1 ) RTg() ;

           //---------------  Формирование задания на напряжение генератора.

          can_ConfigReg ( _CAN_Ug_Zad ) ;  // CAN-задание на напряжение генератора
          obj_ConfigReg ( _Obj_Ug_Zad ) ;  // Объектное задание перебивает CAN-задание

           //---------------
          RNg() ;
      #endif
          //-----
          Linear () ; // 30mcs
        }
      }

     /* if ( S.flg._.Revers == 1 )
        {  // Срезаем длинный ИУ (для режима с ИУ=120грд.)
          mPort_Imp(FOR0[0]) ;
          mFzapoln1_stop() ;// снимаем оба частотных заполнения.
          mFzapoln2_stop() ;
          Clr_DZV() ; // очистка ДЗВ по заднему фронту ИУ.
        }
      */
 //--------
  #ifdef  _SIFU_1Faza
sifu:
  #endif

    T_Izm_Dat ( 2 ) ; // Зарядка аналоговых измерений температуры каждого охладителя в каждом силовом шкафу .

       //   След вставлен здесь, чтобы иметь правильное соответствие между
      //  текущим углом, током и заданием на следующий угол.
    Sled () ;   //150-200mcs

//---------  СИФУ  -------------

    S.flg._.Fmax = 0 ;
    S.flg._.Fmin = 0 ;
    S.flg._.Fdmin  = 0 ;
    S.flg._.Fdmax  = 0 ;

        //---- Ограничение минимального угла управления.
    can_ConfigReg ( _CAN_Alfa_Min ) ;
         //-----

    if ( Av._.Sdvig_imp == 1 ) goto sdv ; // сдвиг импульсов в Альфа_Макс.
    else         s_cx = S.Alfa ;


      //   Наступление ограничений по ЗИ и ограничителю угла друг друга
      // взаимоисключают;  по-этому поводу будет ссылка ниже ...
      //  Ограничитель угла.
  if ( flg_RaTe._.tyr_tst_go == 1 ) // DAN 20.07.2017 9:45 - При тесте тиристоров диапазон угла принимается
  {                                 //                       от 150 до 179 грд :
    if ( s_cx > _Grad( 179 ) )
      {
          s_cx = _Grad( 179 ) ;
        S.flg._.Fmax = 1;
      }
    else if ( s_cx < _Grad( 150 ) )
           {
             s_cx = _Grad( 150 ) ;
             S.flg._.Fmin = 1;
           }
  }
  else
  {
    if ( s_cx > _r.S_Alfa_Max ) // Рабочий Ограничитель угла :
      {
     sdv: s_cx = _r.S_Alfa_Max;
        S.flg._.Fmax = 1;
      }
    else if ( s_cx < _r.S_Alfa_Min )
           {
             s_cx = _r.S_Alfa_Min ;
             S.flg._.Fmin = 1;
           }
  }
       // ЗИ.
    if ( s_cx < S.Alfa_Old  )
      {
        s_ax = S.Alfa_Old - s_cx ;
        if ( s_ax > _r.S_DeltaAlfa_Max)
          {
            s_ax = _r.S_DeltaAlfa_Max;      //   если после ограничителя угол сел на ЗИ,
            s_cx = S.Alfa_Old - s_ax ;    //   то, следовательно, ограничение по _r.Alfa_Min если
            S.flg._.Fdmin = 1 ;   //   и было то отпало само собой и по-этому здесь
            S.flg._.Fmin  = 0 ; // <- признак ограничения _r.Alfa_Min сбрасывается.
          }
        S.TZ -= (w)( (lw)s_ax * (lw)Tsyn >> 15 ) ;
      }
    else
      {
        s_ax = s_cx - S.Alfa_Old ;
            // из-за перекрытия ИУ нельзя обходить ЗИ
        if ( Av._.Sdvig_imp == 1 ) goto s2 ; // Обход ЗИ при сдвиге импульсов в Альфа_Макс.
        if ( s_ax > _r.S_DeltaAlfa_Max )
          {
            s_ax = _r.S_DeltaAlfa_Max ;    // если после ограничителя угол сел на ЗИ,
            s_cx = S.Alfa_Old + s_ax ; // то, следовательно, ограничение по AlfaMax если
            S.flg._.Fdmax = 1 ;                // и было то отпало само собой и по-этому здесь
            S.flg._.Fmax = 0;                  // <- признак ограничения Fmax сбрасывается.
          }
    s2: S.TZ += (w)( (lw)s_ax * (lw)Tsyn >> 15 ) ;
      }

    S.Alfa_Old = s_cx;      // раньше это делать нельзя.

   // TZ += (w)( (lw)_Grad( 60.0 ) * (lw)Tsyn >> 15 ) ;
    S.TZ += Tsyn/6 ;

    S.N++;
    if ( S.N == 07 )  S.N = 1;

       // здесь используется промежут. ячейка NIP  чтобы сэкономить время в прерывании.
    if ( S.flg._.Revers == 0 && flg_RaTe._.tyr_tst_go == 0 ) // нормальная работа , не реверс и не контроль пробития :
      {
#ifndef  _F16e
        S.NIP = FOR0[S.N] ;  // импульсы с подтверждающими
#else
        S.NIP = FOR0 [S.NumMost] [S.N] ;  // импульсы с подтверждающими
#endif
      }
    else // реверс или контроль пробития :
      {
#ifndef  _F16e
        S.NIP = FOR1[S.N] ;  // импульсы без подтверждающих
      }
    if ( Otkl_Imp != 0x0 ) S.NIP = FOR0[0] ;
#else
        S.NIP = FOR1 [S.NumMost] [S.N] ;  // импульсы без подтверждающих
      }
    if ( Otkl_Imp != 0x0 ) S.NIP = FOR0[0][0] ;
#endif

    if ( pSyn->b_SIv == 1 )
      {
        pSyn->b_SIv = 0 ;
        s_ax = S.TZ ;
        S.TZ = pSyn->NS2  ;
        if ( S.N >= _r.S_FazirovVS ) S.TZ += Tsyn/6 * (w)(S.N - _r.S_FazirovVS)  ;
        else                        S.TZ += Tsyn/6 * (w)(6u + S.N - _r.S_FazirovVS)  ;
        S.TZ += (w)( (lw)( _r.S_FazirovUgol + s_cx ) * (lw)Tsyn >> 15 )  ;

          // После перепривязки проверка отклонения момента выдачи УИ от момента расчитанного
        if (( (u)((w)(S.TZ - s_ax)) >= (w)Tsyn/8 ) && ( (u)((w)(s_ax - S.TZ)) >= (w)Tsyn/8 )) // без перепривязки и в случае его большого отклонения
          {
                            /*  Нижеследующая Последовательность проверки обязательна:
                             * сначала "-Tsyn", потом "+Tsyn" - т.е. проверка завершается
                             * прибавлением периода. Это на тот случай если отклонение "TZ"
                             * вызвано не ошибкой перепривязки на "Tsyn", а тем что уплыли
                             * импульсы из-за временного отсутствия синхронизации и прибавив
                             * лишний период в направлении роста таймера мы в худшем случае
                             * просидим период без импульсов, но не собьемся со шкалы таймера
                             * и через период снова подадутся импульсы.
                             */
            S.TZ -= Tsyn ;  // <- Когда мы при большом 'alfa' залезли старой шестеркой за новый СИ.
            if (( (u)((w)(S.TZ - s_ax)) >= (w)Tsyn/8 ) && ( (u)((w)(s_ax - S.TZ)) >= (w)Tsyn/8 ))  // <- Когда мы при маленьком 'alfa'
                      S.TZ += 2*Tsyn ;   //  и задержке обработки очередного СИ получили его после начала новой шестерки.
          }
      }

    S.flg._.TZ_Ok = 1 ;

    /* Конец импульса и номер порта УИ описываются до того, как заряжать EPA */
    /* на случай, если  EPA сработает сразу же после его зарядки             */

    /* Зарядка ЕПА на угол измерения тока */

    //  КВВ 10-11-16 - добавил защиту от опоздания, пришлось перенести ниже реверса
    //  _sifu_epa_time (S.TZ - (w)( (lw)_r.S_Alfa_IzmDoImp * (lw)Tsyn >> 15 ) );

    // Для следа, чтобы в байтовой ячейке содержались номера моста и тиристора :
    S.Most_Tir  = S.N ;
    S.Most_Tir |= S.NumMost << 4  ;
    if ( _r.Cfg._.DZV == 1 && (S.DZV & 0x03) != 0 ) S.Most_Tir |= 0x08 ; // Если пришло хотя бы одно ДЗВ .
    if ( S.flg._.Revers  == 1 ) S.Most_Tir |= 0x40 ; // 6й - SPI .
    if ( S.flg._.SnImpVM == 1 ) S.Most_Tir |= 0x80 ; // 7й - снятие импульсов .

      //-------  Опрос необходимости реверса и его Инициализация. ----
    Revers_start () ;

    /* Зарядка ЕПА на угол измерения тока */

  asm_di() ;
    s_ax = S.TZ - (w)( (lw)_r.S_Alfa_IzmDoImp * (lw)Tsyn >> 15 ) ;
    s_cx = s_ax - timer1 ;

    if ( (u)s_cx < (w)Tsyn*2  &&  s_cx >= _MkSec( 50 ) )
    {
      _sifu_epa_time ( s_ax );
  asm_ei() ;
    }
    else
    {
  asm_ei() ;
      do  s_cx = s_ax - timer1 ;
      while ( (u)s_cx < (w)Tsyn*2  );
      goto beg_imp ;
    }

    break;
  }

       // Объектное (под процессор) дополнение для прерываний:
   // Sifu_int_drv(_sifu_epa_con) ;  // сброс запроса прерывания.

    pS( 0 ) ;

    return;
}

/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/

void  Control_otkr_tir ( word num )
  {
    static word Time1[6];
    register word ax, bx, n;
    lword lax ;
    byte i;
      //----
    switch ( num )
    {    // Стартовая программа для задания начальных условий.
      case _ConOtkr_Init :

          for ( i = 0; i < 6; ++i )
            {
              Schet_p[i] = 0;
            }
          //пока будем использовать алгоритм без дополнительных замеров тока в момент формирования ИУ .
          //flg_RaTe._.Id_anastr = 1 ;  // включить дополнительные замеры тока в момент формирования ИУ .
          IDV_sr = 0 ;

        break;
        //-------
         // программа для задания начальных условий при переходе
        // из Работы в Сб.Готовности.
      case _ConOtkr_DS1_Init :
          for ( i = 0; i < 6; ++i )
            {
              Schet_p[i] = 0;
            }
          //пока будем использовать алгоритм без дополнительных замеров тока в момент формирования ИУ .
          //flg_RaTe._.Id_anastr = 1 ;  // включить дополнительные замеры тока в момент формирования ИУ .
          IDV_sr = 0 ;

        break;
        //-------
         // программа для Сборки Готовности.
      case _ConOtkr_Sborka_Gotovn :
        break;
        //-------
         // программа неотключаемая после срабатывания защиты.
      case _ConOtkr_Rabota :

          // Запоминаем номер тиристора, работающего в данный момент
          // т.к программа включается перед СИФУ, но после измерения тока в 13грд.
          // то номер тиристора совпадает
            n = S.N - 1 ;

    /*   if ( S.N == 1 )
          {
            n = 5 ;
          }
         else
          {
            n = S.N - 2 ;
          }                */

    if ( S.Alfa <= S.Alfa_Old )         // при невозрастающем угле
      {
#ifdef  _KTE
       if ( IDV_sr > INN )              // в режиме непрерывных токов
#endif
         {
          ax =  Id_AN_imp ;
          if ( (sw)ax < 0 )   ax = ~Id_AN_imp + 1 ;
          bx =  IDV ;

          ax -= bx ;

               if ( (sw)ax >= (sw)_Id_nom(0.03) ) // если ток просел
                    {
                      // Проверка на превышение установленного предела счета
                      if( Schet_p[n] >= 5 )
                          {
                            Schet_p[n] = 0;

                            lax = _Srv2_V1 << n ;
                            //Служебное сообщение
                            mSet_ServiceMsg2( lax );
                          }
                      else
                          {
                            if ( Schet_p[n] == 0)
                                {
                                  Time1[n] = Timer1_Ovr;
                                }
                            ++Schet_p[n];
                          }
                    }
         }
#ifdef  _KTE
        else                     // в режиме прерывистых токов
         {
            bx = IDV_sr - IDV ;

            if ( ( IDV <= _Id_nom(0.01)) && ((sw)bx >= (sw)_Id_nom(0.04)) ) // если пульс тока исчез
              {
                // Проверка на превышение установленного предела счета
                if( Schet_p[n] >= 5 )
                    {
                      Schet_p[n] = 0;

                      //if ( ( Reg_ServiceMsg2 & ( _Srv2_V1 | _Srv2_V2 | _Srv2_V3 | _Srv2_V4 | _Srv2_V5 | _Srv2_V6 )) == 0 )  // если раньше не было сообщений
                      // {
                       if ( (sw)( IDV_1 - IDV ) > (sw)_Id_nom(0.04) )  // если на прошлом пульсе был ток
                         {
                           lax = _Srv2_V1 << n ;
                           //Служебное сообщение
                           mSet_ServiceMsg2( lax );
                         }
                      // }
                    }
                else
                    {
                      if ( Schet_p[n] == 0)
                          {
                            Time1[n] = Timer1_Ovr;
                          }

                      ++Schet_p[n] ;

                      if    ( n == 0 ) i = 5 ;
                      else   i = n - 1 ;

                      //Если счетчик на предыдущем пульсе не нулевой, то обнуляем текущий счетчик.
                      if ( Schet_p[i] != 0 )  Schet_p[n] = 0 ;
                    }
              }
         }
#endif
      }


       IDV_sr = ( IDV_sr + IDV ) / 2 ;
       IDV_1 = IDV ;

        // Проверка на лимит времени: каждые 140 милисекунд счетчик обнуляется.
        if ((u)((w)(Timer1_Ovr - Time1[n])) > _Sec( 0.14 )) Schet_p[n] = 0;

        break;
        //-------
         // программа отключаемая после срабатывания защиты.
      case _ConOtkr_Avar_Otkl :
        break;
        //-------
    }

    return ;
  }
