
//         ПРОГРАММЫ ПРИНЯТИЯ ЗАДАНИЯ НА СКОРОСТЬ .
//------------------------------------------------------------------

//  Программа принятия аналогового задания на скорость.

  void  ZadSkor_Analog ( void )  //150mcs
  {
    word ax ;
    //---
    pr = &Z_sk , Izm_Analog () ;
    ax = (sw)Z_sk.out << _Skor_Shift ;

    ZSkA = (sw)( (slw)(sw)ax * (slw)(sw)_r.Mashtab_ZSkA >> 8 ) ;

    return ;
  }
//------------------------------------------------------------------

//    Программа принятия цифрового задания на скорость от "Больше-Меньше"

void  ZadSkor_BolsheMenshe ( void )
{
    static word Time ;
    register word ax, bx ;

        //     Приведение уставки от 'ном/сек' к 'сек/ном'.

        //     Прежнюю формулу расчета пришлось переделать при переходе на 3200дискр
        //  из-за того что делалось приращение по 1дскр за один фоновый оборот программы и
        //  темп быстрее чем 200...300дскр/сек поднять было нельзя.

        //     Новая формула исходит из того что должно соблюдаться равенство пропорции:
        //          dN / dt = _r.Temp_ZSkBM / Sec(1.0)   =>   dt = Sec(1.0) * dN / _r.Temp_ZSkBM
        //

    bx = _Skor_nom( 0.0025 ) ;
    if ( bx == 0 ) bx = 1 ;  // защита.

    ax = (lw)(w)_fSec( 1.0 ) * (lw)(w)bx / (w)_r.Temp_ZSkBM  ;
    if ( ax == 0 ) ax = 1 ;  // защита.

    if ( bi_Bolshe == 1 )
      {
        //ax = (lw)(w)_fSec( 1.0 ) * (lw)(w)bx / (w)_r.Temp_ZSkBM  ;
        //if ( ax == 0 ) ax = 1 ;  // защита.

        if ( bi_Menshe == 1 )
          {              // если нажаты обе кнопки - то ничего не делать.
            Time = Timer1_fSec  ;  // Взведение выдержки времени
            return ;
          }       // если нажата только "больше".
          //   Выдержка времени после очередной прибавки к заданию - определяет
          // интенсивность коррекции при постоянно нажатой кнопке.
        if ( (u)((w)(Timer1_fSec - Time)) < ax )  return ;

        ax = ZSkBM + bx ;
        if ( (sw)ax >= (sw)_r.ZSkBM_MaxB )  ax = _r.ZSkBM_MaxB ;
        ZSkBM = ax ;
        Time = Timer1_fSec ; // Взведение выдержки времени
      }
    else if ( bi_Menshe == 1 )
      {   // если нажата только "меньше".
 //       ax = (lw)(w)_fSec( 1.0 ) * (lw)(w)bx / (w)_r.Temp_ZSkBM  ;
 //       if ( ax == 0 ) ax = 1 ;  // защита.

        if ( (u)((w)(Timer1_fSec - Time)) < ax )  return ;

        ax = ZSkBM - bx ;
        if ( (sw)ax <= (sw)_r.ZSkBM_MaxM )  ax = _r.ZSkBM_MaxM ;
        ZSkBM = ax ;
        Time = Timer1_fSec ; // Взведение выдержки времени
      }
      //   Сброс выдержки времени после отпускания кнопки для того, чтобы
     // программа была тут же готова к приему новой "больше/меньше".
    else  Time = Timer1_fSec - ax ;

    return  ;
  }
//------------------------------------------------------------------

//    Программа принятия команд на толчки

void  ZadSkor_Tolchki ( void )
{
    // 10.07.2008 16:57 - Пока клавиши привязаны к "+" и "-" это приводит к случайному
    //                    включению с компьютера . Пока закоментируем .
    //Pult_Tolchki () ; // Принятие команд на толчки с пультового терминала .

    if ( bi_TB == 1 )
      {
        if ( bi_TH == 1 )   ZSkT = 0  ;  // если нажаты обе кнопки.
        else  ZSkT = _r.ZSk_TB  ;   // если нажата только "Толчок Вперед".
      }
    else if ( bi_TH == 1 )  ZSkT = _r.ZSk_TH ; // если нажата только "Tолчок Hазад".
    else                    ZSkT = 0x0  ;    // если отпущены обе кнопки.

    return  ;
}
//------------------------------------------------------------------

//    Программа принятия команд на толчки с пультового терминала

void  Pult_Tolchki ( void )
{
  if ( Klav_Buff == Shift_Up   ) trig._.TB = 1 , trig._.TH = 0 ;
  if ( Klav_Buff == Shift_Down ) trig._.TB = 0 , trig._.TH = 1 ;
  if ( Klav_Buff == Shift_Esc  ) trig._.TB = 0 , trig._.TH = 0 ;

  if ( trig._.TB != 0 || trig._.TH != 0 ) mSet_ServiceMsg( _Srv_PultTolchki ) ;
  else                                    mClr_ServiceMsg( _Srv_PultTolchki ) ;

  return  ;
}
//------------------------------------------------------------------

//    Программа-диспетчер Выбора Способа ШТАТНОГО Задания Скорости и
//  формирования окончательного Штатного Задания на скорость.

word Shtat_ConfigReg ( word code )
{
  register word ax ;
  //---
  if ( code != _Shtat_Init ) // Иниц.Штат.Задания, даже если Штат.Реж. не задан
    {
      // Задан ли штатный режим управления ?
      if ( _r.Cfg._.Shtat_reg == 0 || Isp.all != 0 ) return 0 ;
    }

  //-------------
  switch ( code )
    {
      // Инициализация - стартовая опрограмма для задания начальных условий :
      case _Shtat_Init :
        // Для Задания Скорости :
        ZSkA = 0,  ZSkBM = 0,  ZSkT = 0,  ZSk_Shtat = 0,  Z_Skor = 0 ;
        Z_sk.out = 0 , Z_sk.shift = 1 , Z_sk.porog = 2 , Z_sk.ach = &Z_sk_ach ;
      break;

      // Штатное Управление :
      default:
        ZadSkor_Analog () ; // 27.04.2020 08:16 перенесено для возможности проверки/масштабирования задания
        if ( bi_Zapret == 1 ) // Есть ли запрет на прием задания ?
         {
#ifndef bi_Fors_Temp               // Если определен форсированный темп ,
           Set_ZI ( &zi_rs , 0 ) ; // то обнулять ЗИ не нужно .
           ZISkor = 0 ;
#endif
           ZSkBM  = 0 ;
           Z_Skor = 0 , ZSk_Shtat = 0 ;
         }
        else // Запрета на прием задания нет :
         {
           ax = 0 ;

           //  Прием задания в режиме "Работа" или "Толчки" ?
           if ( bi_Rab_Tolch == 1 ) //  Прием задания в режиме "Работа" :
            {
              // Считывание аналогового задания в штатное задание :
              //ZadSkor_Analog () ;27.04.2020 08:16 перенесено чуть выше // если задание не задействовано - масштаб=0.
              /*if ( (sw)ZSkA > (sw)_r.Z_SkMin ||
                   (sw)ZSkA < (sw)( ~_r.Z_SkMin + 1 ) )
               {
                 ax = ZSkA ; // 03.08.06 10:15 - фильтрация .
               } 04.07.2008 7:30 - Порог переделан так , чтобы после порога начинать с нуля */
              //  Введение порога в аналоговый сигнал :
              if ( (sw)ZSkA < 0 )
                {
                  if ( (w)(~ZSkA + 1) <= _r.Z_SkMin ) ax = 0x0  ;
                  else                                ax = ZSkA + _r.Z_SkMin  ;
                }
              else
                {
                  if ( (w)ZSkA <= _r.Z_SkMin )        ax = 0x0  ;
                  else                                ax = ZSkA - _r.Z_SkMin  ;
                }
             //---
              ax += Nzad ; // Задание токовой петлёй 4-20 мА .
             //---
              // Добавление задания с сельсина[0] к штатному заданию :
              /*if ( (sw)Sels[0].out_m > (sw)_r.Z_SkMin ||
                   (sw)Sels[0].out_m < (sw)( ~_r.Z_SkMin + 1 ) )
               {
                 ax += (sw)Sels[0].out_m ; // 03.08.06 10:15 - фильтрация .
               } 04.07.2008 7:30 - Порог переделан так , чтобы после порога начинать с нуля */
              //  Введение порога в сигнал сельсина :
              if ( (sw)Sels[0].out_m < 0 )
                {
                  if ( (w)(~Sels[0].out_m + 1) > _r.Z_SkMin ) ax += Sels[0].out_m + _r.Z_SkMin ;
                }
              else
                {
                  if ( (w)Sels[0].out_m > _r.Z_SkMin )        ax += Sels[0].out_m - _r.Z_SkMin ;
                }
             //---
#ifndef  _SIFU_Syn2 // СИНХРОНИЗАЦИЯ ОТ МОСТА ПРИВЯЗАНА КО ВХОДУ СЕЛЬСИНА 1 .
              // Добавление задания с сельсина[1] к штатному заданию :
              /*if ( (sw)Sels[1].out_m > (sw)_r.Z_SkMin ||
                   (sw)Sels[1].out_m < (sw)( ~_r.Z_SkMin + 1 ) )
               {
                 ax += (sw)Sels[1].out_m ; // 03.08.06 10:15 - фильтрация .
               } 04.07.2008 7:30 - Порог переделан так , чтобы после порога начинать с нуля */
              //  Введение порога в сигнал сельсина :
              if ( (sw)Sels[1].out_m < 0 )
                {
                  if ( (w)(~Sels[1].out_m + 1) > _r.Z_SkMin ) ax += Sels[1].out_m + _r.Z_SkMin ;
                }
              else
                {
                  if ( (w)Sels[1].out_m > _r.Z_SkMin )        ax += Sels[1].out_m - _r.Z_SkMin ;
                }
#endif
             //---
              // Добавка смещения от сигналов "больше-меньше" к штатному заданию .
              ZadSkor_BolsheMenshe () ; // если задание не задействовано -
              ax += (sw)ZSkBM ;  // привязываем bi в OBJ.H к нулям .
            }
           else  // Прием задания в режиме "Толчки".
            {
              ZadSkor_Tolchki () ;      // если задание не задействовано -
              ax = ZSkT ;        // привязываем bi в OBJ.H к нулям .
            }

           // Уставка для постоянного задания скорости ( ползучка , рабочая скорость и т.д.) :
           // Задается только в работе , после сборки последнего коммутационного аппарата :
           if ( Prg._.Gotovn == 0 ) ax += _r.Z_SkRab ;

           ZSk_Shtat = ax ; // формируем штатное задание .
           // Штатное Задание ложим в окончательное Задание На Скорость :
           Z_Skor = ZSk_Shtat ;
         }
      break;
    }
  return 0 ;
}

//-------------------------------------------------------------------------------------------------
//
//      Измерение задания скорости .
//
//    Весь диапазон - от "N#-4mA" до "N#-20mA" . Поэтому типовые уставки "N#-4mA" = 0% , "N#-20mA" = 100% .
//
//    При обрыве датчика ( 0мА ) индицируется задание , соответствующее 4мА , т.е. не падает
// ниже уставки . Но зато при обрыве срабатывает сообщение об обрыве датчика .
//
//    Настройка этой платы :
//  |------|---------|-----------------|
//  |  мА  |  В, АЦП |   %, зад.скор   |
//  |------|---------|-----------------|
//  |   0  |    0    |                 |
//  |   4  |   0.77  |        0        |
//  |  12  |   2.33  |                 |
//  |  20  |   3.89  |       100       |
//  ------------------------------------
//
void  Zad_Skor_4_20 ( word num )
{
//---
#ifndef  Nzad_4_20_ach
//---
  num = num,  Nzad = 0, Nzad_4_20 = 0 ;
//---
#else
//---
  static word Nzad_full, time_Nzad, Nzad_4_20_drob, time_scan ;

  register word ax ;
  register lword lax ;

  switch ( num )
  {      //  Стартовая инициализация.
    case 0 :  Nzad = 0, Nzad_4_20 = 0, time_Nzad = Timer1_Ovr, Nzad_4_20_drob = 0 ;

     start: Nzad_full = _AD_BUSY ;  //  запуск первого измерения
            AD_Izm ( Nzad_4_20_ach, &Nzad_full ) ;
      break;
         //  Рабочая программа.
    case 1 :
          if ( (w)(u)(timer1-time_scan) >= _MkSec(10*1000) )
          {
            time_scan = timer1 ;
            //---

            if ( Nzad_full != _AD_BUSY )
             {
               mIzmData_Conversion ( Nzad_full, ax, Nzad_4_20_ach ) ;
              ax =(w)((d)ax * _20mA_Nom /(d)(_AD_MAX * 0.8));

                 //---   Фильтруем, т.к. на Белой Церкви на 4-20мА были пульсации 200Гц с амплитудой до 15%.
                     //  Лобода ВД предполагал, что это пульсации ШИМ-регулятора в источнике блока формирующего 4-20.
               lax  = (lw)Nzad_4_20 << 16,    lax += (lw)(w)Nzad_4_20_drob ;
                 lax += (slw)( ((lw)ax << 16) - lax ) / (sw)(_or.Filtr_Param_Nzad * 2)  ;  // *2 - т.к. слишком глубокие пульсаци сигнала.
               Nzad_4_20 = (w)( lax >> 16 ),   Nzad_4_20_drob = (w)lax ;
                 //---

               ax = Nzad_4_20 ;

               //                              Nzad_20mA(%)-Nzad_4mA(%)
               //     Nzad = Nzad_4mA(грд) + ----------------------------  * (I-4mA)
               //                                         16mA

               ax -= _1mA_nom( 4 ) ;
               if ( (sw)ax <= 0 )  ax = 0 ;

               // Задание скорости в "%" :
               Nzad = _or.Nzad_4mA + (w)( (lw)(w)(_or.Nzad_20mA - _or.Nzad_4mA ) * (lw)(sw)ax / _1mA_nom( 16 ) ) ;

            //--------------------

               goto start; //  запуск очередного измерения.
             }
          }
      break;

    case 2 :                                          // Защита от обрыва 4-20мА.
               if ( /*(sw)Nzad >= (sw)_or.Nzad_predupr ||*/ (sw)Nzad_4_20 <= (sw)_1mA_nom( 3 ) )
               {
                 if ( (u)(w)(Timer1_Ovr-time_Nzad) > _Sec( 1.0 ) )
                 {
                   if ( flgO._.Vedushiy == 1 ) // Задание только от Ведущего .
                   {
                     // Для создания "защелки" при обрыве задания :
                     //flgO._.obryv_Nanal = 1 ;
                     mSet_PreduprMsg( _Pr_Nzad_obryv ) ;
                   }
                 }
               }
               else
               {
                   //flgO._.obryv_Nanal = 0 ;
                   time_Nzad = Timer1_Ovr ;
               }

      break;
  }
//---
#endif
//---
  return ;
}
