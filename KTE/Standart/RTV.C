
//       Программа ' Регулятор Тока Возбуждения'

/*----------------------------------------*/

void  RTV ( void )
  {
      // Вызов объектного задания на ток возбуждения , которое перебивает все предыдущее.
    // 29.02.2016 - Перенесено в СИФУВ , чтобы выполнялось при отключенном регуляторе ...
    //obj_ConfigReg ( _Obj_Iv_Zad ) ;

//  Задание приходит уже ограниченным.
//  Определение  значения  рассогласования : dI

//ДДДДДДДДДДД Расчет ошибки.  ДДДДДДДДДДДДДД

#ifdef _RNV // Регулятор напряжения возбуждения вместо РТВ :
    if  ( _or.CfgO._.RNV == 1 )  v_ax = Uf_full - V.Iv_zad ;
    else
#endif
    v_ax = V.Iv - V.Iv_zad ;

//ДДДДДДДДДДД Расчет интегратора.  ДДДДДДДДДДДДДД

//   Проверка ограничений на возрастание или снижение интегратора.

    if ( (sw)v_ax >= 0 )
      {
        if ( V.flg._.Fmax == 1 || V.flg._.Fdmax == 1 ) goto v4 ;
      }
    else
      {
        if ( V.flg._.Fmin == 1 || V.flg._.Fdmin == 1 )  goto v4 ;
      }

    v_lax = _r.V_Ki_rt & 0x7fff;  //защита от "-" коэфф.
    v_lax = (slw)v_lax * (slw)(sw)v_ax ;

        //  Подготовка к контролю переполнения (без использ.'asm'):
       // если до сложения/вычитания операнды были одного знака, а результат
       // получился другого знака - значит произошло переполнения.
    v_cx = 2 ;
    if ( (slw)v_lax >= 0 ) // запоминаем сочетание знаков операндов.
    {
         if( (sw)V.Integr_rt >= 0 ) v_cx = 0 ; // +/+
    }
    else if( (sw)V.Integr_rt <  0 ) v_cx = 1 ; // -/-

    v_lax += (slw)(sw)V.Integr_rt  ;

              /* Проверка переполнений. */
                  //  переполнение в плюс?
          if     ( v_cx == 0 && (slw)v_lax <  0 ) goto v3 ;
                  //  переполнение в минус?
          else if( v_cx == 1 && (slw)v_lax >= 0 ) goto v2 ;
                  //  нет переполнения.
              /* Проверка ограничений. */
          if ( (slw)v_lax < 0 )
            {
    v2:       V.Integr_rt = 0 ;
            }
          else if ( (slw)v_lax >= (slw)_Ugol_180  )
            {
    v3:       V.Integr_rt = _Ugol_180 ;
            }
          else V.Integr_rt = (w)v_lax ;
    v4:;

//ДДДДДД  Расчет пропорциональной составляющей и выхода регулятора. ДДДДДД

    v_lax = _r.V_Kp_rt & 0x7fff;  //защита от "-" коэфф.
    v_lax = (slw)v_lax * (slw)(sw)v_ax ;

        //  Подготовка к контролю переполнения (без использ.'asm'):
       // если до сложения/вычитания операнды были одного знака, а результат
       // получился другого знака - значит произошло переполнения.
    v_cx = 2 ;
    if ( (slw)v_lax >= 0 ) // запоминаем сочетание знаков операндов.
    {
         if( (sw)V.Integr_rt >= 0 ) v_cx = 0 ; // +/+
    }
    else if( (sw)V.Integr_rt <  0 ) v_cx = 1 ; // -/-

    v_lax += (slw)(sw)V.Integr_rt  ;

              /* Проверка переполнений. */
                  //  переполнение в плюс?
          if     ( v_cx == 0 && (slw)v_lax <  0 ) goto p3 ;
                  //  переполнение в минус?
          else if( v_cx == 1 && (slw)v_lax >= 0 ) goto p2 ;
                  //  нет переполнения.
              /* Проверка ограничений. */
          if ( (slw)v_lax < 0 )
            {
    p2:       v_cx = 0 ;
            }
          else if ( (slw)v_lax >= (slw)_Ugol_180  )
            {
    p3:       v_cx = _Ugol_180 ;
            }
          else v_cx = (w)v_lax ;

  //---------------------------------
        //  Линеаризация выхода Регулятора Тока

    if ( v_cx <= _Ugol_90 )  v_ax = v_cx ;
    else                     v_ax = _Ugol_180 - v_cx ;
          //   Макросы Hw() и Lw() используются, чтобы получить из
          // имеющегося длинного "lax" два недостающих временных слова !
      Lw(v_lax)  = LIN [ v_ax >> 8 ] ;
      Hw(v_lax)  = LIN [(v_ax >> 8) + 1 ] ;
      Hw(v_lax) -= Lw(v_lax) ;
      Lw(v_lax) += (w)( (lw)Hw(v_lax) * (lw)(v_ax & 0x00FFu) / 0x0100ul ) ;
    if ( v_cx <= _Ugol_90 ) V.Alfa = Lw(v_lax) ;
    else                    V.Alfa = _Ugol_180 - Lw(v_lax) ;


      return ;
}

