
 void  Reg_Eds ( void )
 {
    static word Integr_REDS_drob ;

    register lword lax , lbx  ;
    register sword  ax , skor ;
              word  cx ;

  // skor = Skor & 0x7FFFu ;
  skor = Skor ;
  if ( (sw)skor < 0 )  skor = ~skor + 1 ;

 //ДДДДДДДДДДД Расчет ошибки.  ДДДДДДДДДДДДДД

  if ( Isp._.Samonastr == 1 )
   {
     if ( (sw)_r.Z_EDS < 0 )  ax =  0x7fffu ;  /* защита от "-" задания. */
     else                     ax = _r.Z_EDS ;
   }
//else if ( Ckl._.Reg_EDS == 1 ) 09.06.2020 15:35
// {
//   if ( (sw)OCIKL < 0 )     ax =  0x7fffu ;  /* защита от "-" задания. */
//   else                     ax = OCIKL ;
// }
  else
   {
     if ( (sw)_r.Z_II_EDS < 0 )  ax =  0x7fffu ;  /* защита от "-" задания. */
     else                        ax = _r.Z_II_EDS ;
   }

  if ( ax > _EDS_nom(1.00) )     Zad_EDS = _EDS_nom(1.00) ;
  else                           Zad_EDS =  ax ;
  //ax -= EDS & 0x7FFFu ;
  ax = Zad_EDS - (EDS & 0x7FFFu) ;

 //ДДДДДДДДДДД Расчет интегратора.  ДДДДДДДДДДДДДД

//   Проверка ограничений на возрастание или снижение интегратора.

    if ( (sw)ax >= 0 )
      {
        if ( V.flg._.ltd_z_max == 1 )  goto v4 ;
      }
    else
      {
        if ( V.flg._.ltd_z_min == 1 )  goto v4 ;
      }

    lax = _r.Ki_REDS ;

 //ДДДДДДДДДДД Уменьшение коэффициента Ки во второй зоне ДДДДДДДДДДДДДД
 //ДДДДДДДДДДДДДДДД пропорционально росту скорости. ДДДДДДДДДДДДДДДДДДД
    if ( (w)skor > (w)Skor_II_Z &&               // Проверка перехода во вторую зону.
         (sw)_r.Ki_REDS_II_Z > (sw)_r.Ki_REDS )  // Уставка "Ти-РЭДС второй зоны" д.б. задана больше , чем "Ти-РЭДС" .
    {
        //   В Теории , коэффициент регулятора должен уменьшаться во столько же раз , во сколько текущая скорость
        // превышает скорость перехода во вторую зону ...
        lbx = _r.Ki_REDS_II_Z - _r.Ki_REDS ;
        if ( (slw)lbx < 0 ) lbx = 0 ;
        lbx *= (w)(skor - Skor_II_Z) ;
        cx = _r.Z_SkMax_P - Skor_II_Z ;
        if ( (sw)cx <= 0 ) cx = 1 ;
        lbx /= (w)cx ;
        Ki_REDS_ind = _r.Ki_REDS + (w)lbx ;
        //--------
        // Если "вычисленная Ти-РЭДС" получилась больше , чем "Ти-РЭДС второй зоны" , то ограничиваем :
        if ( (sw)Ki_REDS_ind > (sw)_r.Ki_REDS_II_Z ) Ki_REDS_ind = _r.Ki_REDS_II_Z ;
        lax = Ki_REDS_ind ;
    }
 //ДДДДДДДДДДД

    Ki_REDS_ind = lax ; // Индикация окончательного Ти РЭДС .

    if ( lax == 0 )
     {             // инициализация интегратора при Ки = 0 :
       Integr_REDS = _Fv_nom( 1.00 ) ;
       Integr_REDS_drob = 0 ;
       goto v4 ;
     }

    //-----------------18.06.07 08:55-------------------

    lax = (lw)( ((d)_Fv_nom(0.01) *  6.6 * 65535.) / (d)_EDS_nom(0.01) ) / lax ;
    lax &= 0x7ffffffful ;  //защита от "-" коэфф.

    //--------------------------------------------------

 //ДДДДДДДДДДД Уменьшение коэффициента Ки во второй зоне ДДДДДДДДДДДДДД
 //ДДДДДДДДДДДДДДДД пропорционально росту скорости. ДДДДДДДДДДДДДДДДДДД

     /* 16.07.2018 14:00 - Вместо масштабов сделан Минимальный и Максимальный Кп ...
     // Проверка перехода во вторую зону.
    if ( (w)skor > (w)Skor_II_Z )
    {
       //lax =  _r.Ki_REDS ;
       //ax =  Skor_II_Z ;
       //asm   mulu lax , ax ;
       //ax =  skor  ;
       //asm   divu lax , ax ;
       //Ki_reds = (w)lax ;
       //-----------
       // 22.04.2008 - Брался Kи , умножался на скорость перехода во вторую зону и делился на
       //              модуль текущей скорости :
     //lax *= (lw)Skor_II_Z ;
     //lax /= (lw)skor ;
     //if ( lax == 0 )  lax = 1 ;
       //-----------
       // 22.04.2008 - При нулевом масштабе воздействия на коэффициенты РЭДС не меняем Ки .
       if ( _r.DT_ZISk != 0 )
        {
          // Берём скорость перехода во вторую зону и делим на модуль текущей скорости :
          lbx  = (lw)Skor_II_Z ;
          // Mасштабирование воздействия на коэффициент Ки РЭДС :
          lbx =  (slw)( (slw)lbx * (slw)(sw)_r.DT_ZISk >> 8 ) ;
          lbx /= (lw)skor ;
          // Собственно воздействие на Ки РЭДС ( М>1  ) или ( М<1  ) :
          lax *= lbx ;
          if ( lax == 0 )  lax = 1 ;
        }
    }*/

    //-----------------18.06.07 08:55-------------------
    //---------- preventive overflow control -----------
    cx = ax ;                     // ошибка .
    if ( (sw)cx < 0 )  cx = -cx ; // выпрямленная ошибка .
    // Если lax = 0 , то процессор _CM3_ при делении на нуль получает нуль , входит в условие
    // и выдаёт максимальный выход , что есть неправильно . Поэтому проверяем , что lax != 0 :
    if ( ((lw)cx >= (lw)0x7fffffff / lax) && (lax != 0) )    // sravnivaem modul oshibki
     {                                       // s maksimalno dopustimoy
       if ( (sw)ax >= 0 ) lax = 0x7fffffff ; // pri vychislennom 'Ki',
       else               lax = 0x80000000 ; // dlya 32-bit setki oshibkoy.
     }
    else  lax = (slw)lax * (slw)(sw)ax ;
    //asm   mul  lax , ax ;   // умножение интегр. коэффициента на ошибку
    //--------------------------------------------------

    //-----------------18.06.07 08:55-------------------
       //  Подготовка к контролю переполнения (без использ.'asm'):
       // если до сложения/вычитания операнды были одного знака, а результат
       // получился другого знака - значит произошло переполнение.
     cx = 2 ;
     if ( (slw)lax >= 0 ) // запоминаем сочетание знаков операндов.
      {
          if( (sw)Integr_REDS >= 0 ) cx = 0 ; // +/+
      }
     else if( (sw)Integr_REDS <  0 ) cx = 1 ; // -/-

     lax += (slw)(sw)Integr_REDS << 16 ;
     lax += (lw)(w)Integr_REDS_drob ;   // DROB ISN'T SIGNED !

              /* Проверка переполнений. */
                  //  переполнение в плюс?
          if     ( cx == 0 && (slw)lax <  0 ) goto v1 ;
                  //  переполнение в минус?
          else if( cx == 1 && (slw)lax >= 0 ) goto v2 ;
    //--------------------------------------------------

              /* Проверка ограничений. */
          if ( (slw)lax < (slw)r0 )
            {
    v2:       lax = r0 ;
            } // Ограничиваем на номинале <<16 , сдвиг компенс. после П-части .
          else if ( (slw)lax >= ((slw)_Fv_nom( 1.00 ) << 16) ) //0x7fff )
            {
    v1:       lax = (lw)_Fv_nom( 1.00 ) << 16 ;//0x7fff ;
            }

    Integr_REDS = (slw)lax >> 16 ; // дробная часть уходит, целая записывается .
    Integr_REDS_drob = lax ;       // запись дробной части .

    v4:    // Обнуление признаков ограничения РЭДС в конце ф-ии Zadanie_Iv () .
    //ДДДДДД  Расчет пропорциональной составляющей и выхода регулятора. ДДДДДД

    lax = _r.Kp_REDS ;

 //ДДДДДДДДДДД Уменьшение коэффициента Кп во второй зоне ДДДДДДДДДДДДДД
 //ДДДДДДДДДДДДДДДД пропорционально росту скорости. ДДДДДДДДДДДДДДДДДДД
    if ( (w)skor > (w)Skor_II_Z &&         // Проверка перехода во вторую зону.
         (sw)_r.DT_ZISk < (sw)_r.Kp_REDS )  // Уставка "Кп-РЭДС второй зоны" д.б. задана меньше , чем "Кп-РЭДС" .
    {
        //   В Теории , коэффициент регулятора должен уменьшаться во столько же раз , во сколько текущая скорость
        // превышает скорость перехода во вторую зону ...
        lbx = _r.Kp_REDS - _r.DT_ZISk ;
        if ( (slw)lbx < 0 ) lbx = 0 ;
        lbx *= (w)(skor - Skor_II_Z) ;
        cx = _r.Z_SkMax_P - Skor_II_Z ;
        if ( (sw)cx <= 0 ) cx = 1 ;
        lbx /= (w)cx ;
        Kp_REDS_ind = _r.Kp_REDS - (w)lbx ;
        //--------
        // Если "вычисленный Кп-РЭДС" получился меньше , чем "Кп-РЭДС второй зоны" , то ограничиваем :
        if ( (sw)Kp_REDS_ind < (sw)_r.DT_ZISk ) Kp_REDS_ind = _r.DT_ZISk ;
        lax = Kp_REDS_ind ;
    }
 //ДДДДДДДДДДД

    Kp_REDS_ind = lax ; // Индикация окончательного Kп РЭДС .


    //-----------------18.06.07 08:55-------------------
                                    // "<< 8"-догоняем "Kp*256" до формата
    lax = (lax * _Fv_nom(0.01)) / _EDS_nom(0.01) << 8 ;// коэфф."Ki=x*65536".
    lax &= 0x7ffffffful ;  //защита от "-" коэфф.

    //--------------------------------------------------

 //ДДДДДДДДДДД Уменьшение коэффициента Кп во второй зоне ДДДДДДДДДДДДДД
 //ДДДДДДДДДДДДДДДД пропорционально росту скорости. ДДДДДДДДДДДДДДДДДДД

     /* 16.07.2018 14:00 - Вместо масштабов сделан Минимальный и Максимальный Кп ...
     // Проверка перехода во вторую зону.
    if ( (w)skor > (w)Skor_II_Z )
    {
       //lax =  _r.Kp_REDS ;
       //ax =  Skor_II_Z ;
       //asm   mulu lax , ax ;
       //ax =  skor  ;
       //asm   divu lax , ax ;
       //-----------
       // 22.04.2008 - Брался Kп , умножался на скорость перехода во вторую зону и делился на
       //              модуль текущей скорости :
     //lax *= (lw)Skor_II_Z ;
     //lax /= (lw)skor ;
     //if ( lax == 0 )  lax = 1 ;
       //-----------
       // 22.04.2008 - При нулевом масштабе воздействия на коэффициенты РЭДС не меняем Кп .
       if ( _r.DT_ZISk != 0 )
        {
          // Берём скорость перехода во вторую зону и делим на модуль текущей скорости :
          lbx  = (lw)Skor_II_Z ;
          // Mасштабирование воздействия на коэффициент Кп РЭДС :
          lbx =  (slw)( (slw)lbx * (slw)(sw)_r.DT_ZISk >> 8 ) ;
          lbx /= (lw)skor ;
          // Собственно воздействие на Кп РЭДС ( М>1  ) или ( М<1  ) :
          lax *= lbx ;
          if ( lax == 0 )  lax = 1 ;
        }
    }*/

    //-----------------18.06.07 08:55-------------------
    //---------- preventive overflow control -----------
    cx = ax ;                     // ошибка .
    if ( (sw)cx < 0 )  cx = -cx ; // выпрямленная ошибка .
    // Если lax = 0 , то процессор _CM3_ при делении на нуль получает нуль , входит в условие
    // и выдаёт максимальный выход , что есть неправильно . Поэтому проверяем , что lax != 0 :
    if ( ((lw)cx >= (lw)0x7fffffff / lax) && (lax != 0) )    // sravnivaem modul oshibki
     {                                       // s maksimalno dopustimoy
       if ( (sw)ax >= 0 ) lax = 0x7fffffff ; // pri vychislennom 'Kp',
       else               lax = 0x80000000 ; // dlya 32-bit setki oshibkoy.
     }
    else  lax = (slw)lax * (slw)(sw)ax ;
    //asm   mul  lax , ax ;   // умножение интегр. коэффициента на ошибку
    //--------------------------------------------------

    //-----------------18.06.07 08:55-------------------
       //  Подготовка к контролю переполнения (без использ.'asm'):
       // если до сложения/вычитания операнды были одного знака, а результат
       // получился другого знака - значит произошло переполнение.
     cx = 2 ;
     if ( (slw)lax >= 0 ) // запоминаем сочетание знаков операндов.
      {
          if( (sw)Integr_REDS >= 0 ) cx = 0 ; // +/+
      }
     else if( (sw)Integr_REDS <  0 ) cx = 1 ; // -/-

     lax += (slw)(sw)Integr_REDS << 16 ; // дробная часть уходит, целая записывается .
     lax += (lw)(w)Integr_REDS_drob ;    // DROB ISN'T SIGNED !

              /* Проверка переполнений. */
                  //  переполнение в плюс?
          if     ( cx == 0 && (slw)lax <  0 ) goto p1 ;
                  //  переполнение в минус?
          else if( cx == 1 && (slw)lax >= 0 ) goto p2 ;
    //--------------------------------------------------

              /* Проверка ограничений. */
          if ( (slw)lax < (slw)r0 )
            {
    p2:       V.Fv_zad = r0 ;
            } // Ограничиваем на номинале <<16 , сдвиг компенсируем .
          else if ( (slw)lax >= ((slw)_Fv_nom( 1.00 ) << 16) ) //0x7fff )
            {
    p1:       V.Fv_zad = _Fv_nom( 1.00 ) ;//0x7fff >> 6 ;
            }
          else V.Fv_zad = (slw)lax >> 16 ;

        //  Признаки для Регулятора ЭДС перенесены в конец ф-ии Zadanie_Iv () ,
        // т.к. кроме Регулятора ЭДС на задание возбуждения влияют гашение ,
        // эконом.режим , CAN , циклы и т.д ...

/*  V.flg._.ltd_z_max = 0 , V.flg._.ltd_z_min = 0 ;
    if      ( V.Fv_zad > _r.Fv_zad_Max )
      {
        V.Fv_zad = _r.Fv_zad_Max ,  V.flg._.ltd_z_max = 1 ;
      }
    else if ( V.Fv_zad < _r.Fv_zad_Min )
      {
        V.Fv_zad = _r.Fv_zad_Min ,  V.flg._.ltd_z_min = 1 ;
      }
  */
  return  ;
 }
//-----------------------------------
//-----------------------------------

word  Fvz_to_Ivz ( void )
{
#define   _delta_Fv  (const w)(_Fv_nom( 1.0 ) / _Nf)

  register word ax, cx, bx ;
  register byte dx ;

    bx = V.Fv_zad ;

    // Для возможности реверсировать поле :
    if ( (sw)bx < 0 )  bx = ~bx + 1 ,  dx = 1 ;
    else                               dx = 0 ;

        /* нахождение нужного диапазона тока */
    if ( bx >= _Fv_nom( 1.00 ) )  bx = _Fv_nom( 1.00 ), cx = _Nf ;
    else                          cx = bx / _delta_Fv + 1 ;

        /* нахождение коэффициента между точками (линейная аппроксимация) */
    ax = Ivz.t[cx] - Ivz.t[cx-1]  ;
    bx -= _delta_Fv * (cx-1)  ;
    ax = (sw)ax * (sw)bx / (sw)_delta_Fv ;
    ax += Ivz.t[cx-1] ;

    if ( (sw)dx == 1  )  ax = ~ax + 1 ; // Задание на Мост2 реверсивного возбудителя .

    //V.Iv_zad = ax ;

  return ax ;
}
//---------------------------------------
        //  Преобразование тока возбуждения в Поток.
void  Iv_to_Fv ( void )
{
#define   _delta_Fv  (const w)(_Fv_nom( 1.0 ) / _Nf)

  register word ax, cx, bx ;
  register byte dx ;

    bx = V.Iv ;
    // Для возможности принимать обратную связь от реверсивного возбудителя :
    if ( (sw)bx < 0 )  bx = ~bx + 1 ,  dx = 1 ;
    else                               dx = 0 ;

        /* нахождение нужного диапазона тока */
       // пропускаем точку If=100%, т.к. реальный ток может быть больше 100%.
    for( cx = _Nf-1 ; bx < Ivz.t[cx] ; cx-- ) ;

        /* нахождение коэффициента между точками (линейная аппроксимация) */
    ax = Ivz.t[cx+1] - Ivz.t[cx]  ;
    bx = bx - Ivz.t[cx] ;
    ax = (sw)_delta_Fv * (sw)bx / (sw)ax   ;
    ax+= _delta_Fv * cx ;

    if ( (sw)dx == 1  )  ax = ~ax + 1 ; // Обратная связь от Моста2 реверсивного возбудителя .

    V.Fv = ax ;

  return ;
}
//---------------------------------------

        //  Определение момента .
void  MomentDvig ( void )
{
  // Момент определяем по классической ф-ле : M = CmФI .
  // Т.к. единицы относительные , то Cm не требуется .
  // Номинальный момент :
  //
  //                       Pном, кВт
  // Мном , Н/м = 975 * -------------- * 9.8
  //                     Nном, об/мин
  //
  // word ax ;
  //---
#ifndef  _SIFU2_  // Произведение Знакового Потока и Знакового Тока Якоря .
   #ifndef _KTE_GD
     Moment = (sw)((slw)( (slw)(sw)V.Fv * (slw)(sw)Id_dop_kod ) / (sw)_Id_Nom) ;
   #else
     Moment = (sw)((slw)( (slw)(sw)V.Fv * (slw)(sw)Igen ) / (sw)_Ig_Nom) ;
   #endif
#else             // Произведение Знакового Потока и Знакового Суммарного Тока .
     Moment = (sw)((slw)( (slw)(sw)V.Fv * (slw)(sw)Id_sum ) / (sw)_Id_Nom) ;
#endif

  // Для варианта с относительными единицами , Cm не требуется .
  //Moment = (sw)( (slw)(sw)ax * (slw)(sw)_r.Cm >> 8 ) ;

  return ;
}
//---------------------------------------

        //----  Формирование задания на ток возбуждения.
void Zadanie_Iv ( void )
{
  register word ax ; // задание тока возб.
#ifdef _RVId
  register word bx ; // задание тока возб.2
  word ax1, bx1;
#endif

  // Измерение If вынесено в фон 25.04.2008 , т.к. когда оно выполнялось РАЗ В ДВА ПУЛЬСА
  // начиная с 18.06.07 и если форма тока возбуждения была с ярко выраженными пульсами , то
  // измерение тока сильно качало .
         // Измерение If сканированием, либо через встроенное СИФУ возб.
#ifndef _Vozb_KTE
  #ifdef Iv_ach
    Usrednitel( &Iv_usr, 2);
    V.Iv = (slw)(sw)V.Iv_full * (slw)(sw)Mashtab.Iv / 256 ;
  //V.Iv = (sw)( (slw)(sw)V.Iv_full * (slw)(sw)_r.Mashtab_Iv >> 8 ) ;
  #endif
//#else // 25.02.08 15:46 перенесено в СИФУВ для синхронности.
    //Short_V_ImpLong () ;
#endif

#ifdef _RVId
    #ifdef Iv2_ach
        Usrednitel( &Iv2_usr, 2);
        V2.Iv = (slw)(sw)V2.Iv_full * (slw)(sw)Mashtab.Iv / 256 ;
        //V2.Iv = (sw)( (slw)(sw)V2.Iv_full * (slw)(sw)_r.Mashtab_Iv >> 8 ) ;
        RVId.dIf = V.Iv - V2.Iv ;
    #else
        V2.Iv = 0;
        RVId.dIf = 0;
    #endif
#endif

         // Формирование задания на ток возбуждения.
  // Эта программа вызывается в фоне ( _MAIN1.C ) . До 18.06.07 она вызывалась
  // не чаще , чем 1 раз в пульс . Но если объектная программа большая , время
  // фона становится больше , чем время пульса . Поэтому , исходя из того , что
  // фон вряд ли в скором времени станет больше 2х пульсов , выполняем РЭДС и
  // задание тока возбуждения  РАЗ В ДВА ПУЛЬСА .
  if ( (b)( Puls_counter - puls ) >= 2 )  // Для отработки раз в 2 пульса .
  {
    puls = (b)Puls_counter ;

    Iv_to_Fv() ; // Преобразование измеренного If в поток F.

    //------------
    // Скорость перехода во вторую зону вычисляем исходя из рассчетных
    // ЭДС II зоны и N II зоны и заданной ЭДС II зоны . Это обусловлено тем ,
    // что ослабление поля начинает регулятор ЭДС по сигналу ЭДС , а пересчет
    // коэффициентов РС и ограничений задания РТ происходит по достижении
    // скорости II зоны . В идеале это должно происходить одновременно .
    // Посему , при изменении уставки ЭДС II зоны необходимо пересчитывать
    // скорость II зоны относительно рассчетных ( наладочных ) значений .
    //
    //   Eds_II_Z      Eds_II_Z  рассч
    //  ----------- = -----------------
    //   Skor_II_Z     Skor_II_Z рассч
    //
    //
    //                 Eds_II_Z  *  Skor_II_Z рассч
    //   Skor_II_Z  = ------------------------------
    //                       Eds_II_Z  рассч
    //
    Skor_II_Z = (slw)(sw)_r.Z_II_EDS * (slw)(sw)_r.Skor2Z / (sw)_r.Z_EDS ;
    //------------

    MomentDvig () ; // Момент определяем по классической ф-ле : M = CmФI .

    //------------
      // если ток возбуждения не задается по CAN - задаем его штатным способом.
      // ----
      // 16.05.2019 - в Циклах РТВ контролируется только максимум задания тока возбуждения .
      //              Минимум задания тока возбуждения в НАЛАДОЧНЫХ РЕЖИМАХ не контролируется !
    if ( Prg._.Cikl == 1 && Ckl._.RTV  == 1 )  ax = OCIKL ;
    else if ( ( can_ConfigReg ( _CAN_Iv_Zad ) == 0 ) // если CAN-управляет током, то пусть
                             &&                      //  управляет им до конца...
              ( _r.Cfg2._.Rev_Pola == 0 ) ) // и если не включен алгоритм реверса поля...
    {     // Штатное управление.
      if ( _r.Cfg._.Dve_Zony == 1 )
      {
        Reg_Eds () ;  // 100...200mcs 21.01.04 09:37
        if ( V.flg._.otkl_func == 0 ) ax = Fvz_to_Ivz () ;
        else                          ax = V.Fv_zad ;
      }
      else
      {
        ax = _r.Iv_zad ; // Принятие задания из уставки .
        V.Fv_zad = V.Fv ;  // Инициализация Fv# реальным Fv для индикации .
      }

#ifdef _RVId
      RVId.Iv1_z = ax - RVId.dIfz;
      RVId.Iv2_z = ax + RVId.dIfz;

      RVId.Iv1_dlt = RVId.Iv1_z - _r.Iv_zad_Max;
      RVId.Iv2_dlt = RVId.Iv2_z - _r.Iv_zad_Max;

      if( (sw)RVId.Iv1_dlt > 0 ) RVId.Iv1_korr = RVId.Iv1_dlt;
      else                       RVId.Iv1_korr = 0;
      if( (sw)RVId.Iv2_dlt > 0 ) RVId.Iv2_korr = RVId.Iv2_dlt;
      else                       RVId.Iv2_korr = 0;

      RVId.flg._.Iv1_max = 0, RVId.flg._.Iv2_max = 0;
      ax1 = RVId.Iv1_z;
      if( (sw)ax1 > (sw)_r.Iv_zad_Max )
      {
          ax1 = _r.Iv_zad_Max;
          RVId.flg._.Iv1_max = 1;
      }
      bx1 = RVId.Iv2_z;
      if( (sw)bx1 > (sw)_r.Iv_zad_Max )
      {
          bx1 = _r.Iv_zad_Max;
          RVId.flg._.Iv2_max = 1;
      }

      RVId.Iv1_zad = ax1 - RVId.Iv2_korr;
      RVId.Iv2_zad = bx1 - RVId.Iv1_korr;

      if( _r.Cfg._.Dve_Zony == 0 )
      {
          if( _r.CfgRVId._.GL1_RVId == 1 ) ax = RVId.Iv1_zad;
          else                             ax = _r.Iv_zad_GL1;
          if( _r.CfgRVId._.GL2_RVId == 1 ) bx = RVId.Iv2_zad;
          else                             bx = _r.Iv_zad_GL2;
      }
      else
      {
          if( _r.CfgRVId._.GL1_RVId == 1 ) ax = RVId.Iv1_zad;
          if( _r.CfgRVId._.GL2_RVId == 1 ) bx = RVId.Iv2_zad;
          else                             bx = ax;
      }
#endif

//    ГАШЕНИЕ ПОЛЯ имеет больший приоритет , чем ЭКОНОМ.РЕЖИМ - поэтому
// опрашивается после него . Задание гашения ложится последним в V.Iv_zad
// и перебивает эконом режим :

      // ---------- ЭКОНОМ.РЕЖИМ - не в "Работе" -----------
      // О нахождении в СбГот или в аварии лучше судить не по последнему
      // коммутационному аппарату ( bi_QK1 == 0 ) , а по ( Prg._.Gotovn == 1 || bo_Avar == 1 ) ,
      // т.к. при отсуствии контактора Q2 по аварии может и не отключаться и ток возбуждения
      // в аварии не снизится .
   #ifndef _KTE_GD
      if ( _r.Cfg._.Iv_Econom == 1 && ( Prg._.Gotovn == 1 || bo_Avar == 1 || ( _r.Cfg2._.Iv_Econom2 == 1 && ZISkor == 0 ) ) ) //&& bi_QK1 == 0 )
   #else
      if ( _r.Cfg._.Iv_Econom == 1 && ( bi_LK  == 0 || ( _r.Cfg2._.Iv_Econom2 == 1 && ZISkor == 0 ) ) )
   #endif
      {
        // В режиме "Готовность" или при "Аварии" выдается задание на
        // минимальный ( экономичный стояночный ) ток возбуждения , при
        // условии , что двигатель стоит больше уставки _r.T_econom :
        if ( V.flg._.Iv_econom == 1 ) ax = _r.Iv_econom ;
        else if ( (sw)Skor < (sw)_r.Ostanov_skor
                           &&
                  (sw)Skor > (sw)( ~_r.Ostanov_skor + 1 ))
        {
          //установка признака "Эконом.режим" с выдержкой времени для исключения
          //бросков тока возбуждения при кратковременных отключениях контактора:
          if ( (u)((w)(Timer1_Ovr - Time_econom)) >= _r.T_econom )
               V.flg._.Iv_econom = 1 ;
        }
        else   Time_econom = Timer1_Ovr ;
      }
      else  // в режиме "Работа" ( и/или при откл. ЭКОНОМ. РЕЖИМЕ ) :
      {
        Time_econom = Timer1_Ovr ;
        V.flg._.Iv_econom = 0 ;    //снятие признака "Эконом.режим"
      }

      // ------------ ГАШЕНИЕ - не в "Работе" --------------
#ifdef bi_Gashenie
      // Принимать сигнал на гашение поля разрешается в аварии или в СбГот.
      // О нахождении в этих режимах можно судить по ЛК , но быстрее прийдут
      // сигналы ( Prg._.Gotovn == 1 || bo_Avar == 1 ) .
   #ifndef _KTE_GD
      if ( (bi_Gashenie == 1 && bi_QK1 == 0) ||
           (bi_Gashenie == 1 && (Prg._.Gotovn == 1 || bo_Avar == 1)) )
   #else
      if ( bi_Gashenie == 1 && bi_LK == 0 )
   #endif
      {
        // В режиме "Сборки Готовности" или при "Аварии" при наличии сигнала
        // "Гашение Поля" выдается задание на отрицательный ток возбуждения :
        if ( V.flg._.Iv_gashen == 1 ) ax = _r.Iv_gashen ;
        else
         {
           // установка признака "Гашение поля" по отдельной выдержке ,
           // не проверяя Останов двигателя во избежание затягивания гашения :
           if ( (u)((w)(Timer1_Ovr - time_gash_polja)) >= _r.T_gashenie )
            {
              V.flg._.Iv_gashen = 1 ;
            }
         }
      }
      else   // в режиме "Работа" ( и/или без команды "ГАШЕНИЕ ПОЛЯ" ) :
      {
        time_gash_polja = Timer1_Ovr ;
        V.flg._.Iv_gashen = 0 ;        //снятие признака "Гашение поля"
      }
#endif
      // ---------------------------------------------------

    }
    else  ax = Fvz_to_Ivz () ;  // перевод "CAN"/"Реверса Поля"-задания потока в Iv-заданнный .

        //  Признаки для Регулятора ЭДС.
        //  Признаки ограничения для РЭДС только внешние , внутри РЭДС они не
        // выставляются и не сбрасываются т.к. кроме РЭДС на задание возбуждения
        // влияют гашение , эконом.режим , CAN , циклы и т.д ...
        //  А уставки максимума и минимума для отключения интегратора общие ...

    // Проверка на Максимум Задания :
    V.flg._.ltd_z_max = 0 , V.flg._.ltd_z_min = 0 ;
    if      ( (sw)ax > (sw)_r.Iv_zad_Max )
      {
        ax = _r.Iv_zad_Max ,  V.flg._.ltd_z_max = 1 ;
      }
    // Проверка на Минимум Задания , если не определен Реверс Поля , если нет Гашения Поля и если циклы РТВ не заданы :
#ifndef _Rev_Pola
    else if ( (sw)ax < (sw)_r.Iv_zad_Min )
      {
        if ( V.flg._.Iv_gashen == 0 && Ckl._.RTV == 0 )
          {
            ax = _r.Iv_zad_Min ,  V.flg._.ltd_z_min = 1 ;
          }
      }
#else
    else if ( (sw)ax < (sw)(~_r.Iv_zad_Max+1) )
      {
        //if ( V.flg._.Iv_gashen == 0 )  // если нет гашения поля - проверка мин.
        //  {
            ax = ~_r.Iv_zad_Max+1 ,  V.flg._.ltd_z_min = 1 ;
        //  }
      }
#endif

#ifdef  _RVId
   if ( V.flg._.Iv_econom == 1 || V.flg._.Iv_gashen == 1 )  bx = ax ;
   else
   {
     if ( (sw)bx > (sw)_r.Iv_zad_Max )
     {
       bx = _r.Iv_zad_Max ;//,  V.flg._.ltd_z_max = 1 ;
     }
     else if ( (sw)bx < (sw)_r.Iv_zad_Min )
     {
       bx = _r.Iv_zad_Min ;//,  V.flg._.ltd_z_min = 1 ;
     }
   }

   //asm_di() ;         //запрещаем прерывание, чтобы задание легло одновременно
   V.Iv_zad  = ax ;   //в оба возбудителя
   V2.Iv_zad = bx ;
   //asm_ei() ;

#else
      // Перезапись задания в одном месте, т.к. оно считывается из прерывания.
   V.Iv_zad = ax ;
#endif

      // Вызов объектного задания на ток возбуждения , которое перебивает все предыдущее.
#ifndef _Vozb_KTE  // для встроенного возб. добавка переносится в прерывание
    obj_ConfigReg ( _Obj_Iv_Zad ) ; // чтобы не было гонок с перезаписью V.Iv_zad
#endif
  }

  return ;
}
