
 void  RegSk ( void )
 {
    static word  Time_ostanov  ;
    static word  Timer_ostanov  ;
    static word  OuIchRS_drob ;
           word  ax , cx , skor ;
          lword  lax , lbx ;
    //register struct RegFlags zn ;

#ifdef bi_RS_P // для адаптивного РС ( П и ПИ по команде ) :
          lword  lcx ,ldx ;
#endif

          //  Для расчетов второй зоны.
      skor = Skor ;
      if ( (sw)skor < 0 )  skor = ~skor + 1 ;

 //---------------
         // Копия задания, чтобы не портить его в исходнике.
      ZISkor = Z_Skor ;

      ZISkor_Ogr () ; // Проверка Задания Скорости на уставочные ограничения .

 // Задатчик Интенсивности

 zi_rs.in  = ZISkor ; //,  zip = &zi_rs ;

if ( Isp._.ZIRS_shunt == 0 ) // Если есть ЗИРC :
{
 Zad_Intens ( &zi_rs ) ;
}
else
{
 Set_ZI ( &zi_rs , ZISkor ) ; // Инициализация всего ЗИРС .
}

//---------------- торможение ЗИ при реверсе
 if ( S.flg._.Revers == 1 )
   {
     if ( Prz._.torm_zi_p == 1 && (sw)zi_rs.out > (sw)Ogr_zi_rev )  zi_rs.out = Ogr_zi_rev ;

     if ( Prz._.torm_zi_m == 1 && (sw)zi_rs.out < (sw)Ogr_zi_rev )  zi_rs.out = Ogr_zi_rev ;
   }
//------------------

 ZISkor = zi_rs.out ;


    // CAN-задание скорости посли ЗИ в РС :
 if ( can_ConfigReg ( _CAN_N_Zad_R ) == 1 ) ZISkor_Ogr () ;

    // Объектное задание скорости после ЗИ в РС .
 if ( obj_ConfigReg ( _Obj_N_Zad_R ) == 1 ) ZISkor_Ogr () ;
//-------------------------

// ------------- Реализация режима "ОСТАНОВ" ---------------

          // Выявление условия входа в режим "Останов".
      if ( ( ( _r.Cfg._.Ostanov == 1
#ifdef bi_Ostanov_Regim // Внешний сигнал для входа в ОСТАНОВ , при отключенном режиме "РС-Останов" .
                        // Если подан дискретный сигнал "Останов" , то в "F2-Наладке" не обращаем на него внимания :
                                   || ( bi_Ostanov_Regim == 1 && Isp.all == 0 )
#endif
                       ) &&
#ifdef bi_Ostanov       // Внешний сигнал для входа в ОСТАНОВ , если включён режиме "РС-Останов" .
                        // Если подан дискретный сигнал "Останов" , то в "F2-Наладке" не обращаем на него внимания :
                                      ( bi_Ostanov == 1 && Isp.all == 0 ) &&
#endif
          (sw)Z_Skor < (sw)_r.Ostanov_skor && (sw)Z_Skor > (sw)( ~_r.Ostanov_skor + 1 )
                         &&
          (sw)ZISkor < (sw)_r.Ostanov_skor && (sw)ZISkor > (sw)( ~_r.Ostanov_skor + 1 )
                         &&
          (sw)Skor < (sw)_r.Ostanov_skor && (sw)Skor > (sw)( ~_r.Ostanov_skor + 1 ) )
#ifdef bi_Ostanov_Prinudit // Внешний сигнал для принудительного входа в ОСТАНОВ :
            || (bi_Ostanov_Prinudit == 1 && Isp.all == 0)
#endif
          )
        {
            // выдержка времени для проверки устойчивости условий "Останова".
          if ( Timer_ostanov > _r.Ostanov_time )
            {
              Prg._.RegTok   = 0 ;
              OuIchRS = 0 ;
              OuIchRS_drob = 0 ;
              OuRegS_dop_kod = 0 ;
              OuRegS         = 0 ;
              OIRT_drob = 0      ;
              Set_ZIRT ( &zi_rt , 0 ) ;
#ifndef _KTE_GD
              ZIDN = ZIDN1 = 0 ;  /* выход ЗИ-РТ. */
              OIRT  = _r.RevU0  ;  /* интегратор регулятора тока */
              OIRT1 = _r.RevU0  ;  /* интегратор регулятора тока */
            #ifdef _SIFU2_
               Set_ZIRT ( &zi_rt2 , 0 ) ;
               OIRT_drob_2_ = 0 ;
               ZIDN_2_  = ZIDN1_2_ = 0 ;  /* выход ЗИ-РТ. */
               OIRT_2_  = _r.RevU0  ;  /* интегратор регулятора тока */
               OIRT1_2_ = _r.RevU0  ;  /* интегратор регулятора тока */
            #endif
              S.Alfa = _r.RevU0 ;
              mOtkl_Imp( _Ostanov_imp ) ;
#else
              Set_ZI ( &zi_rtg , 0 ) ;
              OIRT  = 0 ;  /* интегратор регулятора тока */
              Prg._.RN = 1 ; // задание на нулевое напряжение генератора.
              ORT = 0 ;
#endif
#ifdef _Rev_Pola
              OuRegS_long = 0 ;
#endif
              goto end ;
            }
          else Timer_ostanov += Timer1_Ovr - Time_ostanov ;
        }
      else if ( Timer_ostanov != 0 )// для однократности выхода из ОСТАНОВА.
        {
          Timer_ostanov = 0 ;
          Prg._.RegTok   = 1 ;
#ifndef _KTE_GD
          mVkl_Imp( _Ostanov_imp ) ;
#endif
        }
      Time_ostanov = Timer1_Ovr ;

 //ДДДДДДДДД Расчет ПИП-части. ДДДДДДДДДДДДД

#ifdef bi_RS_P // для адаптивного РС ( П и ПИ по команде ) :
               // включена ПИ-структура :
 #ifdef bi_RS_Koef_2
  if ( ( _or.KRSPIP != 0 && _or.KRSI != 0 && bi_RS_P == 0 && bi_RS_Koef_2 == 1 ) ||
       (  _r.KRSPIP != 0 &&  _r.KRSI != 0 && bi_RS_P == 0 && bi_RS_Koef_2 == 0 ) )
 #else
  if (    _r.KRSPIP != 0 &&  _r.KRSI != 0 && bi_RS_P == 0 )
 #endif

#else

#ifdef bi_RS_Koef_2
  if ( ( _or.KRSPIP != 0 && _or.KRSI != 0 && bi_RS_Koef_2 == 1 ) ||
       (  _r.KRSPIP != 0 &&  _r.KRSI != 0 && bi_RS_Koef_2 == 0 ) )
#else
  if (    _r.KRSPIP != 0 &&  _r.KRSI != 0 )
#endif

#endif
  {
  //  Выход интегральной части "OuIchRS" делится на "64" и далее умножается
  //  на делитель ( "64" / "_r.KRSPIP" ).
  //  Коэффициент "Kпип-РC" расположен в делителе для удобства использования.
  //  В таком случае он всегда будет больше или рaвен "1". Например,  при
  //  увеличении  "Kпип-РC" от 1ед до 10ед - в 10 раз уменьшится сигнал
  //  "OuIchRS_k" тем самым вырастут рассогласование между "Delta_Sk" и "OuIchRS_k"
  //  и сигнал  интегратора "OuIchRS".
  //  В прошлом варианте, чтобы оказать такое же действие нужно было "Kпип-РC"
  //  уменьшать от 1ед до 0,1ед

    lax  = (slw)(sw)OuIchRS << 16 ; // дробная часть уходит, целая записывается.
    lax += (lw)(w)OuIchRS_drob ;    // DROB ISN'T SIGNED !

    //------------------------- 29.10.2015 -----------------------------------
       // ТОЛЬКО для случаев , когда сигнал для переключения Коэффициентов РС приходит
#ifdef bi_RS_Koef_2 // не в работе , иначе необходимо делать плавное переключение :
  if ( bi_RS_Koef_2 == 1 )  lbx = _or.KRSPIP ;
  else
#endif
    //-----------------03.08.07 12:53-------------------
    lbx = _r.KRSPIP ;
                                    // "<< 8"-догоняем "Kpip*256" до формата
#ifdef _KTE_GD   //----- 15.10.08 ---------------
    lbx = lbx * _Ig_nom(0.01) / _Skor_nom(0.01) << 8 ;// коэфф."Ki=x*65536".
#else
    lbx = lbx * _Id_nom(0.01) / _Skor_nom(0.01) << 8 ;// коэфф."Ki=x*65536".
#endif
    lbx &= 0x7ffffffful ;  //защита от "-" коэфф.
    //--------------------------------------------------

    lax = (slw)lax / (slw)lbx ; // здесь основание "65536" сокращается .
    OuIchRS_k = (sw)lax ;
  }
 else OuIchRS_k = 0 ; // подумать , м.б. при адаптивном РС не сразу обнулять .

  // Исключение дребезга возле нуля О.С. по скорости

// 10.03.06 09:31 Со слов А.П. по замечаниям из Мариуполя
// if ( (sw)Skor < 3 && (sw)Skor > -3 )  Skor = 0 ;

//ДДДДДДДДДДД Расчет ошибки.  ДДДДДДДДДДДДДД

    ax = ZISkor - Skor ;

    Delta_Sk = ax ;

    if ( ax == 0 && OuIchRS_k == 0 && _r.KRSPIP != 0 )  OuIchRS = 0 ;

    ax -= (sw)OuIchRS_k ; // вычитаем интегральную часть без сдвига , т.к. после
                          // деления интегратора "OuIchRS" на Кпип "_r.KRSPIP"
                          // их основание 65536 сокращается .

 //ДДДДДДДДД Торможение интегратора и ЗИ ДДДДДДДДДДДД

    // 22.04.2008 - При реверсе ,
    if ( S.flg._.Revers == 1 )
     {   // если Мост и Ошибка разных знаков, не даем нарастать интегратору и ЗИ:
       if ( S.NumMost == 1 && (sw)Delta_Sk < 0 )
        {
         if ( Prz._.torm_zi_m == 0 )
           {
             Prz._.torm_zi_m = 1 ;
             Ogr_zi_rev = zi_rs.out ; // торможение ЗИ при реверсе, если надо.
           }
         goto v4 ;
        }
       else  Prz._.torm_zi_m = 0 ;


       if ( S.NumMost == 2 && (sw)Delta_Sk > 0 )
        {
         if ( Prz._.torm_zi_p == 0 )
           {
             Prz._.torm_zi_p = 1 ;
             Ogr_zi_rev = zi_rs.out ; // торможение ЗИ при реверсе, если надо.
           }
         goto v4 ;
        }
       else  Prz._.torm_zi_p = 0 ;
     }
    else Prz._.torm_zi_p = Prz._.torm_zi_m = 0 , Ogr_zi_rev = 0 ;

    //03.06.2019 - Продумать : при ПИП-регуляторе для Торможения интегратора и ЗИ нужно проверять
    //             чистую оишбку "Delta_Sk" , или всё-таки "ax" ...

 //ДДДДДДДДДДД Расчет интегратора.  ДДДДДДДДДДДДДД

//   Проверка ограничений на возрастание или снижение интегратора.
    if ( (sw)ax >= 0 )
      {
        if ( Prz._.int_p == 1 )  goto v4 ;
      }
    else
      {
        if ( Prz._.int_m == 1 )  goto v4 ;
      }

    //------------------------- 29.10.2015 -----------------------------------
       // ТОЛЬКО для случаев , когда сигнал для переключения Коэффициентов РС приходит
#ifdef bi_RS_Koef_2 // не в работе , иначе необходимо делать плавное переключение :
  if ( bi_RS_Koef_2 == 1 )  lax = _or.KRSI ;
  else
#endif
    lax = _r.KRSI ;

 //ДДДДДДДДДДД Увеличение коэффициента Ки во второй зоне ДДДДДДДДДДДДДД
 //ДДДДДДДДДДДДДДДД пропорционально росту скорости. ДДДДДДДДДДДДДДДДДДД
    if ( _r.Cfg._.Dve_Zony == 1 && (w)skor > (w)Skor_II_Z &&   // Проверка перехода во вторую зону.
         (sw)_r.KRSI_II_Z < (sw)(slw)lax && _r.KRSI_II_Z != 0 ) // Уставка "Ти-РС второй зоны" д.б. задана меньше , чем "Ти-РС" .
    {
        //   В Теории , коэффициент регулятора должен увеличиваться во столько же раз , во сколько текущая скорость
        // превышает скорость перехода во вторую зону ...
        lbx = lax - _r.KRSI_II_Z ;
        if ( (slw)lbx < 0 ) lbx = 0 ;
        lbx *= (w)(skor - Skor_II_Z) ;
        cx = _r.Z_SkMax_P - Skor_II_Z ;
        if ( (sw)cx <= 0 ) cx = 1 ;
        lbx /= (w)cx ;
        KRSI_ind = (w)(lax - lbx) ;
        //--------
        // Если "вычисленная Ти-РС" получилась меньше , чем "Ти-РС второй зоны" , то ограничиваем :
        if ( (sw)KRSI_ind < (sw)_r.KRSI_II_Z ) KRSI_ind = _r.KRSI_II_Z ;
        lax = KRSI_ind ;
    }
 //ДДДДДДДДДДД

    KRSI_ind = lax ; // Индикация окончательного Ти РС .

    if ( lax == 0 )
     {             // инициализация интегратора при Ки = 0 :
       OuIchRS = 0 ;
       OuIchRS_drob = 0 ;
       goto v4 ;
     }

    //-----------------03.08.07 12:53-------------------
#ifdef _KTE_GD   //----- 15.10.08 ---------------
    lax = (lw)( (d)_Ig_nom(0.01) / (d)_Skor_nom(0.01) * _RS_T *  65535.) / lax ;
#else
    lax = (lw)( (d)_Id_nom(0.01) / (d)_Skor_nom(0.01) * _RS_T *  65535.) / lax ;
#endif
    lax &= 0x7ffffffful ;  //защита от "-" коэфф.
    //--------------------------------------------------

#ifdef bi_RS_P // для адаптивного РС ( П и ПИ по команде ) :

    if ( bi_RS_P == 1 )  lax = 0 ; // команда на включение П-рег .

    if ( lax == 0 )        // Если И-часть отключена ,
     {                     // проверяем обнулен ли интегратор :
       if ( OuIchRS != 0 ) // Если интегратор еще не обнулен ,
       {                   // обнуляем его с темпом :
         lbx = (lw)_r.Adapt_temp << 16 ;
         lbx = (lw)_RS_T * lbx / (lw)1000 ;
         if ( lbx == 0 )  lbx = 1 ;  // Если темп нулевой .
         //---
         lcx  = (slw)(sw)OuIchRS << 16 ;
         lcx += (lw)(w)OuIchRS_drob ;   // DROB ISN'T SIGNED !
         //---
         if ( (slw)lcx > 0 ) // Если интегратор положительный , вычитаем :
          {
            lcx -= lbx ;
            if ( (slw)lcx < 0 ) lcx = 0 ; // проверка , что не отрицательный .
          }
         else                   // Если интегратор отрицательный , прибавляем :
          {
            lcx += lbx ;
            if ( (slw)lcx > 0 ) lcx = 0 ; // проверка , что не положительный .
          }
         OuIchRS = (slw)lcx >> 16 ; // дробная часть уходит, целая записывается .
         OuIchRS_drob = lcx ;       // запись дробной части .
       }
       else goto v4 ; // Если интегратор уже обнулен , идем на П-часть .
     }
#endif

    //-----------------03.08.07 12:53-------------------
    //---------- preventive overflow control -----------
    cx = ax ;                     // ошибка .
    if ( (sw)cx < 0 )  cx = -cx ; // выпрямленная ошибка .
    // Если lax = 0 , то процессор _CM3_ при делении на нуль получает нуль , входит в условие
    // и выдаёт максимальный выход , что есть неправильно . Поэтому проверяем , что lax != 0 :
    if ( ((lw)cx >= (lw)0x7fffffff / lax) && (lax != 0) )    // sravnivaem modul oshibki
     {                                       // s maksimalno dopustimoy
       if ( (sw)ax >= 0 ) lax = 0x7fffffff ; // pri vychislennom 'Ki',
       else               lax = 0x80000000 ; // dlya 32-bit setki oshibkoy.
     }
    else  lax = (slw)lax * (slw)(sw)ax ;
    //asm   mul  lax , ax ;   // умножение интегр. коэффициента на ошибку
    //--------------------------------------------------

    //-----------------03.08.07 12:53-------------------
       //  Подготовка к контролю переполнения (без использ.'asm'):
       // если до сложения/вычитания операнды были одного знака, а результат
       // получился другого знака - значит произошло переполнение.
     cx = 2 ;
     if ( (slw)lax >= 0 ) // запоминаем сочетание знаков операндов.
      {
          if( (sw)OuIchRS >= 0 ) cx = 0 ; // +/+
      }
     else if( (sw)OuIchRS <  0 ) cx = 1 ; // -/-

     lax += (slw)(sw)OuIchRS << 16 ;
     lax += (lw)(w)OuIchRS_drob ;   // DROB ISN'T SIGNED !

              /* Проверка переполнений. */
                  //  переполнение в плюс?
          if     ( cx == 0 && (slw)lax <  0 ) goto v1 ;
                  //  переполнение в минус?
          else if( cx == 1 && (slw)lax >= 0 ) goto v2 ;
    //--------------------------------------------------

              /* Проверка ограничений. */
#ifdef  _CM3_
          if ( (slw)lax < (slw)0xf8000000 )
            {
    v2:       lax = 0xf8000000 ;  // -512*4 дискрет * 65536.
            }  // не подпускаем к краю сетки, чтобы можно было контролир.переполн.
          else if ( (slw)lax >= (slw)0x07ff0000 )
            {
    v1:       lax = 0x07ff0000 ;  // +512*4 дискрет * 65536.
            }
#else
          if ( (slw)lax < (slw)0xfe000000 )
            {
    v2:       lax = 0xfe000000 ;  // -512 дискрет * 65536.
            }  // не подпускаем к краю сетки, чтобы можно было контролир.переполн.
          else if ( (slw)lax >= (slw)0x01ff0000 )
            {
    v1:       lax = 0x01ff0000 ;  // +512 дискрет * 65536.
            }
#endif
         OuIchRS = (slw)lax >> 16 ; // дробная часть уходит, целая записывается .
         OuIchRS_drob = lax ;       // запись дробной части .

         // Нереверсивным агрегатам обрезаем отрицательный интегратор :
         if ( _r.Cfg._.Ne_Revers == 1 && (sw)OuIchRS < (sw)0
#ifndef _KTEV
              && _r.Cfg2._.Rev_Pola == 0
#endif
                ) OuIchRS = 0 , OuIchRS_drob = 0 ;

    v4:  Prz._.int_p = 0 ,  Prz._.int_m = 0 ;

    //ДДДДДД  Расчет пропорциональной составляющей и выхода регулятора. ДДДДДД

#ifdef bi_RS_P // для адаптивного РС ( П и ПИ по команде ) :
    if ( bi_RS_P == 1 ) lax = _r.KRSP_for_P ; // команда на вкл. П-рег .
    else
#endif
    //------------------------- 29.10.2015 -----------------------------------
       // ТОЛЬКО для случаев , когда сигнал для переключения Коэффициентов РС приходит
#ifdef bi_RS_Koef_2 // не в работе , иначе необходимо делать плавное переключение :
  if ( bi_RS_Koef_2 == 1 )  lax = _or.KRSP ;
  else
#endif
    lax = _r.KRSP ;

 //ДДДДДДДДДДД Увеличение коэффициента Кп во второй зоне ДДДДДДДДДДДДДД
 //ДДДДДДДДДДДДДДДД пропорционально росту скорости. ДДДДДДДДДДДДДДДДДДД
    if ( _r.Cfg._.Dve_Zony == 1 && (w)skor > (w)Skor_II_Z &&   // Проверка перехода во вторую зону.
         (sw)_r.KRSP_II_Z > (sw)(slw)lax )                     // Уставка "Кп-РС второй зоны" д.б. задана больше , чем "Кп-РС" .
    {
        //   В Теории , коэффициент регулятора должен увеличиваться во столько же раз , во сколько текущая скорость
        // превышает скорость перехода во вторую зону ...
        lbx = _r.KRSP_II_Z - lax ;
        if ( (slw)lbx < 0 ) lbx = 0 ;
        lbx *= (w)(skor - Skor_II_Z) ;
        cx = _r.Z_SkMax_P - Skor_II_Z ;
        if ( (sw)cx <= 0 ) cx = 1 ;
        lbx /= (w)cx ;
        KRSP_ind = (w)(lax + lbx) ;
        //--------
        // Если "вычисленный Кп-РС" получился больше , чем "Кп-РС второй зоны" , то ограничиваем :
        if ( (sw)KRSP_ind > (sw)_r.KRSP_II_Z ) KRSP_ind = _r.KRSP_II_Z ;
        lax = KRSP_ind ;
    }
 //ДДДДДДДДДДД

    KRSP_ind = lax ; // Индикация окончательного Kп РС .

    //-----------------03.08.07 12:53-------------------
                                    // "<< 8"-догоняем "Kp*256" до формата
#ifdef _KTE_GD   //----- 15.10.08 ---------------
    lax = lax * _Ig_nom(0.01) / _Skor_nom(0.01) << 8 ; // коэфф."Ki=x*65536".
#else
    lax = lax * _Id_nom(0.01) / _Skor_nom(0.01) << 8 ; // коэфф."Ki=x*65536".
#endif
    lax &= 0x7ffffffful ;   //защита от "-" коэфф.
    //--------------------------------------------------

#ifdef bi_RS_P // для адаптивного РС ( П и ПИ по команде ) :

    if ( _r_KRSP != lax )   // Если Кп еще не вышел на требуемый уровень ,
     {                      // то определяем на сколько следующим образом :
       ldx = _r_KRSP - lax ; // из текущего Кп вычитаем требуемый Кп .

                                          // Темп для П-части необходимо
       lbx = (lw)_r.Adapt_temp << 6 ;     // определить заново , т.к. в
       lbx = (lw)_RS_T * lbx / (lw)1000 ; // И-части его рассчет еще мог
                                          // не провестись ...
       if ( lbx == 0 )  lbx = 1 ;  // Если темп нулевой .
       // Выгоняем Кп на требуемый уровень с заданным темпом :
       if ( (slw)ldx > 0 ) // Если дельта положительная , вычитаем :
        {
          lcx = _r_KRSP - lbx ;
          if ( (slw)lcx < (slw)lax ) _r_KRSP = lax ; //Уст., если перестарались.
          else                       _r_KRSP = lcx ;
        }
       else                // Если дельта отрицательная , прибавляем :
        {
          lcx = _r_KRSP + lbx ;
          if ( (slw)lcx > (slw)lax ) _r_KRSP = lax ; //Уст., если перестарались.
          else                       _r_KRSP = lcx ;
        }
     }
    lax =  _r_KRSP ;
#endif

      ax = Delta_Sk; // Для правильной работы ПИП-регулятора , перед рассчетом П-части ,
                     // кладем в "ax" чистую ошибку , затирая то , что  было там при
                     // рассчете ограниченного коэффициентом "Кпип-РС" интегратора .

    //-----------------03.08.07 12:53-------------------
    //---------- preventive overflow control -----------
    cx = ax ;                     // ошибка .
    if ( (sw)cx < 0 )  cx = -cx ; // выпрямленная ошибка .
    // Если lax = 0 , то процессор _CM3_ при делении на нуль получает нуль , входит в условие
    // и выдаёт максимальный выход , что есть неправильно . Поэтому проверяем , что lax != 0 :
    if ( ((lw)cx >= (lw)0x7fffffff / lax) && (lax != 0) )    // sravnivaem modul oshibki
     {                                       // s maksimalno dopustimoy
       if ( (sw)ax >= 0 ) lax = 0x7fffffff ; // pri vychislennom 'Kp',
       else               lax = 0x80000000 ; // dlya 32-bit setki oshibkoy.
     }
    else  lax = (slw)lax * (slw)(sw)ax ;
    //asm   mul  lax , ax ;   // умножение интегр. коэффициента на ошибку
    //--------------------------------------------------

    //-----------------03.08.07 12:53-------------------
       //  Подготовка к контролю переполнения (без использ.'asm'):
       // если до сложения/вычитания операнды были одного знака, а результат
       // получился другого знака - значит произошло переполнение.
     cx = 2 ;
     if ( (slw)lax >= 0 ) // запоминаем сочетание знаков операндов.
      {
          if( (sw)OuIchRS >= 0 ) cx = 0 ; // +/+
      }
     else if( (sw)OuIchRS <  0 ) cx = 1 ; // -/-

     lax += (slw)(sw)OuIchRS << 16 ; // дробная часть уходит, целая записывается .
     lax += (lw)(w)OuIchRS_drob ;    // DROB ISN'T SIGNED !

              /* Проверка переполнений. */
                  //  переполнение в плюс?
          if     ( cx == 0 && (slw)lax <  0 ) goto p1 ;
                  //  переполнение в минус?
          else if( cx == 1 && (slw)lax >= 0 ) goto p2 ;
    //--------------------------------------------------

              /* Проверка ограничений. */
#ifdef  _CM3_
          if ( (slw)lax < (slw)0xf8000000 ) // 0xfe000000
            {
    p2:       OuRegS_dop_kod = 0xf800 , Prz._.int_m = 1 ; // -512*4 дискрет .
            }  // не подпускаем к краю сетки, чтобы можно было контролир.переполн.
          else if ( (slw)lax >= (slw)0x07ff0000 )  //0x01ff0000
            {
    p1:       OuRegS_dop_kod = 0x07ff , Prz._.int_p = 1 ; // +512*4 дискрет .
            }
#else
          if ( (slw)lax < (slw)0xfe000000 )
            {
    p2:       OuRegS_dop_kod = 0xfe00 , Prz._.int_m = 1 ; // -512 дискрет .
            }  // не подпускаем к краю сетки, чтобы можно было контролир.переполн.
          else if ( (slw)lax >= (slw)0x01ff0000 )
            {
    p1:       OuRegS_dop_kod = 0x01ff , Prz._.int_p = 1 ; // +512 дискрет .
            }
#endif
          else OuRegS_dop_kod = (slw)lax >> 16 ;

 #ifdef _Rev_Pola

     if ( Prz._.int_m == 1 )
        #ifdef  _CM3_
            lax  =  0xf8000000 ;
        #else
            lax  =  0xfe000000 ;
        #endif
     if ( Prz._.int_p == 1 )
        #ifdef  _CM3_
            lax  =  0x07ff0000 ;
        #else
            lax  =  0x01ff0000 ;
        #endif

     OuRegS_long = (slw)lax >> 4 ;

 #endif
     //IchRS =  OuRegS ;

end:  //RegFlg = zn ;

    return  ;
 }

//------------------------------------------

void ZISkor_Ogr ( void )
 {
// Проверка Задания Скорости на превышение или снижение уставочных ограничений.  .

           if ( (sw)ZISkor >= (sw)_r.Z_SkMax_P ) ZISkor = _r.Z_SkMax_P ;
      else if ( (sw)ZISkor <  (sw)_r.Z_SkMax_M ) ZISkor = _r.Z_SkMax_M ;

   return ;
 }

//------------------------------------------

void Izm_TG ( word num )        //150-200mcs
{

//#ifdef _KTEV // Заглушка для КТЭВ , чтоб пропускал компилятор
#ifndef TG_ach // 14.09.07 11:24 - Заглушка для всех агрегатов , у которых
   num = num ;                  // нет канала TG_ach .
#else

          word ax , dx ;
   static word bx , cx ;
   static byte tst ;

   switch ( num )
   {
     case 1 :
       //------ Измерение напряжения собственного тахогенератора  -----//
       bx = _AD_BUSY  ;
       mAD_Izm( TG_ach, &bx ) ;

#ifdef  TGx_ach
       //------ Измерение напряжения собственного тахогенератора , умноженного на 10 -----//
       cx = _AD_BUSY  ;
       mAD_Izm( TGx_ach, &cx ) ;
#else
       cx = 0 , dx = 0 , tst = 0 ; // Заглушки для компилятора .
#endif
     break;

     case 2 :
       while ( bx == _AD_BUSY ) ;

        // Преобразование в знаковый дополнительный код.
       mIzmData_Conversion( bx , ax , TG_ach ) ;
       ax = (sw)ax << _Skor_Shift ;
        // Mасштабирование наряжения
       ax = (sw)( (slw)(sw)ax * (slw)(sw)_r.Mashtab_OS_TG >> 8 ) ;

#ifdef  TGx_ach
       //------
       while ( cx == _AD_BUSY ) ;

        // Преобразование в знаковый дополнительный код.
       mIzmData_Conversion( cx , dx , TGx_ach ) ;
        // Mасштабирование наряжения
        // компенсирующее расбаланс масштабирование
       dx = (sw)( (slw)(sw)dx * (slw)(sw)_r.Mashtab_OS_TGx >> 8 ) ;
        // общее базовое масштабирование
       dx = (sw)( (slw)(sw)dx * (slw)(sw)_r.Mashtab_OS_TG >> 8 ) ;
#endif

  #ifdef    _TG_vypryamlen
          //  Для ТГ переменного тока с выпрямлением
         // и определением знака по знаку ЭДС.
       if ( (sw)ax < 0 )  ax = ~ax + 1 ; // выпрямление смещения нуля.
       if ( (sw)dx < 0 )  dx = ~dx + 1 ; // выпрямление смещения нуля.
       //------
       if ( (sw)EDS_dop_kod < 0 )  ax = ~ax + 1 , dx = ~dx + 1 ;
  #endif

#ifdef  TGx_ach
       TGx1 = ax ;
       TGx8 = dx ;

       //------
        // Выбор канала обратной связи TG .
      if ( (sw)ax < 0 ) ax = ~ax+1 ;

      if ( tst == 0 )
      {   // ограничение выхода платы умножения начинается с 4.4В и до 5.6В.
        TG = TGx1 ;
        if ( ax < _r.TGx8_porog ) tst = 1 ; // переходим на TGx8
      }
      else
      {
        TG = TGx8 ;                          // снимаемся с TGx8
        if ( ax > (w)(_r.TGx8_porog+_Skor_nom( 0.02 )) ) tst = 0 ;
      }
#else
        TG = ax ;
#endif

     break;
   }
#endif

   return ;
}

//------------------------------------------

// Функция фильтра скорости , вызывается независимо от того , включен ли фильтр
// для индикации нефильтрованной и отфильтрованной скоростей .

word Filtr_Sk ( word num )
{
    word ax , dx ;
    sword  cx ;
    slword  lax;

 switch ( num )
  {
   case 0 : // инициализация .
    Kf_Sk = _r.K_fil_sk ;
    if ( Kf_Sk <= 1 )  Kf_Sk = 2 ;
    drob_FSk = 0 ;
    Skor_f = 0 ;
   break ;

   case 1 :
//if ( new_izm_pdf == 1 ) //вызывается раз в 10ms
 //{
    cx = Skor - Skor_f ; //разность скорости между измеренной и отфильтрованной
    dx = cx ;  //сохранение разности

    //смещение на 16 бит влево для получения в дальнейшем числа с дробной частью
    lax = ( (slw)(sw)cx << 16 );

    ax = Kf_Sk ;
    lax /= (slw)(sw)ax ; // деление на текущий коэффициент фильтрации

    // добавление к результату дробной части, оставшейся в прошлом вычислении
    lax += (lw)(w)drob_FSk ;
    drob_FSk = (w)lax ;  //сохранение текущей дробной части для след-го вычисл-ия

    cx = (slw)lax >> 16 ; //смещение на 16 бит вправо для получения челой части
    Skor_f += cx ;    //добавление к выходу фильтра  целой части от деления.


         //---  определение коэффициента фильтрации

    // если разность выше уставочного порога
    if ( (sw)dx >= (sw)_r.porog_fil || (sw)dx <= (sw)( ~_r.porog_fil + 1 ) )
      {
        // если разность на прошлом шаге была другого знака -
        // - коэффициент фильтрации не уменьшается
        cx = Skor - Skor_f ;
        if ( ( (sw)cx < 0 && (sw)Delt_n > 0 )
                          ||
             ( (sw)cx > 0 && (sw)Delt_n < 0 ) )
          {
            dfgg++ ;
            goto sz ;
          }
        ax = ax / 2 ; // деление КF_sk на два.
        if ( ax <= 1 )  ax = 2 ;
      }
    else  // если разность не вылезла за порог
      {
        sz:
        ax = ax * 2 ; // умножение КF_sk на два.
        if ( ax > _r.K_fil_sk )   ax = _r.K_fil_sk ;  // ограничение КF_sk.
      }

    //сохранение данных.
    Kf_Sk = ax ;
    Delt_n = dx ;
 //}

    //Skor = Skor_f ; // 24.01.07 09:45 - если фильтр включен .
   break ;
  }
    return 0 ;
}

//------------------------------------------

// Функция для определения рассчетной скорости по ЭДС .
void Izm_Skor_EDS ( void )
{
  word ax , bx ;

  if ( _r.Cfg._.Dve_Zony == 1 )
   {
         //
         // Скорость по ЭДС вычисляем по классической формуле E=CeФn :
         //
         //            Fном      Skor2Z
         // N = Eds * ------ * ----------- ;
         //             F       EdsVkl_2Z
         //

     if ( V.Fv < _r.Iv_zad_Min ) ax = _r.Iv_zad_Min ;
     else                        ax = V.Fv ;
     bx = (sw)EDS_dop_kod ;
     ax = (slw)(sw)bx * (slw)(sw)_Fv_Nom / (sw)ax ;
     Skor_r = (slw)(sw)ax * (slw)(sw)Skor_II_Z / (sw)_r.Z_II_EDS ;
   }
  // Если не выбрана ДвухЗонка , для рассчетной скорости берется ЭДС .
  else Skor_r = (sw)EDS_dop_kod ;
return ;
}

//------------------------------------------

// Функция для замены темпов ЗИ .
//#ifdef bi_Fors_Temp - 30.01.2020 функция замены темпов должна работать всегда .
void  Fors_Temp ( void )
{
  // Все темпы ЗИС даны по уровню приоритета :
  //----
  // Штатный темп ЗИС ( если нет Форсированного Темпа и Темпа для Ревизии ) .
  // 05.03.2020 - Штатный темп используем так же во всех наладочных режимах во избежание разных эксцессов ,
  // как , например , самонастрйка функционала на клети ЦГПТЛ при которой сработал Форсированный Темп
  // и двигатель не разлетелся только благодаря центробежнику ...
  if ( (bi_Fors_Temp == 0 &&
 #ifdef bi_Reviz
                             bi_Reviz == 0 &&
 #endif
                                              Shtat_temp == 0) || Isp.all != 0 )
    {
      zi_rs.temp_p_razg = &_r.T_ZISkorP_Razg ;
      zi_rs.temp_p_torm = &_r.T_ZISkorP_Torm ;
    #ifndef _ZI_4TEMPA
      zi_rs.temp_m_razg = &_r.T_ZISkorP_Razg ;
      zi_rs.temp_m_torm = &_r.T_ZISkorP_Torm ;
    #else
      zi_rs.temp_m_razg = &_r.T_ZISkorM_Razg ;
      zi_rs.temp_m_torm = &_r.T_ZISkorM_Torm ;
    #endif

      Shtat_temp = 1 ; // флаг для однократности .
      Fors_temp  = 0 ;
      Reviz_temp = 0 ;
    }
  //----
  // Форсированный темп ( Ревизию не проверяем , у нее приоритет меньше ) :
  else if ( bi_Fors_Temp == 1 && Fors_temp == 0 )
    {
      zi_rs.temp_p_razg = &_r.T_ZISkorP_Fors ;
      zi_rs.temp_p_torm = &_r.T_ZISkorP_Fors ;
      zi_rs.temp_m_razg = &_r.T_ZISkorP_Fors ;
      zi_rs.temp_m_torm = &_r.T_ZISkorP_Fors ;

      Shtat_temp = 0 ;
      Fors_temp  = 1 ; // флаг для однократности .
      Reviz_temp = 0 ;

    /*if ( Prg._.Gotovn == 0 )  // В режиме "Работа" ( не в "Сборке Готовн" ) :
       {
         if ( (sw)Skor < (sw)_r.Ostanov_skor
                      &&
              (sw)Skor > (sw)( ~_r.Ostanov_skor + 1 ) )
          {
            // После остановки привода даем оперативное отключение контактора :
            mSet_AvarMsg( _Av_VR1 ) ;
          }
       }*/
    }
  // Темп ЗИС для Ревизии ( Перед этим проверен Штатный темп и Форсированный темп ) :
 #ifdef bi_Reviz
  else if ( bi_Reviz == 1 && Reviz_temp == 0 ) // Темп для Ревизии .
    {
      zi_rs.temp_p_razg = &_or.T_ZISkor_Reviz ;
      zi_rs.temp_p_torm = &_or.T_ZISkor_Reviz ;
      zi_rs.temp_m_razg = &_or.T_ZISkor_Reviz ;
      zi_rs.temp_m_torm = &_or.T_ZISkor_Reviz ;

      Shtat_temp = 0 ;
      Fors_temp  = 0 ;
      Reviz_temp = 1 ; // флаг для однократности .
    }
 #endif
}
//#endif

//------------------------------------------

// Программа Регулятора Положения :
#ifdef _REG_POL
 void  RegPol ( void )
 {
    static word Integr_RP_drob ;
    static byte tst ;

    register lword lax , lbx ;
    register sword  ax ;
              word  cx ;

         // Копия задания, чтобы не портить его в исходнике.
 ZIUgol = ZUgol ;

 // Задатчик Интенсивности
 //zi_rp.in  = ZIUgol ;
 //Zad_Intens ( &zi_rp ) ;
 //ZIUgol = zi_rp.out ;

 //ДДДДДДДДДДД Расчет ошибки.  ДДДДДДДДДДДДДД

  ax = ZIUgol - Ugol ;

 //ДДДДДДДДДДДДДДД Мертвая зона ДДДДДДДДДДДДДДДДДД

     /* Проверка нахождения в мертвой зоне. */
    if ( tst == 0 ) // Зона Больших Отклонений .
    {
      // Проверка входа в Мертвую Зону , выставляем признак мертвой зоны... Порог половинный :
      if ( (sw)ax < (sw)_r.DeltaDeadZone/2 && (sw)ax > (sw)( ~(_r.DeltaDeadZone/2)+1) ) tst = 1 ;
    }
      // Выход из Мертвой Зоны . Переключение с гистерезисом . Порог полный :
    else if ( (sw)ax > (sw)_r.DeltaDeadZone || (sw)ax < (sw)(~_r.DeltaDeadZone+1) ) tst = 0 ;

    if ( tst == 1 ) // В мертвой зоне :
     {
       ax = 0 ;        // Обнуляем ошибку .
       RP_in_sqr = 0 ; // Обнуляем корень ошибки .
                       // Подумать , обнулять ли интегратор ? Скорее всего останавливать ...
       OuRP = 0 ;      // Обнуляем выход РП .
       goto end ;
     }

 //ДДДДДДДДДДДДДДД Точный сельсин ДДДДДДДДДДДДДДДДДД

    // Переключение с Грубого на Точный сельсин ....
    // Перерасчет ошибки :
    // if ( tst == 1 ) ax = ZIUgol - UgolToch ;

 //ДДДДДД  Расчет коэффициента согласования. ДДДДДД

    // Для того , чтобы получить корень из входной величины в градусах ,
    // необходимо искусственно сделать квадрат единицы градуса , т.к.
    // корень из квадрата единицы градуса - это градус :
    lax = (slw)(sw)ax * (slw)(sw)_Grad( 1.00 ) ;

 //ДДДДДД  Регулятор Ошибки Положения :) ДДДДДД

                  // защита от "-" коэфф.
    cx = _r.Kp_dP & 0x7fff ; // Коэффициент для ошибки .

    //-----------------18.06.07 08:55-------------------
    //---------- preventive overflow control -----------
    lbx = lax ;                      // ошибка .
    if ( (slw)lbx < 0 ) lbx = -lbx ; // выпрямленная ошибка .
    // Если lbx = 0 , то процессор _CM3_ при делении на нуль получает нуль , входит в условие
    // и выдаёт максимальный выход , что есть неправильно . Поэтому проверяем , что lbx != 0 :
    if ( ((lw)cx >= (lw)0x7fffffff / lbx) && (lbx != 0) )    // sravnivaem modul koefficienta
     {                                       // s maksimalno dopustimoy oshibkoy
       if ( (slw)lax >= 0 ) lax = 0x7fffffff ; // pri vychislennom 'Kp',
       else                 lax = 0x80000000 ; // dlya 32-bit setki oshibkoy.
     }
    else  lax = (slw)lax * (slw)(sw)cx ;
    //asm   mul  lax , ax ;   // умножение пропорц. коэффициента на ошибку
    //--------------------------------------------------

    lax = (slw)lax >> 8 ; // компенсируем коэффициент , умноженный на 256 .

    //--------------------------------------------------

 //ДДДДДДДДДДДД Расчет корня.  ДДДДДДДДДДДДДД

 if ( (slw)lax < 0 ) lbx = ~lax + 1 ;  // Выделяем модуль ошибки для квадратного корня .
 else                lbx =  lax ;
 //---
 lbx = Sqr( lbx ) ;   // Рассчет корня .
 cx = (w)(lbx >> 8) ; // В младшем байте дробная часть - она не нужна .
 //---
 if ( (slw)lax < 0 ) RP_in_sqr = ~cx + 1 ;  // Возвращаем корню знак .
 else                RP_in_sqr =  cx ;
 //----
 ax = RP_in_sqr ; // В "ax" возвращаем ошибку ( теперь с учетом корня и Кп ошибки ) .

//-------------------------------------------

 //ДДДДДДДДДДДДДДД Мертвая зона ДДДДДДДДДДДДДДДДДД

     /* Проверка нахождения в мертвой зоне , "tst" рассчитывается выше , до определения Kп ошибки . */
    /*if ( tst == 0 )*/ lax = _r.Ki_RP ; // Коэффициент для больших отклонений .
    /*else*/ //lax = _r.Ki_RP_DZ ; // Коэффициент для малых отклонений в Мертвой Зоне .


 //ДДДДДДДДДДД Расчет интегратора.  ДДДДДДДДДДДДДД

//   Проверка ограничений на возрастание или снижение интегратора.
    if ( (sw)ax >= 0 )
      {
        if ( RegFlg._.rp_int_p == 1 )  goto v4 ;
      }
    else
      {
        if ( RegFlg._.rp_int_m == 1 )  goto v4 ;
      }

    //--------------------------------------------------

    if ( lax == 0 )
     {             // инициализация интегратора при Ки = 0 :
       Integr_RP = 0 ;
       Integr_RP_drob = 0 ;
       goto v4 ;
     }

    //-----------------18.06.07 08:55-------------------

    lax = (lw)( ((d)_Skor_nom(0.01) * _RS_T * 65535.) / (d)_Grad(1.00) ) / lax ;
    lax &= 0x7ffffffful ;  //защита от "-" коэфф.

    //--------------------------------------------------

    //-----------------18.06.07 08:55-------------------
    //---------- preventive overflow control -----------
    cx = ax ;                     // ошибка .
    if ( (sw)cx < 0 )  cx = -cx ; // выпрямленная ошибка .
    // Если lax = 0 , то процессор _CM3_ при делении на нуль получает нуль , входит в условие
    // и выдаёт максимальный выход , что есть неправильно . Поэтому проверяем , что lax != 0 :
    if ( ((lw)cx >= (lw)0x7fffffff / lax) && (lax != 0) )    // sravnivaem modul oshibki
     {                                       // s maksimalno dopustimoy
       if ( (sw)ax >= 0 ) lax = 0x7fffffff ; // pri vychislennom 'Ki',
       else               lax = 0x80000000 ; // dlya 32-bit setki oshibkoy.
     }
    else  lax = (slw)lax * (slw)(sw)ax ;
    //asm   mul  lax , ax ;   // умножение интегр. коэффициента на ошибку
    //--------------------------------------------------

    //-----------------18.06.07 08:55-------------------
       //  Подготовка к контролю переполнения (без использ.'asm'):
       // если до сложения/вычитания операнды были одного знака, а результат
       // получился другого знака - значит произошло переполнение.
     cx = 2 ;
     if ( (slw)lax >= 0 ) // запоминаем сочетание знаков операндов.
      {
          if( (sw)Integr_RP >= 0 ) cx = 0 ; // +/+
      }
     else if( (sw)Integr_RP <  0 ) cx = 1 ; // -/-

     lax += (slw)(sw)Integr_RP << 16 ;
     lax += (lw)(w)Integr_RP_drob ;   // DROB ISN'T SIGNED !

              /* Проверка переполнений. */
                  //  переполнение в плюс?
          if     ( cx == 0 && (slw)lax <  0 ) goto v1 ;
                  //  переполнение в минус?
          else if( cx == 1 && (slw)lax >= 0 ) goto v2 ;
    //--------------------------------------------------

              /* Проверка ограничений. */
          if ( (slw)lax < (slw)0xf0000000 )
            {
    v2:       lax = 0xf0000000 ;  // -4096 дискрет * 65536 , это 128% .
            }  // не подпускаем к краю сетки, чтобы можно было контролир.переполн.
          else if ( (slw)lax >= (slw)0x10000000 )
            {
    v1:       lax = 0x10000000 ;  // +4096 дискрет * 65536 , это 128% .
            }

    Integr_RP = (slw)lax >> 16 ; // дробная часть уходит, целая записывается .
    Integr_RP_drob = lax ;       // запись дробной части .

    v4:  RegFlg._.rp_int_p = 0 , RegFlg._.rp_int_m = 0 ;

    //ДДДДДД  Расчет пропорциональной составляющей и выхода регулятора. ДДДДДД

 //ДДДДДДДДДДДДДДД Мертвая зона ДДДДДДДДДДДДДДДДДД

     /* Проверка нахождения в мертвой зоне , "tst" рассчитывается выше , до определения Kп ошибки . */
    /*if ( tst == 0 )*/ lax = _r.Kp_RP ; // Коэффициент для больших отклонений .
    /*else*/ //lax = _r.Kp_RP_DZ ; // Коэффициент для малых отклонений в Мертвой Зоне .

    //--------------------------------------------------
    //-----------------18.06.07 08:55-------------------
                                    // "<< 8"-догоняем "Kp*256" до формата
    lax = (lax * _Skor_nom(0.01)) / _Grad(1.00) << 8 ;// коэфф."Ki=x*65536".
    lax &= 0x7ffffffful ;  //защита от "-" коэфф.

    //--------------------------------------------------

    //-----------------18.06.07 08:55-------------------
    //---------- preventive overflow control -----------
    cx = ax ;                     // ошибка .
    if ( (sw)cx < 0 )  cx = -cx ; // выпрямленная ошибка .
    // Если lax = 0 , то процессор _CM3_ при делении на нуль получает нуль , входит в условие
    // и выдаёт максимальный выход , что есть неправильно . Поэтому проверяем , что lax != 0 :
    if ( ((lw)cx >= (lw)0x7fffffff / lax) && (lax != 0) )    // sravnivaem modul oshibki
     {                                       // s maksimalno dopustimoy
       if ( (sw)ax >= 0 ) lax = 0x7fffffff ; // pri vychislennom 'Kp',
       else               lax = 0x80000000 ; // dlya 32-bit setki oshibkoy.
     }
    else  lax = (slw)lax * (slw)(sw)ax ;
    //asm   mul  lax , ax ;   // умножение интегр. коэффициента на ошибку
    //--------------------------------------------------

    //-----------------18.06.07 08:55-------------------
       //  Подготовка к контролю переполнения (без использ.'asm'):
       // если до сложения/вычитания операнды были одного знака, а результат
       // получился другого знака - значит произошло переполнение.
     cx = 2 ;
     if ( (slw)lax >= 0 ) // запоминаем сочетание знаков операндов.
      {
          if( (sw)Integr_RP >= 0 ) cx = 0 ; // +/+
      }
     else if( (sw)Integr_RP <  0 ) cx = 1 ; // -/-

     lax += (slw)(sw)Integr_RP << 16 ; // дробная часть уходит, целая записывается .
     lax += (lw)(w)Integr_RP_drob ;    // DROB ISN'T SIGNED !

              /* Проверка переполнений. */
                  //  переполнение в плюс?
          if     ( cx == 0 && (slw)lax <  0 ) goto p1 ;
                  //  переполнение в минус?
          else if( cx == 1 && (slw)lax >= 0 ) goto p2 ;
    //--------------------------------------------------

              /* Проверка ограничений. */
          if ( (slw)lax < (slw)0xf0000000 )
            {
    p2:       OuRP = 0xf000 , RegFlg._.rp_int_m = 1 ; // -4096 дискрет , это 128% .
            }  // не подпускаем к краю сетки, чтобы можно было контролир.переполн.
          else if ( (slw)lax >= (slw)0x10000000 )
            {
    p1:       OuRP = 0x1000 , RegFlg._.rp_int_p = 1 ; // +4096 дискрет , это 128% .
            }
          else OuRP = (slw)lax >> 16 ;

    end:
#ifdef  _RP_ZIS
          Z_Skor = OuRP ; // Задание на РС .
#endif

  return  ;
 }

//-----------------------------------

// Программа Расчета Угла Положения :
 void  Ugol_Pol ( void )
 {
   #ifdef    _RP_OS_S0_      // Обратная связь для РП по Сельсину 0
     Ugol = Sels[0].out_g ;
   #endif

   #ifdef    _RP_OS_S1_      // Обратная связь для РП по Сельсину 1
     Ugol = Sels[1].out_g ;
   #endif

   #ifdef    _RP_OS_PDF_     // Обратная связь для РП по ПДФ
     // Потом продумать .
   #endif

  return  ;
 }

#endif

//-----------------------------------
