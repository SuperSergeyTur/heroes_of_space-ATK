
//   добавить в формировании задания тока в RegEDS одношаговую запись задания.
// ! добавить проверку битов ограничения задания и интеграторов.
//   совместить измерения Iv сканером и в прерываниях.
//   угол управления, интегратор в след и в CAN.
//   добавить частотное заполнение ИУ
//   уставки и сообщ. в msg.h
//   добавить в vectors.c
//   добавить F2-СИФУВ
// ! таблица импульсов
//   сброс флагов по дист.сбросу.
// ! фазировка

//     За векторами прерываний функции закрепряются в "vectors.c".

//ДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДД

      //   Переключение длины и скважности ИУ.
      //
word Short_V_ImpLong ( void )
{ // 25.02.2008 19:17 - добавлен контроль реверса из СИФУ , чтобы не переключать
  // ошибочно на длинные ИУ при реверсе :
  if( V.Iv >= _r.Iv_null )
  {
      //   При наличии тока ИУ задаются короткими с низкой скважностью.
    if ( V_ImpLong != _ShortImp_Long )
    {
      V_ImpLong = _ShortImp_Long ;
      mSet_Fzapoln4( _V_FzapolnShort_Low, _V_FzapolnShort_High ) ;
      return 1 ; // возвращаем "1", однократно по переключению на короткие ИУ .
  } }
  else
  {
      //   При отсутсвии тока ИУ задаются длинными с большой скважностью.
    if ( V_ImpLong != _Grad(120)  )
    {
      V_ImpLong = _Grad(120) ;
      mSet_Fzapoln4( _FzapolnLong_Low, _FzapolnLong_High ) ;
  } }

  return 0;
}
//ДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДД
//
//                Принцип построения СИФУ:
// - СИФУ формирует ИУ с подтверждающими;
// - длина ИУ задается через "#define" либо уставкой либо внешней переменной.
// При задании длины в диапазоне "3грд...(Lизм-2грд)" формируются короткие ИУ.
// При задании длины более "Lизм-2грд" длительность дискретно переключается
// на 120грд (в статике). При коротких ИУ СИФУ специально формирует задний
// фронт ИУ. При длинных ИУ задний фронт специально не формируется, а
// получается сам по себе: i+2й тиристор записывая свой код в регистр ИУ
// затирает ИУ i-того тиристора.
//-----------------------------------

// Программа старта СИФУ.

word  Vozb_Start ( void )
{
    mPort_ImpV( SetImpCode( 0 ) ) ;
         // частотное заполнение использует Po0_c._.n4, и в
    if (_r.Cfg2._.FzapolnV) mInit_Fzapoln4() ;
    mFzapoln4_start() ;

  //   Расчет времени выдачи первого импульса .
    //V.flg._.RT = 1 ;
    V.Alfa = _r.V_Alfa_Max ;
    V.Alfa_Old = V.Alfa ;
    v_cx = V.Alfa;

    V.N = _r.V_FazirovVS ;
    Syn.b_SIi = 0 ;
    V.TZ = Syn.NS2  ;
    V.TZ += (w)( (lw)( _r.V_FazirovUgol + v_cx ) * (lw)Tsyn >> 15 )  ;

    V.NumInt = 1 ;
    V.NIP = SetImpCode( 0 ) ;
    V_ImpLong = _ShortImp_Long ;// начальное короткое значение длины ИУ.

    V.Iv_off = 0 ;
    //-------------
          //   Настройка EPA.
    init_sifu_epa( _sifuv_epa_con ) ;

    V.TZ_real = V.TZ;
    _sifuv_epa_time( V.TZ ) ; // зарядка начала импульса
   //---------
                // расчет точки измерения Iv и заднего фронта ИУ.
    //V.TZ2 = V.TZ + _r_V_Alfa_Izm ;

    return 0 ;
}

 //-----------------------------------------

//         ПРОГРАММА УПРАВЛЕНИЯ СИФУ ВОЗБУДИТЕЛЯ.
//------------------------------------------------------------

// Программа-прерывание управления возбудителем.

void Vozb_Interrupt ( void )
  {
    static byte Ivmax ;
    pV( 1 ) ;

beg_imp:
       // Объектное (под процессор) дополнение для прерываний:
    Sifu_int_drv(_sifuv_epa_con) ;  // сброс запроса прерывания.
//---------------------

  switch( V.NumInt )
  {
  case 1 :

      mFzapoln4_stop() ;
      if ( V.flg._.Otkl_Imp == 0 ) mFzapoln4_start() ;  //синхронизация суммы
  asm_di();
      mPort_ImpV( V.NIP ) ;  V.TZ_real = timer1;
  asm_ei();
      //--- расчет точки измерения Iv и заднего фронта ИУ.
      v_ax = V.TZ_real + _ShortImp_Long;//_r_V_Alfa_Izm;
      //_sifuv_epa_time( V.TZ + _r_V_Alfa_Izm ) ;

      V.NumInt = 2 ;

      //---   Проверка на опоздание ИУ. Если опоздал, то переход тут же к началу ИУ.
  asm_di() ;
    v_cx = v_ax - timer1 ;
    if ( (u)v_cx < (w)Tsyn*2  &&  v_cx >= _MkSec( 50 ) )
    {
                 // перезарядка ЕПА
      _sifuv_epa_time( v_ax ) ; // зарядка начала импульса

  asm_ei() ;
    }
    else
    {
  asm_ei() ;

      do  v_cx = v_ax - timer1 ;
      while ( (u)v_cx < (w)Tsyn*2  );

      goto end_imp ;
    }

    break;
     //-------------

  case 2 :
end_imp: ;
      //   Задний фронт формируем только при коротких ИУ.
      //  При длинных ИУ задний фронт сформируется через два тир-ра, т.е.
      // в статике длина ИУ составляет 120грд.
      if ( V_ImpLong != _Grad( 120 ) )
      {
yyy:    mFzapoln4_stop() ;
        mPort_ImpV( SetImpCode( 0 ) ) ;
      }
      // Стоит специально после срезания ИУ, чтобы укоротить текущий длинный ИУ
      if ( Short_V_ImpLong() == 1 ) goto yyy ; // и начать следующий ИУ уже с новым PPG.
      // 25.02.2008 19:17 - При таком алгоритме переключения длины и скважности ИУ :
      // 1. При переходе с длинных на короткие : первый короткий ИУ будет с заполнением 10х70 ,
      //    а следующие уже с родной скважностью 10х10.
      // 2. При переходе с коротких на длинные : закончится последний начатый короткий ,
      //    произойдет перерасчет длины и скважности на длинные с возвратом "0" , затем
      //    первый длинный ИУ будет с родным заполнением 10х70 .

      //---
      V.NumInt = 3 ;

      asm_di() ;
          // ИУв сформирован с приоритетом выше СИФУя чтобы, не дрожали
      _set_sifuv_priority(_SIFUV_PRIORITY_low ); // его фронты,
          // а измер. и РТВ можно выполнить уже как получится, чтобы не
          // задерживать СИФУя => ставим приоритет СИФУв ниже, чем СИФУя.

      v_ax = _r_V_Alfa_Izm - _ShortImp_Long;
      if ( (sw)v_ax < (sw)_MkSec(15)) v_ax = _MkSec(15) ;

          // зарядка точки измерения Iv.
          // отступаем не от TZ, а от таймера, чтобы не сбиться при накладке с СИФУя.
      //_sifuv_epa_time( timer1+_MkSec(5) ) ; // переносим регуляторы в тут-же
      _sifuv_epa_time( timer1+v_ax );//_MkSec(15) ) ;
          // следующее прерывание, чтобы выйти из СИФУя, если мы его перебили.

      asm_ei() ;

    break;
     //-------------
  case 3 :
           //  разрешить  прерывания для АЦП.
      asm_ei() ;

    V.NumInt = 1 ;

            /*    Измерение  тока  возбудителя  .*/
                          //   Это нельзя ставить после запуска измерений, т.к. тут же после
    V.Iv_full =  _AD_BUSY ; // запуска программа может сразу же вскочить в другое прерывание -
                        // за его время АЦП досчитает, запишет в "Id", а мы его сбросим и
                       // будем долго ждать у моря погоды.
    mAD_Izm (  Iv_ach  , &V.Iv_full ) ;

        //  Ожидание готовности измерения тока возбуждения Id.
    while ( V.Iv_full  == _AD_BUSY ) ;

    mIzmData_Conversion ( V.Iv_full , v_ax , Iv_ach  ) ;
    if ( (sw)v_ax < 0 ) v_ax = ~v_ax + 1 ;
      //   Масштабирование.
    v_ax = (slw)(sw)v_ax * (slw)(sw)Mashtab.Iv / 256 ;
  //v_ax = (slw)(sw)v_ax * (slw)(sw)_r.Mashtab_Iv / 256 ;

  #ifdef  _SIFUV_1Faza
    //Для однофазной схемы возбуждения РТ вызывается после 1 и 4 тиристоров
    //т.к измерения тока делаются после импульса
    if ( _SIFUV_1Faza == 1 )
    {
      V.Iv_off += v_ax ; // nakaplivaem Id
             // для рабочего ИУ и пропущенного ИУ: для линейности,
             // т.к. между ИУ Id = "0", а сами пики большие.
      if ( (V.N != 1 ) && (V.N != 4) ) goto sifu_v ;
           //  Для полууправляемого моста с датчиком тока на трансф.тока
           // на переменной стороне не делаем усреднения, т.к. в обратной
           // связи идут полочки, а не сплошной ток, из-за того, что
           // ток замыкается через диоды моста когда напряжение синусоиды
           // переходит в минус.
        #ifndef  _SIFUV_1Faza_PoluUpr_TT
      v_ax = (sw)V.Iv_off/3 ; // берем среднее Id
        #endif
      V.Iv_off = 0 ;
    }
  #endif
     //   При нулевой схеме моста на мост подаются нечетные ИУ (1,3,5),
     //   и измерения тока производим для нечетных ИУ.
  #ifdef _NullSchemeMostV
    if ( _NullSchemeMost == 1 )
    {
      V.Iv_off += v_ax ;
      if( ( V.N & 0x01 ) == 0 )  goto sifu_v ;
      v_ax = (sw)V.Iv_off/2, V.Iv_off = 0 ; // берем среднее Id
    }
  #endif

    V.Iv = v_ax ;

        /*     Проверка тока на максимальное значение.
         *  Контроль "Iv_Max" внесен непосредственно в после измерения с
         * целью оперативности сдвига импульсов - реагирует на превышение
         * "дважды подряд" .
         */
  //if ( V.flg._.Iv_max <= 1 )
  //{
      if ( V.Iv >= _r.Iv_avar_Max )
      {
        // 07.04.2008 15:42 - добавлена выдержка времени на аварию Iv-max для фильтрации помех .
        if ( ((b)(Puls_counter - time_Iv_max) > _r.time_Iv_max) || Ivmax == 1 ) // проверка длительности превышения.
        {
          Ivmax = 1 ; // когда счетчик Puls_counter обнулится , останется взведенным флаг ...
          if ( V.flg._.Iv_max == 1 )// превышение было дважды:
          {                        // sdvig impulsov ne pomog.
          //  mSet_AvarMsg ( _Av_Iv_Max ) ;
          //  V.flg._.Sdvig_imp = 1 ;// snimaem IU srazu, t.k. pri nastoyashem k.z.
            //---------------------------------------------------------------------------------------
            // DAN 08.11.2016 - В соответствии с гениальным техническим решением Соломахи и Шестакова ,
            // при "Id-max" НЕ СНИМАЕМ ИУ в течении 2 сек и пытаемся сеточной защитой погасить ток ...
            //V.flg._.Otkl_Imp = _V_Av_otkl_imp ; // v 1-Fazn sheme pri Lmax=150grd
            //---------------------------------------------------------------------------------------
            //----                           // budet 2sec neslabiy tok.
          //  V.flg._.Iv_max = 2 ; // отсчет выдержки на снятие ИУ.
          }
          else
          {
            V.flg._.Iv_max = 1 ; // превышение было одиночное.
            //---
            mSet_AvarMsg ( _Av_Iv_Max ) ;
            V.flg._.Sdvig_imp = 1 ;
          }
      } }
      else  time_Iv_max = Puls_counter , Ivmax = 0 ;
      //else  V.flg._.Iv_max = 0 ; // превышение было одиночное.
  //}
       //   Dlya snyatiya IU i po Iv_max i pri Lmax po Iv_gashenie.
       // Dobavili Iv_null, t.k. v poluupravl. sheme c TT v datchike toka
       // pri perehode na stoyanochn.tok pri Lmax+snyatie IU, esli tok ne uspel
       // doyti do stoyanochnogo, ischezaet tok cherez TT i RTV daet Lmin
       // i idet nebolshoy podbros toka. no pri 150grd tok ne padal nige 37%
       // IU ne snimalisya...
    if ( V.Alfa_Old == _r.V_Alfa_Max )// &&  V.Iv <= _r.Iv_null )
    {
      if ((b)(Timer1_Ovr - V.time_Iv_max) > _r.V_Time_do_OtklImp)  //_Sec( 5.0 ))
         {
            // DAN 08.11.2016 - В соответствии с гениальным техническим решением Соломахи и Шестакова ,
            // при "Id-max" НЕ СНИМАЕМ ИУ в течении 2 сек и пытаемся сеточной защитой погасить ток ...
            if ( V.flg._.Iv_max == 1 ) V.flg._.Otkl_Imp = _V_Av_otkl_imp ;
            else                       V.flg._.Otkl_Imp |= _V_VR1_otkl_imp ;
         }
    }
    else {  V.flg._.Otkl_Imp &= ~_V_VR1_otkl_imp, V.time_Iv_max = Timer1_Ovr ; }

#ifdef _RNV // Регулятор напряжения возбуждения вместо РТВ :
    // здесь измеряем напряжение возбуждения
    Uf_ax =  _AD_BUSY ;
    mAD_Izm (  Uf_ach  , &Uf_ax ) ;
    while ( Uf_ax  == _AD_BUSY ) ;
    mIzmData_Conversion ( Uf_ax , v_ax , Uf_ach  ) ;
    if ( (sw)v_ax < 0 ) v_ax = ~v_ax + 1 ;
    //Uf_full = (slw)(sw)v_ax * (slw)(sw)_or.Mashtab_Uf / 256 ;
    Uf_full = (sw)( (slw)(sw)v_ax * (slw)(sw)_or.Mashtab_Uf >> 8 ) ;
#endif

      // Вызов объектного задания на ток возбуждения , которое перебивает все предыдущее.
    // 29.02.2016 - Перенесено в СИФУВ , чтобы выполнялось при отключенном регуляторе ...
    obj_ConfigReg ( _Obj_Iv_Zad ) ;

          //   Регулятор Tока Возбуждения
    if (/*V.flg._.RT == 1*/ Isp._.SIFUV_Res == 0 && Ckl._.SIFUV == 0 && V.flg._.fazir == 0) RTV () ;
  //------------
goto sifu_v ; // заглушка для 3-х фазной схемы возбудителя .
sifu_v:  // для нулевой схемы.

        //   СИФУ.
       // Расчет и запуск переднего фронта следующего ИУ.
  //---------------------------------
      V.N++;
      if ( V.N == 07 )  V.N = 1;

  //---------------------------------
        //   СИФУ  Возбудителя .

    V.flg._.Fmax = 0 , V.flg._.Fmin = 0 , V.flg._.Fdmax = 0 , V.flg._.Fdmin = 0 ;

    if ( V.flg._.Sdvig_imp == 1 ) goto sdv ; // сдвиг импульсов в Альфа_Макс.
    else                       v_cx = V.Alfa ;

      //   Наступление ограничений по ЗИ и ограничителю угла друг друга
      // взаимоисключают;  по-этому поводу будет ссылка ниже ...
      //  Ограничитель угла.
    if ( v_cx >= _r.V_Alfa_Max )
      {
   sdv: v_cx = _r.V_Alfa_Max ;
        V.flg._.Fmax = 1;
      }
    else if ( v_cx <= _r.V_Alfa_Min )  // '<='-chtoby flag ogranicheniya,
           {                          // vystavlyalsya i pri Lmin=0
             v_cx = _r.V_Alfa_Min ;
             V.flg._.Fmin = 1 ;
           }

      // Задатчик Интенсивности .
    if ( v_cx < V.Alfa_Old )
      {
        v_ax = V.Alfa_Old - v_cx ;
        if ( v_ax > _r_V_DeltaAlfa_Max )
          {
            v_ax = _r_V_DeltaAlfa_Max ;    // если после ограничителя угол сел на ЗИ,
            v_cx = V.Alfa_Old - v_ax ; // то, следовательно, ограничение по AlfaMin если
            V.flg._.Fdmin = 1 ;                // и было то отпало само собой и по-этому здесь
            V.flg._.Fmin = 0;                  // <- признак ограничения Fmin сбрасывается.
          }
        V.TZ -= (w)( (lw)v_ax * (lw)Tsyn >> 15 )  ;
      }
    else
      {
        v_ax = v_cx - V.Alfa_Old ;
            // из-за перекрытия ИУ нельзя обходить ЗИ
        if ( V.flg._.Sdvig_imp == 1 ) goto s2 ; // Обход ЗИ при сдвиге импульсов в Альфа_Макс.
        if ( v_ax > _r_V_DeltaAlfa_Max )
          {
            v_ax = _r_V_DeltaAlfa_Max ;    // если после ограничителя угол сел на ЗИ,
            v_cx = V.Alfa_Old + v_ax ; // то, следовательно, ограничение по AlfaMax если
            V.flg._.Fdmax = 1 ;                // и было то отпало само собой и по-этому здесь
            V.flg._.Fmax = 0;                  // <- признак ограничения Fmax сбрасывается.
          }
  s2:   V.TZ += (w)( (lw)v_ax * (lw)Tsyn >> 15 )  ;
      }

    V.Alfa_Old = v_cx ;   // раньше это делать нельзя.

    V.TZ += Tsyn/6 ;

    if ( Syn.b_SIi == 1 )
      {
        Syn.b_SIi = 0 ;
        v_ax = V.TZ ;
        V.TZ = Syn.NS2  ;
        if ( V.N >= _r.V_FazirovVS) V.TZ += Tsyn/6 * (w)( V.N - _r.V_FazirovVS) ;
        else                        V.TZ += Tsyn/6 * (w)( 6u + V.N - _r.V_FazirovVS)  ;
        V.TZ += (w)( (lw)( _r.V_FazirovUgol + v_cx ) * (lw)Tsyn >> 15 )  ;

        if (( (u)((w)(V.TZ - v_ax)) >= (w)Tsyn/8 ) && ( (u)((w)(v_ax - V.TZ)) >= (w)Tsyn/8 ))
          {
                            /*  Нижеследующая Последовательность проверки обязательна:
                             * сначала "-Tsyn", потом "+Tsyn" - т.е. проверка завершается
                             * прибавлением периода. Это на тот случай если отклонение "TZ"
                             * вызвано не ошибкой перепривязки на "Tsyn", а тем что уплыли
                             * импульсы из-за временного отсутствия синхронизации и прибавив
                             * лишний период в направлении роста таймера мы в худшем случае
                             * просидим период без импульсов, но не собьемся со шкалы таймера
                             * и через период снова подадутся импульсы.
                             */
            V.TZ   -= Tsyn ;   // когда мы при большом 'cx' залезли старой шестеркой за новый СИ
            if (( (u)((w)(V.TZ - v_ax)) >= (w)Tsyn/8 ) && ( (u)((w)(v_ax - V.TZ)) >= (w)Tsyn/8 ))  // когда мы при маленьком 'cx'
                      V.TZ += 2*Tsyn ;   //  и задержке обработки очередного СИ получили его после начала новой шестерки
      }   }

    if ( V.flg._.Otkl_Imp != 0 )  V.NIP = SetImpCode( 0 ) ;
    else                          V.NIP = SetImpCode( V.N )  ;
       //-------------
    //_sifuv_epa_time( V.TZ ) ; // зарядка начала импульса
     //-------------

                // расчет точки измерения Iv и заднего фронта ИУ.
    //V.TZ2 = V.TZ + _r_V_Alfa_Izm ;
        // для того чтобы сформировать передний и задний фронт ИУв ставим его
       // приоритет выше чем СИФУя, а после заднего фронта сделаем ниже.
    //_set_sifuv_priority(_SIFUV_PRIORITY_high );

    //  КВВ 10-11-16 - добавил защиту от опоздания - при реверсе якоря пропадали ИУ возбудителя на 65-85мсек
  asm_di() ;
        // для того чтобы сформировать передний и задний фронт ИУв ставим его
       // приоритет выше чем СИФУя, а после заднего фронта сделаем ниже.
    _set_sifuv_priority(_SIFUV_PRIORITY_high );
      //---
    v_ax = V.TZ - timer1 ;
    if ( (u)v_ax < (w)Tsyn*2  &&  v_ax >= _MkSec( 50 ) )
    {
      _sifuv_epa_time ( V.TZ );
      asm_ei() ;
    }
    else
    {
      asm_ei() ;
      do  v_ax = V.TZ - timer1 ;
      while ( (u)v_ax < (w)Tsyn*2  );
      goto beg_imp ;
    }

    break;
  }

    pV( 0 ) ;

    return;
}

