/* Диаграмма работы фильтра дребезга и помех.

    є исходный сигнал
    є   ЪДДДї    ЪДДДДДДДї ЪДДДДДДДДДДДДДДДДДДДї   ЪДДДДДї     ЪДДї
    є   і   і    і       і і                   і   і     і     і  і
    є   і   і    і       і і                   і   і     і     і  і
  ННОНННПНННПННННПНННННННПНПНННННННННННННННННННПНННПНННННПНННННПННПННННННННННН>
                                                                          t,o.e.

    є Д<Дранее был зафиксирован "0"                      зафиксирован "0"Д>Дґ
    є                                ГД<Дзафиксирована "1"
 по-* Д  Д  Д  Д  Д  Д  Д  Д  Д  Д   ЪДДДДДДДДДї   ЪДДДДДї     ЪДДї         і
рог є интегратора                  ЪДЩ         АДї і     АДї   і  АДї
    є   фильтра        ЪДї       ЪДЩ             АДЩ       АДї і    АДї     і
    є                ЪДЩ і     ЪДЩ                           АДЩ      АДї
    є     ЪДї      ЪДЩ   і   ЪДЩ                                        АДї
    є   ЪДЩ і    ЪДЩ     і ЪДЩ                                            АДї
  ННОНННПНННПННННПНННННННПНПННННННННННННННННННННННННННННННННННННННННННННННННПН>
                                                                          t,o.e.
    є
    є отфильтрованный сигнал         ЪДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДї
    є                                і                                      і
    є                                і                                      і
  ННОННННННННННННННННННННННННННННННННПННННННННННННННННННННННННННННННННННННННПН>
    є                                                                     t,o.e.
*/
//--------------------------------------------------------

//    Программа централизованной обработки внешних входных дискретных
//  сигналов.
//    Программа осуществляет нормализацию уровней, маскирование и
// антидребезг/фильтрацию сигналов.
//    Точность отслеживания постоянных времени фильтрации сигналов
// прямо пропорциональна частоте отработок данной программы .

void S400_input ( byte cs_n, byte Port, byte code)
{
    register byte  al ;
    register word  ax , bx ;
    register lword  lax ;

    ssio_busy = 1;                      // Признак того, что последовательный порт занят для прерываний.

 #ifndef _BTE_NEW

    //Устанавливаем выборку
    Set_cs_sio (cs_n);
    //Выдержка времени на срабатывание сигнала выборки
    ax = timer1;
    do  bx = timer1 - ax;
    while ((u)bx < _MkSec(2) );
    //Считываем сигнал из SIO
    sio_in(al);

 #else
      //Порт GPIO как вход с подтяжкой на "+"
      // Возможно не имеет смысла. Т.к. при инициализации они изначально входы, а сразу после установки выходов
      // в той же функции эти пины опять переводяться во входы и больше их переопределить некому, НО так спокойней
    SET_GPIO_PiS() ;
      //Устанавливаем выборку
    Set_cs_sio (cs_n);
      //Выдержка времени на срабатывание сигнала выборки
    ax = timer1;
    do  bx = timer1 - ax;
    while ((u)bx < _MkSec(1) );

     //Считываем сигнал из буферной микросхемы
    Pinp_al(al) ;
 #endif

    //Снимаем выборку
    Clr_cs_sio (cs_n);

    ssio_busy = 0;                      // Снимаем признак

        /*   Фиксация полного времени для данного момента.
         * Полное время состоит из показаний рабочего таймера и счетчика
         * его переполнений.
         * Дискрета рабочего таймера = 0.868мксек.
         * Дискрета счетчика переполнений рабочего таймера = 0.569сек.
         *  Алгоритм считывания показаний имеет особенность из-за того,
         * что считывание производится в два приема: считывание таймера и
         * считыание счетчика переполнений - а в интервале между считываниями
         * может иметь место переполнение таймера с переносом в счетчик.
         * Если последнее не учитывать, то будет вероятна ошибка считывания.
         *   Для учета данной особености считывания используется алгоритм
         * рекомендуемый в литературе для применения в 8-разрядных микро-
         * контроллерах для считывания показаний 16-разрядных таймеров.
         *   Алгоритм, применительно к нашему случаю, заключается в следующем:
         * 1. считывание счетчика переполнений => 'ax' ;
         * 2. считывание таймера => 'bx' ;
         * 3. сравнений счетчика переполнений с ранее считанным его значением
         *    хранящимся в 'ax' ;
         * 4. при несовпадении значений, что является признаком переполнения
         *    таймера между считываниями, возврат к пункту 1.
         */
    do { ax = Timer1_Ovr , bx = timer1 ; } while ( ax != Timer1_Ovr ) ;
    ax <<= 8 ;      //  Из четырехбайтного полного значения времени
    ax  += (bx>>8); // для работы берутся средние два байта прини-
                    // мающие значения в диапазоне 0.25мсек-12.0сек.


  switch ( code )
  {    //  Стартовая инициализация.
    case 0 :
        PiS_c[Port].all = al ;
        PiS_cf[Port].all = al ;
        PiS_nm[Port].all = PiS_f[Port].all = al ^ _or.PiS_Normal[Port] ;
        for ( bx = 0 ; bx < 8 ; bx++ )  PS_t[Port][bx] = ax ;

      break;
    //---------------------
    default:
    case 1 :


//   Нормализация, т.е. приведение посредством уставки реальных активных
// уровней сигналов к общепринятому уровню активного сигнала, и маскирование
// заданных уставкой сигналов порта.
     PiS_c[Port].all = al ,  al ^= _or.PiS_Normal[Port] ;

//            Фильтрация дискретных сигналов портов .
//   Фильтрация осуществляется отдельно, как для каждого из портов,
// так и для отдельных сигналов в порту.

    lax = (lw)(w)PiS_f[Port].all << 24 ;
    lax += (lw)(w)PiS_nm[Port].all << 16;
    lax += (lw)(w)al << 8 ;

    for ( bx = 0 ; bx < 8 ; bx++ , lax >>= 1 )
       {
         if((lax & 0x1000000L) != 0)
          {
             if( (lax & 0x10100L) == 0 )
              {
                if ( (u)((w)(ax - PS_t[ Port][bx ])) >= PS_tu[ Port][bx ] )
                  {
                    PS_t[ Port][bx ] = ax ;
                    lax &= 0xfeffffff ;
                  }
                continue ;
              }
             else  PS_t[ Port][bx ] = ax ;
             continue ;
          }
         else
          {
             if( (lax & 0x10100L) == 0x10100L )
              {
                if ( (u)((w)(ax - PS_t[ Port][bx ])) >= PS_tu[ Port][bx ] )
                  {
                    PS_t[ Port][bx ] = ax ;
                    lax |= 0x01000000 ;
                  }
                continue ;
              }
             else PS_t[ Port][bx ] = ax ;
             continue ;
           }
       }
    //   Возвращение обработанных сигналов в память.
      PiS_f[Port].all = (b)(lax >> 16) ;
      PiS_nm[Port].all = (b)lax;

           // Производим обратное инвертирование, чтобы получить
          // отфильтрованное, но ненормированное значение.
      PiS_cf[Port].all = PiS_f[Port].all ^ _or.PiS_Normal[Port] ;

    break;
  }

  return  ;
}

/*ДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДД*/

#ifdef _BTE_NEW

  void BuffIO_out ( byte cs_n,  byte  port_out )
    {
      word  ax , bx ;

        // Установить порт как выход
      SET_GPIO_PoS() ;
        // Задать значение выходного порта
      Pout_al(port_out) ;
        // Выдержка времени на переход портов в заданное состояние
      ax = timer1;
      do  bx = timer1 - ax;
      while ((u)bx < _MkSec(1) );

        // Переложили данные с порта на выход выбрав нужный адрес
      Set_cs_sio (cs_n);

        // Выдержка времени на съем сигнала выборки перед переводом порта во вход
      ax = timer1;
      do  bx = timer1 - ax;
      while ((u)bx < _MkSec(1) );

        // Снимаем выборку тем самым защелкиваем данные до следующего обращения к данному адресу
      Clr_cs_sio (0);
        // Чтоб выборка успела снятся
      __NOP(); __NOP(); __NOP();
        // Порт GPIO как вход с подтяжкой на "+"
      SET_GPIO_PiS() ;

      return ;
    }

#endif

/*ДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДД*/


void S400_output ( byte cs_n, byte Port)
{
  byte  port_out;
  //---
#ifndef _AsPo_INVERT
  port_out = PoS_c[Port].all ;
#else
  port_out = PoS_c[Port].all ^ _or.PoS_Normal[Port] ;
#endif
    ssio_busy = 1;        // Признак того, что последовательный порт занят для прерываний.

#ifndef _BTE_NEW
    //Устанавливаем выборку
    Set_cs_sio (cs_n);
  //sio_out(PoS_c[Port].all); // 08.01.2015 так было до возможности инверсии выхода .
    sio_out(port_out);
    //Снимаем выборку
    Clr_cs_sio (cs_n);
#else
    BuffIO_out ( cs_n, port_out ) ;
#endif

    ssio_busy = 0;        // Снимаем признак

  return  ;
}


