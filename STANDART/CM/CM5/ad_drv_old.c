

//     ПРОГРАММА ЗАПУСКА АЦП НА ИЗМЕРЕНИЕ.
//     Т.к. время преобразования АЦП всего 6мксек то прерывания
//  по готовности АЦП и организация очереди при наложении измерений
//  не предусматриваются.
//--------------------------------------------------------

  //  Программа инициализации АЦП без его прерывания и буферов для прерывания.

void  Start_AD ( void )
{
  lword adc_clk;
  //word ax;

    //OutAdBuffCount = 0 ;
    //InAdBuffCount  = 1 ;
    //Flg.NoAdBuffInfo  = 1 ;



	LPC_SC->PCONP |= CLKPWR_PCONP_PCADC;

	LPC_ADC->CNR = 0;
// Включаем АЦП
    adc_clk =  PeripheralClock/_ADC_CLK-1;
	LPC_ADC->CNR = ( ADC_CR_CLKDIV(adc_clk) ) | ADC_CR_PDN;

	// Начальный канал AN4
	LPC_ADC->CNR |= ADC_CR_CH_SEL(4);

    AD_busy = 0;
}


//----------------------------------------------
//     Т.к. время преобразования АЦП всего 6мксек то прерывания
//  по готовности АЦП и организация очереди при наложении измерений
//  не предусматриваются, НО ИММИТИРУЕТСЯ ВИДИМОСТЬ ЭТОГО ДЛЯ СОВМЕСТИМОСТИ
//  С ПРОГРАММАМИ MCS196.

/*   П/п запуска АЦП на измерение либо, при занятости АЦП, занесения измерения
 * в очередь. При этом используются два буфера:  "AdBuff_AddrResult[]" и
 * "AdBuff_Command[]". В первый из них рабочей программой заносятся адреса
 * ячеек, в которые необходимо помещать результаты измерений АЦП, а во
 * второй - управляющие слова для мультиплексора АЦП, которыми в случае
 * наличия очереди измерений подключается нужный канал мультиплекора и АЦП
 * тут же из прерывания будет запускаться на новое измерение.
 * Вышесказанное относится к случаю когда при необходимости сделать измерение
 * оказывается, что АЦП занят т.е. существует очередь. В случае же когда очередь
 * исчерпана и АЦП свободен, признаком чего является взведенный бит "Flg.NoAdBuffInfo"
 * (см.ниже),  рабочая программа, при необходимости измерения, должна
 * сама по управляющему слову мультиплексора подключить нужный канал и запустить
 * АЦП, а адрес ячейки, в которую необходимо будет положить результат измерения,
 * занести в буфер адресов по индексу "OutAdBuffCount", а не "InAdBuffCount"
 * т.к управляющее слово заносилось прямо в АЦП, а не в очередь.
 *  Считывание данных из буфера очереди подпрограммой прерывания производится
 * посредством указателя "OutAdBuffCount". Организация этого указателя
 * абсолютно идентична вышеописанной.
 *   Перед записью данных в буфер измерений в рабочей программе следует
 * убедиться (чего с целью экономии времени не сделано), что в буфере еще
 * осталось место. Для этого необходимо проверить
 * не сравняется ли указатель записи с указателем считывания если первый
 * увеличить на единицу. Если оказывается, что они в результате этого станут
 * равными - значит в буфере места нет и принятый байт записывать некуда, при
 * этом следует либо подождать пока место появится, либо проигнорировать это
 * обстоятельство.
 */
     /*   Благодаря макросу сокращается 9 команд передачи параметров.
      *
      *   На время операций с буферами во избежание накладок запрещаются
      * прерывания.
      *   В связи с этим установку контрольного бита готовности в ячейке
      * результата надо делать до входа в подпрограмму и НЕЛЬЗЯ после "ei",
      * т.к. тут же после "ei" программа может сразу же вскочить в прерывание
      * за его время АЦП досчитает, запишет в ячейку результат, а мы его
      * сбросим и будем долго ждать у моря погоды.
 * * **
 *
 * struct Channel_AD ach - имя структуры данных для канала АЦП по которому
 *              производится измерение; из этой структуры макрос извлечет
 *              управляющее слово для мультиплексоров данного канала.
 * word* AddrResult - адрес ячейки в которую следует поместить результат
 *                    этого измерения.
 */


//----------------------------------------------
void Set_MUX( word num )
{
  word ax, bx;
  lword lax = 0;
  for (ax = 9, bx = 0; ax >= 6; --ax, ++bx)
  {
    lax |= ((num >> bx)&0x1)<<ax;
  }
  LPC_GPIO0->SET = lax;
  bx = timer1;
  while (( timer1 - bx ) < _MkSec(10)) ;

}

void Clr_MUX()
{
  LPC_GPIO0->CLR = 0x3c0;
}
//----------------------------------------------

static __INLINE void mAD_Izm( struct Channel_AD ach , word* AddrResult )
{
//  LPC_ADC_TypeDef *pADC = (LPC_ADC_TypeDef*) LPC_ADC_BASE;
  slword ax ; //,tx;
  volatile lword lax;



      //AdBuff_AddrResult [(w)OutAdBuffCount] = ( AddrResult );
  // ax = ach.mux&0xff00;
         __disable_interrupt();
          //
       tx = timer1;
       mSet_MUX( ach.mux )  ;
    
        //  ax = ach.mux;
           LPC_ADC->CNR &= ~( 0x000000FF | ADC_CR_START_NOW );
           LPC_ADC->CNR |= ( ADC_CR_CH_SEL((ach.mux&0x0f))| ADC_CR_START_NOW );
           lax = LPC_ADC->GDR;
           ax = timer1;
           while ( (lax&ADC_GDR_DONE_FLAG)== 0)
           {
               if ( (u)((w)(timer1-ax)) >= _MkSec(10))
               {
                   ax = timer1;
                   LPC_ADC->CNR &= ~( 0x000000FF | ADC_CR_START_NOW );
                   LPC_ADC->CNR |= ( ADC_CR_CH_SEL((ach.mux&0x0f))| ADC_CR_START_NOW );
               }
               lax = LPC_ADC->GDR;
           };
          *AddrResult =  ADC_GDR_RESULT(LPC_ADC->DR[(ach.mux&0x0f)]);

         __enable_interrupt();
         
         mClr_MUX()  ;
         
         dtizm = timer1 - tx;
}





/*   Функция для запуска измерения - использует внутри себя аналогичный
 * макрос - из-за чего время ее выполнения больше, чем макроса, но затраты
 * памяти при ее использовании меньше
 *   Ее имеет смысл использовать в программах не требовательных ко времени.
 */
void  AD_Izm( struct Channel_AD ach , word* AddrResult )
{
   mAD_Izm( ach , AddrResult ) ;
    return ;
}

