

//     ПРОГРАММА ЗАПУСКА АЦП НА ИЗМЕРЕНИЕ.
//     Т.к. время преобразования АЦП всего 6мксек то прерывания
//  по готовности АЦП и организация очереди при наложении измерений
//  не предусматриваются.
//--------------------------------------------------------

  //  Программа инициализации АЦП без его прерывания и буферов для прерывания.

void  Start_AD ( void )
{
  lword adc_clk;
#ifdef _ADC_SPI
  word ax;
#endif

    //OutAdBuffCount = 0 ;
    //InAdBuffCount  = 1 ;
    //Flg.NoAdBuffInfo  = 1 ;



	LPC_SC->PCONP |= CLKPWR_PCONP_PCADC;

	LPC_ADC->CNR = 0;
// Включаем АЦП
    adc_clk =  PeripheralClock/_ADC_CLK-1;
	LPC_ADC->CNR = ( ADC_CR_CLKDIV(adc_clk) ) | ADC_CR_PDN;

	// Начальный канал AN0
	LPC_ADC->CNR |= ADC_CR_CH_SEL(0);

 /*   // Инициализация прервания

    LPC_ADC->INTEN = 0x1F7; // Включаем прерывания по всем каналам +глобальное, кроме ADC3
	NVIC_SetPriority(ADC_IRQn, _ADC_IRQ_PRIORITY );
	NVIC_EnableIRQ(ADC_IRQn);
   */

    AD_busy = 0;
#ifdef _ADC_SPI
    _ADC_SPI->DR = 0xffff;

    while ( _ADC_SPI->SR & SSP_SR_BSY  );

    ax = _ADC_SPI->DR;
#endif
    adc_sts.all = 0;
    //Задаем настройки внешнего АЦП
    adc_sts._.write = 1;
    adc_sts._.pm = 3;
    adc_sts._.coding = 1;

}


//----------------------------------------------
//     Т.к. время преобразования АЦП всего 6мксек то прерывания
//  по готовности АЦП и организация очереди при наложении измерений
//  не предусматриваются, НО ИММИТИРУЕТСЯ ВИДИМОСТЬ ЭТОГО ДЛЯ СОВМЕСТИМОСТИ
//  С ПРОГРАММАМИ MCS196.

/*   П/п запуска АЦП на измерение либо, при занятости АЦП, занесения измерения
 * в очередь. При этом используются два буфера:  "AdBuff_AddrResult[]" и
 * "AdBuff_Command[]". В первый из них рабочей программой заносятся адреса
 * ячеек, в которые необходимо помещать результаты измерений АЦП, а во
 * второй - управляющие слова для мультиплексора АЦП, которыми в случае
 * наличия очереди измерений подключается нужный канал мультиплекора и АЦП
 * тут же из прерывания будет запускаться на новое измерение.
 * Вышесказанное относится к случаю когда при необходимости сделать измерение
 * оказывается, что АЦП занят т.е. существует очередь. В случае же когда очередь
 * исчерпана и АЦП свободен, признаком чего является взведенный бит "Flg.NoAdBuffInfo"
 * (см.ниже),  рабочая программа, при необходимости измерения, должна
 * сама по управляющему слову мультиплексора подключить нужный канал и запустить
 * АЦП, а адрес ячейки, в которую необходимо будет положить результат измерения,
 * занести в буфер адресов по индексу "OutAdBuffCount", а не "InAdBuffCount"
 * т.к управляющее слово заносилось прямо в АЦП, а не в очередь.
 *  Считывание данных из буфера очереди подпрограммой прерывания производится
 * посредством указателя "OutAdBuffCount". Организация этого указателя
 * абсолютно идентична вышеописанной.
 *   Перед записью данных в буфер измерений в рабочей программе следует
 * убедиться (чего с целью экономии времени не сделано), что в буфере еще
 * осталось место. Для этого необходимо проверить
 * не сравняется ли указатель записи с указателем считывания если первый
 * увеличить на единицу. Если оказывается, что они в результате этого станут
 * равными - значит в буфере места нет и принятый байт записывать некуда, при
 * этом следует либо подождать пока место появится, либо проигнорировать это
 * обстоятельство.
 */
     /*   Благодаря макросу сокращается 9 команд передачи параметров.
      *
      *   На время операций с буферами во избежание накладок запрещаются
      * прерывания.
      *   В связи с этим установку контрольного бита готовности в ячейке
      * результата надо делать до входа в подпрограмму и НЕЛЬЗЯ после "ei",
      * т.к. тут же после "ei" программа может сразу же вскочить в прерывание
      * за его время АЦП досчитает, запишет в ячейку результат, а мы его
      * сбросим и будем долго ждать у моря погоды.
 * * **
 *
 * struct Channel_AD ach - имя структуры данных для канала АЦП по которому
 *              производится измерение; из этой структуры макрос извлечет
 *              управляющее слово для мультиплексоров данного канала.
 * word* AddrResult - адрес ячейки в которую следует поместить результат
 *                    этого измерения.
 */


//----------------------------------------------
//DAN 11.09.2017 11:30 - На канале , на котором подключен внешний мультиплексор должна стоять фильтрующая ёмкость 470pF,
//                       вместо стандартной 10nF . При маленькой ёмкости 470pF мультиплексированные каналы почти не влияют
//                       друг на друга ( как происходило бы  при стандартной 10nF ) , но при нулевом сигнале микросхема АЦП
//                       выдаёт шум ~140мВ . Это погрешность измерений при такой маленькой фильтрующей ёмкости , и с этой
//                       погрешностью остаётся только смириться ...
// Для установки пинов внешнего мультиплексора.
#ifdef _Adc_Extend // Внешний мультиплексор АЦП .
void Set_MUX( word num )
{
  word cx , bx ;
  //---
  // Внимание! Нулевой канал нулевой платы мультиплексора не определится как мультиплексированный , но , т.к. это
  // начальное состояние мультиплексора после окончания любого измерения , выдержка времени на нём и не нужна ...
  if ( num != 0xf ) // Выполняется только при опросе мультиплексированного канала :
  {
 #ifndef _Adc_Extend_Inv
      Mux_Port->CLR = Mux_Pins((~num)&0x0f);
    //Mux_Port->CLR = Mux_Pins(0x3f);
      Mux_Port->SET = Mux_Pins((num)&0x30);
 #else // Инвертирование выборки для внешнего мультиплексора (например, если управление от Po0) :
      Mux_Port->SET = Mux_Pins((~num)&0x0f);
  //  Mux_Port->SET = Mux_Pins(0x3f);
      Mux_Port->CLR = Mux_Pins((num)&0x30);
 #endif

#ifdef _SecondPlatBit
    if ((num &0x10) == 0)
    {
     _SecondPlatPort->CLR =  _SecondPlatBit;
//если выборка на дискретном выходе, то обнуляем бит в выходном порту, чтобы не мешался в выборку
#ifdef bo_SC_ADC
     bo_SC_ADC = 0;
#endif
    }
    else
    {
     _SecondPlatPort->SET =  _SecondPlatBit;

//если выборка на дискретном выходе, то устанавливаем бит в выходном порту, чтобы не мешался в выборку
#ifdef bo_SC_ADC
     bo_SC_ADC = 1;
#endif
    }
#endif

    //Выдержка времени на срабатывание сигнала выборки и на зарядку/разрядку ёмкости 470pF :
    cx = timer1;

    do  bx = timer1 - cx ;
    while ((u)bx < MUX_delay[(num>>4)][num&0x0f]);

   // asm_ei();
  }
}

void Clr_MUX( word num )
{
  //Ввел проверку на номер канала чтобы при влезании прерывания
  //Не обнуляло выборку
  if ( num != 0xf )
  {
 #ifndef _Adc_Extend_Inv
  Mux_Port->SET = Mux_Pins(0x0f);
  Mux_Port->CLR = Mux_Pins(0x30);
 #else // Инвертирование выборки для внешнего мультиплексора (например, если управление от Po0) :
  Mux_Port->CLR = Mux_Pins(0x0f);
  Mux_Port->SET = Mux_Pins(0x30);
 #endif
/*
#ifdef _SecondPlatBit
    if ((num &0x10) == 0)
    {
     _SecondPlatPort->SET =  _SecondPlatBit;
    }
    else
    {
     _SecondPlatPort->CLR =  _SecondPlatBit;

    }
#endif
  */
  }
}
#endif
//----------------------------------------------

static __INLINE void mAD_Izm( struct Channel_AD ach , word* AddrResult )
{
//  LPC_ADC_TypeDef *pADC = (LPC_ADC_TypeDef*) LPC_ADC_BASE;
  slword ax ; //,tx;
  volatile lword lax;

#ifdef _Adc_Extend // Внешний мультиплексор АЦП .
  mSet_MUX( ach.mux >> 8 )  ;
#endif

   // DAN 11.09.2017 11:30 - Если мерять мультиплексированные аналоговые каналы в фоне , то запрет прерываний
   // нужно перенести выше , перед зарядкой выборки мультиплексора . Тем самым добавится еще 12мкс ,
   // на которые может съехать передний фронт ИУ ... Поэтому пока что лучше заряжать мультиплексированные
   // измерения в прерывании ...

      //AdBuff_AddrResult [(w)OutAdBuffCount] = ( AddrResult );
  // ax = ach.mux&0xff00;
  asm_di();
   //
tx = timer1;

        //  ax = ach.mux;
        // В маске для внутреннего АЦП - только вторая тетрада . Третья и четвертая терады могут использоваться для внешних мультиплексоров АЦП ... :
        if ((ach.mux &~0xff0f)!= 0) // Внутрений АЦП процессора (_ChXX_Numb >= 16 ) - используем для измерения Р24 , Р12 , N12 ...  :
        {
           LPC_ADC->CNR &= ~( 0x000000FF | ADC_CR_START_NOW );
           LPC_ADC->CNR |= ( ADC_CR_CH_SEL((ach.mux&0x0f))| ADC_CR_START_NOW );
           lax = LPC_ADC->GDR;
           ax = timer1;
           while ( (lax&ADC_GDR_DONE_FLAG)== 0)
           {
               if ( (u)((w)(timer1-ax)) >= _MkSec(10))
               {
                   ax = timer1;
                   LPC_ADC->CNR &= ~( 0x000000FF | ADC_CR_START_NOW );
                   LPC_ADC->CNR |= ( ADC_CR_CH_SEL((ach.mux&0x0f))| ADC_CR_START_NOW );
               }
               lax = LPC_ADC->GDR;
           };
          *AddrResult =  ADC_GDR_RESULT(LPC_ADC->DR[ach.mux&0x0f]) / _AD_K33 ;
        }
        else // Внешний АЦП :
        {
#ifdef  _ADC_SPI
          *AddrResult = SPI_izm (_ADC_SPI,
#ifdef _ADC_CS
              _ADC_CS,
#endif
             ach.mux & 0xf );
#else  //_ADC_SPI
          *AddrResult = 0;//Нет внешнего АЦП на SPI
#endif //_ADC_SPI

        }

      asm_ei();
#ifdef _Adc_Extend // Внешний мультиплексор АЦП .
    mClr_MUX(ach.mux >> 8)  ;
#endif
      dtizm = timer1 - tx;
///asm_ei();
    //  lax = ADC_GDR_CH(LPC_ADC->GDR);
}





/*   Функция для запуска измерения - использует внутри себя аналогичный
 * макрос - из-за чего время ее выполнения больше, чем макроса, но затраты
 * памяти при ее использовании меньше
 *   Ее имеет смысл использовать в программах не требовательных ко времени.
 */
void  AD_Izm( struct Channel_AD ach , word* AddrResult )
{
   mAD_Izm( ach , AddrResult ) ;
    return ;
}



/*   П/п обработки прерываний от АЦП.
 *  Прерыванием от АЦП используются два буфера:  "AdBuff_AddrResult[]" и
 * "AdBuff_Command[]". В первый из них рабочей програмой заносятся адреса
 * ячеек, в которые необходимо помещать результаты измерений АЦП, а во
 * втором - управляющие слова для мультиплексора АЦП, которыми в случае
 * наличия очереди измерений подключается нужный канал мультиплекора и АЦП
 * тут же из прерывания запускается на новое измерение.
 *  Рабочая программа, при необходимости измерения, посредством специальной
 * п/п заносит в свободные ячейки буферов, на которые указывает указатель
 * "InAdBuffCount" необходимые для измерения данные: управляющее слово
 * мультиплексора и адрес ячейки, в которую необходимо будет положить
 * результат измерения. После очередной записи в буфера этот указатель
 * должен увеличиваться на единицу, таким образом он всегда указывает на
 * ячейки в которые следует заносить, при необходимости, данные для
 * следующего измерения. Если указатель дошел до конца буфера , то его
 * возвращают снова к его началу и так по кругу. Для того чтобы не надо было
 * контролировать достижение указателем конца буфера, размер буфера
 * "AdBuffSize+1" принимается равным 2,4,8,16,32,64,128,256. В этом случае
 * величина указателя не выходит за сетку 1,2,3,4,5,6,7,8-ми младших битов.
 * Это позволяет перемещать указатель к следующей позиции с наименьшими
 * затратами времени следующим образом:
 *     "InAdBuffCount = ++InAdBuffCount & AdBuffSize ;"  -  указатель
 * увеличивается на единицу и на него накладывается маска обрезающая ненужные
 * старшие биты. Таким вот образом имитируется 1,2,3,4,5,6,7,8-ми битовое поле
 * сетки указателя и он, дойдя до конца буфера, в результате "переполнения"
 * своей сетки сам возвращается к началу буфера.
 *   Вышесказанное относится к случаю когда при необходимости сделать измерение
 * оказывается, что АЦП занят т.е. существует очередь. В случае же когда очередь
 * исчерпана и АЦП свободен, признаком чего является взведенный бит "Flg.NoAdBuffInfo"
 * (см.ниже),  рабочая программа, при необходимости измерения, должна
 * сама по управляющему слову мультиплексора подключить нужный канал и запустить
 * АЦП, а адрес ячейки, в которую необходимо будет положить результат измерения,
 * занести в буфер адресов по индексу "OutAdBuffCount", а не "InAdBuffCount"
 * т.к управляющее слово заносилось прямо в АЦП, а не в очередь.
 *  Считывание данных из буфера очереди подпрограммой прерывания производится посредством
 * указателя "OutAdBuffCount". Организация этого указателя абсолютно идентична
 * вышеописанной.
 * Указатель "OutAdBuffCount" всегда "отстает" от "InAdBuffCount".
 * Перед считыванием в прерывании данных из буфера для инициации следующего
 * измерения следует убедиться, что они там есть, т.е. что очередь существует.
 * Для этого необходимо проверить не сравняется ли указатель считывания с
 * указателем записи, если первый увеличить на единицу. Если оказывается что
 * они в результате этого станут равными - значит буфер пуст, очереди нет и
 * данных для следующего измерения нет. При этом взводится признак
 * "Flg.NoAdBuffInfo" указывающий но то, что очередь пуста и отработало последнее
 * прерывание от АЦП. При этом если рабочей программе необходимо будет
 * произветси измерение, она должна сама по управляющему слову мультиплексора
 * подключить нужный канал и запустить АЦП, а адрес ячейки, в которую
 * необходимо будет положить результат измерения, занести в буфер адресов по
 * индексу "OutAdBuffCount", а не "InAdBuffCount" т.к управляющее слово зано-
 * силось прямо в АЦП, а не в очередь.
 *   Аналогично перед записью данных в буфер измерений в рабочей программе следует
 * убедиться, что в буфере еще осталось место. Для этого необходимо проверить
 * не сравняется ли указатель записи с указателем считывания если первый
 * увеличить на единицу. Если оказывается, что они в результате этого станут
 * равными - значит в буфере места нет и принятый байт записывать некуда, при
 * этом следует либо подождать пока место появится, либо проигнорировать это
 * обстоятельство.
 */
/*
void ADC_IRQHandler (void)
{

        //  Поместить результат измерения по заданному адресу.
      *AdBuff_AddrResult [(w)OutAdBuffCount] = ADC_GDR_RESULT(LPC_ADC->GDR) ;
         //  Есть ли данные в буфере очереди ?
      if ( ((OutAdBuffCount + 1) & AdBuffSize) != InAdBuffCount )
        {      // Очередь есть.
            OutAdBuffCount = ++OutAdBuffCount & AdBuffSize ;
            // Запуск АЦП по следующему в очереди управляющему слову.
            mSet_MUX( AdBuff_Command [(w)OutAdBuffCount] >> 8 )  ;
 	        LPC_ADC->CNR &= ~( 0x000000FF | ADC_CR_START_NOW );
	        LPC_ADC->CNR = (  ADC_CR_CH_SEL(AdBuff_Command [(w)OutAdBuffCount]) ) | ADC_CR_START_NOW;
        }
      else
        {      //  Измерения закончились и Очереди нет.
          Flg.NoAdBuffInfo = 1 ;  // Установка флага свободности АЦП.
 	        LPC_ADC->CNR &= ~( 0x000000FF | ADC_CR_START_NOW );
//          LPC_ADC->INTEN = 0;
        }
      return  ;
}
*/

//Измерения по SPI с внешнего АЦП, если номер канала больше 7, то измерения
//производятся со второй микросхемы(устанавливаем бит ADC_SEL в 1)
//Считывание происходит в два этапа: сначала устанавливаем номер канала,
//потом следующим считыванием забираем значение измерения.
//Если задана выборка микросхемы, то в вызове функции добавляется еще порт выборки
word SPI_izm (LPC_SSP_TypeDef *SSPx,
#ifdef _ADC_CS
              LPC_GPIO_TypeDef *CS_Chnl,
#endif
              word chnl)
{
  word ax ; //, t ;
#ifdef _ADC_CS
  if ((chnl&0x8)!= 0 )
  {
     CS_Chnl->SET = _ADC_SELL_Msk;
  }
  else  CS_Chnl->CLR = _ADC_SELL_Msk;
#endif
   adc_sts._.addr = chnl&0x0007;

   write_ssio( SSPx, adc_sts.all);

   ax = read_ssio(SSPx)&0xfff;

/*#ifdef _ADC_CS

   if ((chnl&0xfff8)!= 0 )
  {
     CS_Chnl->CLR |= _ADC_SELL_Msk;
  }
  else  CS_Chnl->SET |= _ADC_SELL_Msk;

#endif*/
   //t = timer1;
   //while( (u)((w)(timer1 - t ))< _r.AD_pause);

  #ifndef _ADC_12_
   return ax >> 2 ;  // 10-ти разрядный АЦП - перестраховочный вариант Idnom = 200d Udnom = 400d .
  #else
   return ax ;       // 12-ти разрядный АЦП - нормальный       вариант Idnom = 800d Udnom =1600d .

  #endif

}
