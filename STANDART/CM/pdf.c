
#include "pdf_drv.c"


      //  Настройки для ПДФов.

void pdf_init ( void )
{
   pdf_drv_init( 0 ) ;

  return ;
}

void pdf_input ( void )
{
  word ax ;
  static word PDF_time ;

#ifdef _T_PDF
  word bx ;
  //---
  for ( ax = 0 ; ax < _PDF_Num ; ax++ )
  {
  //если период импульсов по ПДФ не садился на ограничение по максимому,
  //ограничением является значение "_PDF_base_time * 5" = 50ms.
  if ( PDF[ax].flg._.t_ogr_pdf == 0 )
   {
    asm_di();
    bx = timer1 - pdf_drv_data[ax].Tpdf_time ;
    if ( (u)((w)bx) > (_PDF_base_time * 6) )
      {
       PDF[ax].flg._.t_ogr_pdf = 1 ;
       //if ( pdf_interrupt(ax) == 1 )
       PDF[ax].N_Tpdf = 0 ; // прерывания разрешены
      }
    asm_ei();
   }
  }
#endif

  // 05.09.2019 - В связи с болтанкой сигнала ПДФ Оноприенко и Даниличев переделали последовательность операций :
/*ax = timer1 - PDF_time;
  for ( bx = 0 ; bx < _PDF_Num ; bx++ )
  {
    if ( ( PDF[bx].flg._.pdf_zona_T )||((u)((w)ax) >  _PDF_base_time) )
    {
      pdf ( 1 , bx ) ;
      PDF_time = timer1;
    }
  }*/

  // 05.09.2019 - В связи с болтанкой сигнала ПДФ Оноприенко и Даниличев переделали последовательность операций :
    asm_di();
  ax = timer1 - PDF_time;
  if( ( PDF[0].flg._.pdf_zona_T == 0 ) && ((u)((w)ax) <  _PDF_base_time) )
  {
    asm_ei();
    return;
  }
  PDF_time = timer1;
    asm_ei();
  pdf ( 1 , 0 ) ;

  return ;
}

//   Скорость по ПДФ можно рассчитывать по частоте импульсов или по периоду импульсов , например ,
// рассчет дискрет 10 импульсов за базовое время 10 мс :
// 1. По частоте : 10 имп * _PDF_Kmul = 40 ( 590 проц.) или 20 ( 360 проц.)
// 2. По периоду : _PDF_base_time / 10 имп = 10000 мкс / 10 имп = 1000 мкс = 1000 дискрет timer1 .
//
// |------|------------|-------------|------------|
// | имп  | Дискреты   |  Дискреты   | Дискреты   |
// | за   | по частоте |  по частоте | по периоду |
// | 10мс | 590 проц.  |  360 проц.  |            |
// |------|------------|-------------|------------|
// |  10  |    40      |    20       |    1000    |
// |  30  |    120     |    60       |    333     |
// |  50  |    200     |    100      |    200     |
// | 100  |    400     |    200      |    100     |
// |------|------------|-------------|------------|
//
//   Как видно из таблицы , при небольших скоростях и , соответственно , небольших количествах
// импульсов бОльшее количество дискрет , а значит , и бОльшую точность дает рассчет по периоду .
// По достижению порога ( сейчас принят 40 имп за 10 мс и для 590 и для 360 ) переходим с рассчета
// по периоду на теперь уж более точный рассчет по частоте и наоборот ( с гистерезисом ) .

//   Расчет скорости по частоте производится по формуле: N = F * Km , где F - частота импульсов ,
// Km - масштабирующий коэффициент . Или N = ((PDF_out * 65536)/dT) * Km , где PDF_out - кол-во
// учетверенных ( или удвоенных ) импульсов , dT - время подсчета импульсов .

//   Расчет скорости по периоду производится по формуле:
// PDF_out = ((dT * 65536)/T) * _PDF_Kmul * Km , где T - период импульсов .

//   Величина масштабирующего коэффициента Km выбирается такой , чтобы при номинальной
// скорости двигателя величина PDF_out равнялась 3200 дискрет. Домножение на 65536
// делается для того, чтобы не потерять дробные величины (в результате получается
// число импульсов не за 1 дискрету таймера, а за 65536 дискрет что, в принципе,
// не имеет значения, так как полученная величина все равно пропорциональна
// скорости). Масштабирующий коэффициент сдвинут  влево на 10.

word pdf ( word code , word num )
{
 register word ax ;// , cx ;
 register lword lax;
 register struct PDF_data *ptr ;
#ifdef _T_PDF
 float dax,dbx;
 static float dcx;
 word dt_ob_max;  //максимальный период, который может воспринимать ПДФ по периоду
 word edges;
#endif
 ptr = &PDF[num] ;

 switch ( code )
 {
   case 0 :    // настройка EPA - передаем его условный номер.

     ptr->out_ob = 0 ;
     ptr->out_m  = 0 ;
     ptr->out_g  = 0 ;
     ptr->time   = timer1 ;
    // ptr->count  = pdf_drv_read( num ) ;
     ptr->Fpdf   = 0 ;
     ptr->N_Fpdf = 0 ;
     ptr->N_Tpdf = 0 ;
     ptr->flg.all= 0 ;
     ptr->fz = 0 ;
     //---
       break;

   default:;

     //Число импульсов за 10 мсек
     ptr->Fpdf =QEI_GetVelocityCap(num);

     lax = _Skor_Nom * ptr->Fpdf;

     //Скорость в оборотах в минуту ( с основанием _Skor_Nom ) :
     lax = QEI_CalculateRPM(num,lax,_r.PDF[num].imp);
     //Определение направления вращения
     if ( QEI_GetStatus(num, QEI_STATUS_DIR) ) lax = ~lax + 1 ;

     ax = (slw)lax / (slw)(sw)(_Skor_Nom/10); //Скорость в оборотах в минуту ( с основанием 10 ) .

     //lax = (slw)(sw)_Skor_Nom * (slw)(sw)ax ;
     lax = (slw)lax*(slw)(sw)10/(slw)(sw)_sr.NOM.N.fe ; // 15.05.2021 АТК - убираем основание уставки 10 , а основание 10 в об/мин остаётся .

     ptr->N_Fpdf = lax;
   //mUSEL_not();



  #ifdef _T_PDF
     //  При запрете прерываний устанавливаем ограничения, чтобы при включении
     //прерываний не получился большой период.
     //Прерывания включены всегда
    // if ( pdf_interrupt(num) == 0 && ptr->flg._.t_ogr_pdf == 0 ) ptr->flg._.t_ogr_pdf = 1 ;

     //Масштабирование скорости по периоду импульсов
     if ( pdf_drv_data[num].Scht_T != 0 ) // если насчитало хотя-бы один период или больше
       {
        // Масштабирование сигнала по ПДФ происходит с использованием двух
        // уставок "ПДФ0-имп/об." и  "N-ном (Об/мин)" и вычисляется по формуле:
        //   Km = Skor_Nom * 60000000 / ( "ПДФ0-имп/об." * "N-ном (Об/мин)" ),
        //   где 60000000 - 60сек в дискретах timer1 ( 1дискрета - 1мкс ) .
       // lax = (lw)60000000 / (lw)(w)_r.PDF[num].imp  ;
       // lax *= (lw)(w)_Skor_Nom ;
       // lax = (lw)lax / (lw)(w)_sr.NOM.N.fe ;

      //if ( QEI_GetStatus(num, QEI_STATUS_DIR) ) ax = ~ax + 1 ; 23.01.2020 11:35 - инверсия отрицательного сигнала не нужна .

         asm_di() ;   // запретить прерывания.
        //Само масштабирование сигнала по периоду
        // N =  Km / T ;
        // где T - период импульсов по ПДФ
        // fr1[0] = (float)pdf_drv_data[num].Scht_T;
        // fr1[1] = (float)pdf_drv_data[num].Tpdf;
        // fr1[2] = (fr1[0]*10000)/fr1[1];
         dbx = (float)pdf_drv_data[num].Scht_T;
         dcx = (float)pdf_drv_data[num].Tpdf ;
         pdf_drv_data[num].Scht_T = 0 ,  pdf_drv_data[num].Tpdf = 0 ;
         asm_ei() ;

         dax = 60000000. / (float)(w)_r.PDF[num].imp  ;
         dax *= dbx;
         dax /= (dcx*(float)_PDF_Kmul) ;

         if ( QEI_GetStatus(num, QEI_STATUS_DIR) )  dax *= -1; // Инвертируем , если отрицательная скорость .

         //fr1[3] = dax;
         dcx = dax;
         dax *= (float)(sw)_Skor_Nom; //* (slw)lax ;
         dax *= (float)(sw)10 ; // 15.05.2021 АТК - убираем основание уставки 10 , а основание 10 в об/мин остаётся .
         dax /= (float)(sw)_sr.NOM.N.fe ;
//          fr1[4] = dax;
         ptr->N_Tpdf = (sw)dax;// * (lw)pdf_drv_data[num].Scht_T / (lw)pdf_drv_data[num].Tpdf ;

       //if ( QEI_GetStatus(num, QEI_STATUS_DIR) )  ptr->N_Tpdf  =  ~ptr->N_Tpdf + 1 ; 23.01.2020 11:35 - перенесено выше .


          // разрешить прерывания.
         //if ( (sb)pdf_drv_sign(num) < 0 )  ptr->ptr->N_Tpdf  =  ~ptr->ptr->N_Tpdf + 1 ;
       }
     else
       {
         //обнуление значения скорости, если обороты упали ниже 0.1 об/мин
         //максимальный период в этом случае равен 600 сек / кол_имп * (2 или 4, в зависимости от настроек)
         edges = (w)((QEI_GetPointer(num)->CONF & QEI_CONF_CAPMODE) ? 4 : 2);
         lax = 600*_fSec(1);
         dt_ob_max = lax/(lw)(_r.PDF[num].imp*edges);

         if ((u)((w)(Timer1_fSec - PDF_Oborot_Time)) > dt_ob_max )
         {
            dcx = 0;
         }
       }

     // порог переключения с частоты на период и наоборот ( мб сделать уставку для перехода ) .
     // переключение на ОС по периоду при небольших скоростях                       // Для одинаковой точности при переходе :
     if      ( (w)ptr->Fpdf < (w)( 20 * _PDF_Kmul ) )  ptr->flg._.pdf_zona_T = 1 ;  // 05.09.2019 - было 40 , Шестаков пересчитал .
     else if ( (w)ptr->Fpdf > (w)( 25 * _PDF_Kmul ) )  ptr->flg._.pdf_zona_T = 0 ;  // 05.09.2019 - было 45 , Шестаков пересчитал .

     if  ( ptr->flg._.pdf_zona_T == 1 )
     {
       ptr->out_m = ptr->N_Tpdf ; // скорость по периоду .
       //скорость в оборотах в минуту ( с основанием 10 , не из уставки об/мин , а добавленного в этой программе ) :
       ax = (sw)(dcx * 10.0) ;
     }
     else
  #endif
           ptr->out_m = ptr->N_Fpdf ; // скорость по частоте .
          //Само масштабирование сигнала по частоте
     ptr->out_ob =  ax; //скорость в оборотах в минуту ( с основанием 10 , не из уставки об/мин , а добавленного в этой программе )

     //---
     ptr->flg._.new_izm_pdf = 1 ; // взвод флага готового измерения ПДФ .

  break;
 }
   //------

 return 1 ;
}
