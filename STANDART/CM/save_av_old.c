//    ПРОГРАММА  ЗАПИСИ  ПОСЛЕДНЕЙ  АВАРИИ  В  FLASH-ПЗУ.

/*------------------------------------------------------------------*/

/*   Программа занесения в память i2c данных текущей аварии.
 *   Заносятся аварийные регистры сообщений и фрагмент следа из N-пульсов.
 *   Данные аварий регистрируются в памяти по замкнутому циклу в
 * пределах адресов '_i2c_av_beg+2' и '_i2c_av_end'.
 * По адресу '_i2c_av_beg' находится двухбайтный указатель конца данных
 * последней зарегистрированной аварии. Он всегда указывает на следующую,
 * после последнего занесенного байта данных аварии, свободную ячейку
 * памяти.
 *   Программа работает "методом по частям" и запускается после отработки
 * аварии и отключения следа, до Дист.Сброса.
 *   Программа возвращает:
 * - 0 - по заверешении записи;
 * - 4 - в процессе записи;
 * - 1 - при нарушении связи с i2c.
 */
word   Save_avar ( void )
{
    static   word L_Av, ax_count;
    word    ax, cx ;

      //   Следует следить, чтобы номера меток здесь и далее шли
      //  последовательно по возрастающей.
  enum { i0, i4, i5_5, i6 };


    switch ( i2c_av_label )
     {
      default: i2c_av_label = i0;
      case i0:
               //Номер массива последней аварии в который будем писать наши данные
               if ( Last_Av >= _MaxNumbAv) L_Av = 0;
               else L_Av = Last_Av;
               //-----------------
               Asave[L_Av].CtrlCode = 0xabcd;
                 //   Запуск записи 16-ти байт регистров аварий
               Asave[L_Av].Msg = msg_av ;
                 //   Запись текущей таблицы адресов следа.
               Asave[L_Av].sled = sled ;
                i2c_av_label = i4 ;
               break;
               //-----------------
      case i4 :
                 // Записываем фрагмент следа исходя из заданного объема
                 // записываемого фрагмента следа, независимо от того
                 // сколько колонок следа регистрировалось реально,
                 // для удобства последующего учета границ различных
                 // фрагментов следа, т.к. их размер будет одинаковым.

                   // влазит ли заданный размер страницы в i2c.

               ax = _MaxSaveSled ;
                   // Не больше ли заданный размер фрагмента, чем сам след?
               if( ax > _SizeSledPole )  ax = _SizeSledPole ;
               if ( ax > sl_d.print_size) ax = sl_d.print_size;

               Asave[L_Av].sled.save_mem = ax;
                 /*  Отступаем от конца следа в ОЗУ на
                  * заданное количество пульсов N к началу следа.
                  * Проверяем возможность перехода при этом через нижнюю
                  * границу области следа к ее верхней границе.
                  * Запускаем запись фрагмента следа в i2c.
                  */
               cx = sl_d.index - ax ;
                  // не переваливает ли след через свою верхнюю границу?
                if ( sl_d.index >= ax )
                {         // нет не переваливает:
                    for(ax = 0; cx< sl_d.index; ++cx)
                    {
                        Asave[L_Av].Sled_data[ax] = SledPole[cx] ;
                        ++ax;
                    }
                    i2c_av_label = i6 ;
                }
                else    //  След переваливает через свою верхнюю границу:
                {      // данные следа лежат в ОЗУ  на двух отрезках.
                        // Пишем отрезок до верхней границы:
                    cx += _SizeSledPole ;
                    for(ax_count = 0; cx< _SizeSledPole; ++cx)
                    {
                        Asave[L_Av].Sled_data[ax_count] = SledPole[cx] ;
                        ++ax_count;
                    }
                    i2c_av_label = i5_5 ;
                    break;
    case i5_5 :

                    //   Пишем отрезок после верней границы, т.е. от нуля.
                    for (cx = 0;cx < sl_d.index; ++cx)
                    {
                        Asave[L_Av].Sled_data[ax_count] = SledPole[cx] ;
                        ++ax_count;
                    }
                    i2c_av_label = i6 ;
               }
               break;

               //-----------------
      case i6 :  //   Запись указателя адреса конца данных последней
                // зафиксированной аварии.

         //     if( Flash_Store(1)!= 4)
         //     {
                 Last_Av = ++L_Av;
                 i2c_av_label = i0;
         //     }

               return 0;
    }
  return 4;
}


/*    Сервисная программа извлечения из i2c аварийных регистров сообщений
 * и фрагмента следа по заданному номеру следования аварии во времени.
 * Номер -1- состветствует последней зафиксированной аварии,
 * номер -2- состветствует предпоследней зафиксированной аварии и т.д.
 *    Данные аварий регистрируются в памяти по замкнутому циклу в
 * пределах адресов '_i2c_av_beg+2' и '_i2c_av_end'.
 * По адресу '_i2c_av_beg' находится двухбайтный указатель конца данных
 * последней зарегистрированной аварии. Он всегда указывает на на следующую,
 * после последнего занесенного байта данных аварии, свободную ячейку
 * памяти.
 */

void ReLoad_sled ( void )
{
  static   byte tst_msg ;
  static   word L_Av;

  word ax, bx, cx ;
  lword lax;


      //   Следует следить, чтобы номера меток здесь и далее шли
      //  последовательно по возрастающей.
      enum { i0, i1, i2, i3, i4, i5, i6, i7 };

      if ( M_FirstCall == 1 )  /*  Идентификация первого входа для задания  */
        {                      /* начального условия ...                    */
          M_FirstCall = 0 ;
              m_index = 1 , Label = 0; // , m_ext = 0 ;
              output_s ( _ReLoadAvar_txt "\n") ;
          tst_msg = 0 ;
            // Останавливаем След.
          bo_SledStart = 0 ;
          L_Av = Last_Av;
          //return ; 20.10.04 15:27
        }
       //  пока находимся в распечатке следа, острочиваем автозапуск следа.
      sl_d.time_out = Timer1_Ovr ;  //20.10.04 15:27

          //  Закончено ли восстановление данных и вкл.вывод сообщений.
      if ( tst_msg != 0 )
      {     //  Однократная установка "M_FirstCall" для "print_message".
        if ( tst_msg == 1 )  tst_msg = 2 , M_FirstCall = 1 ;
          //  Вывод восстановленных аварийных сообщений.
        print_message ( &msg_av ) ;
        return ;
      }

  switch ( Label )
    {
      default: Label = 0 ;
      case i0:     // Ожидание завершения предыдущего вывода.
              if (  TestCompleted_Output() )
                {   // вывод номера аварии предлагаемой к выборке из i2c.
                  output_s ( _ReLoad_prm ) ;
            //    output_c ( m_index/10 + 0x30 ) ;// десятки.
            //    output_c ( m_index%10 + 0x30 ) ;// единицы.
            // 22.06.2017 9:59. В СМ3 при отсутствии журнала количество следов оказалось больше сотни.
            lax = (lw)m_index;
            for ( ax = 10000, cx = 0; ax != 1; ax /= 10 )
            {
              bx = lax / ax;
              lax %= ax;

              if ( bx == 0 && cx == 0 ) output_c (' '); //пока идут первые нули - не выводим их
              else
              {
                cx = 1;
                output_c ( (b)bx + 0x30 );
              }
            }
            output_c ( (b)(w)lax + 0x30 ); //распечатываем последнюю цифру

                  Label++ ;
                  break ;
                }
      case i1: if (  TestData_for_Input() )
                {   // вычисляем кол-во страниц в следе.
                  mInput_c ( m_ch ) ;
                  if ( m_ch == Return )
                    {
                      Pult_Prog_Addr = _MainPultProg ,  M_FirstCall = 1 ;
                      return ;   // добавить еще какую-то иниц.
                    }
                    // выбор номера аварии подлежащей выборке из i2c.
                  else if ( m_ch == Up )
                    {
                      if ( ++m_index >  _MaxNumbAv) m_index = 1 ;
                      Label-- ;
                    }
                  else if ( m_ch == Down )
                    {
                      if ( --m_index == 0 ) m_index = _MaxNumbAv ;
                      Label-- ;
                    }    // переход к выборке данных по выбранному номеру аварии.
                  else if ( m_ch == Enter )
                    {
                      Label++ ;
                      output_s ( _Waiting_txt ) ;
                }   }
              break ;
            //-------------------

      case i2:  Prg._.Sled = 0 ;  //  ожидаем остановки следа.
                  if ( bo_SledActiv == 0 ) Label++ ;
              break ;
            //-------------------

      case i3 :    //  Проверка указателя: не было ли там какого-то мусора.

               if ( (L_Av > _MaxNumbAv)/*||(Last_Av == 0)*/)
               {
                     L_Av = 0;
                    // Flash_Store();
                     m_ext = 0 ;
               }
               else  m_ext = L_Av ;

               //-----------------

                 //  Отступаем от последней аварии к началу заданной аварии.

               if (  m_ext >= m_index)
               {
                    m_ext -= m_index;
               }
               else
               {
                  m_ext += _MaxNumbAv  - m_index;

               }
               if (Asave[m_ext].CtrlCode != 0xabcd)
               {
                     output_s ( _Avar_Not_txt ) ;
                     Label = i7 ;
                     m_time = Timer1_Ovr;
                     break ;
               }


               //   Cчитываем регистры аварии.
              msg_av = Asave[m_ext].Msg;
                 //  Текущая таблица адресов следа:
                    // не было-ли там какого-то мусора?
                if ( Asave[m_ext].sled.type == sled.type )
                {   // таблица как-будто исправна - можно переписывать.
                  sled =  Asave[m_ext].sled;
                }
                Label = i4 ;
               break;
      case i4 :
                 // Считываем фрагмент следа исходя из заданного объема
                 // считываемого фрагмента следа, независимо от того
                 // сколько колонок следа регистрировалось реально,
                 // для удобства последующего учета границ различных
                 // фрагментов следа, т.к. их размер будет одинаковым.
                 if (sled.save_mem > _SizeSledPole) sled.save_mem = _SizeSledPole;

                 for ( ax = 0; ax < sled.save_mem; ++ax)
                 {
                    SledPole[ax] =  Asave[m_ext].Sled_data[ax];
                 }
                Label = i5 ;
               break;
      case i5 :
                   //   Находим соответствие именам из рабочей таблицы имен
                   // в const-таблице и списываем ее свежие параметры (адрес),
                   // поскольку при перезашивке адрес переменной мог измениться
                   // по-сравнению с устаревшим адресом данной переменной хранящимся в i2c.
               if ( TestSledTab () == 0 )  Label++ ;
               break;
               //-----------------
      case i6 :
               output_s ( "\n\r  Ok. \n\r" ) ;
               sl_d.print_size = sled.save_mem ;   /* Распечатываемый размер следа. */
               if ((_SizeSledPole != _MaxSaveSled) ||(sled.save_mem < _SizeSledPole))
               {
                 sl_d.index = sled.save_mem ;
               }
               else
               {
                 sl_d.index = 0; 
               }
               tst_msg = 1 ; // вкл.распечатку сообщений.
               break;
    case i7:
              if ((Timer1_Ovr - m_time)>= _Sec(3))
              {
                Pult_Prog_Addr = _MainPultProg ,  M_FirstCall = 1 ;
              }
              break;


      //---------------------------------------------
    }

 Restart_Output ()  ;

  return ;
}
