
void pdf_drv_init( word num )
{
  switch ( num )
  {
    case 0 :  // ПДФ0
         //   Для определения направления прерываемся по переднему
         // фронту F00, а читаем F90
        //Срабатывание по переднему фронту
      ELVR_LALB4 = 0x02;
      pdf_ei (0) ; // разрешение прерывания для определения знака ПДФ .
        //---
      pdf_drv_data[0].sign = 0 ;
      pdf_drv_data[0].time = timer1 ;
    //ДДДДДДДДДДДДДДДДДДДДДДReload timer0ДДДДДДДДДДДДДДДДДДДДДДДДДД
      TMRLR0 = 0xffff; // счетчик на вычитание, перезагружаемый 0xFFFF после достижения нуля.
                      // счетчик внешних событий по обоим фронтам,
      TMCSR0 =0xd93;   //1101 1001 0011 - по внешнему входу, перезагружаемый
      //TMCSR0_TRG = 1; // запуск счетчика
      break;

    case 1 :  // ПДФ1
      ELVR_LALB6 = 0x02;
      pdf_ei (1) ; // разрешение прерывания для определения знака ПДФ .
        //---
      pdf_drv_data[1].sign = 0 ;
      pdf_drv_data[1].time = timer1 ;
    //ДДДДДДДДДДДДДДДДДДДДДДReload timer1ДДДДДДДДДДДДДДДДДДДДДДДДДД
      TMRLR1 = 0xffff;

      TMCSR1 =0xd93;   //1101 1001 0011 - по внешнему входу, перезагружаемый
      //TMCSR1_TRG = 1;
      break;
  }

  return ;
}

// Функция разрешения прерывания для определения знака ПДФ .
void pdf_ei ( word num )
{
  switch ( num )
  {
    case 0 :  // ПДФ0
      EIRR_ER4 = 0 ;          // сбрасываем запрос по ЕПА .
      ENIR_EN4 = 1 ;          // разрешаем прерывания ЕПА .
      ICR06 = _PDF_PRIORITY ; // приоритет прерывания .
      break;
      //-----------
    case 1 :  // ПДФ1
      EIRR_ER6 = 0 ;          // сбрасываем запрос по ЕПА .
      ENIR_EN6 = 1 ;          // разрешаем прерывания ЕПА .
      ICR08 = _PDF_PRIORITY ; // приоритет прерывания .
      break;
  }
  return ;
}

// Функция запрета прерывания для определения знака ПДФ .
void pdf_di ( word num )
{
  switch ( num )
  {
    case 0 :  // ПДФ0
      EIRR_ER4 = 0 ;          // сбрасываем запрос по ЕПА .
      ENIR_EN4 = 0 ;          // запрещаем прерывания ЕПА .
    //ICR06 = _PDF_PRIORITY ; // приоритет прерывания .
      break;
      //-----------
    case 1 :  // ПДФ1
      EIRR_ER6 = 0 ;          // сбрасываем запрос по ЕПА .
      ENIR_EN6 = 0 ;          // запрещаем прерывания ЕПА .
    //ICR08 = _PDF_PRIORITY ; // приоритет прерывания .
      break;
  }
  return ;
}

// Состояние прерывания для определения знака ПДФ : 1 - разреш , 0 - запреш .
word pdf_interrupt( word num )
{
  word ax ;
  ax = 0 ;
  switch ( num )
  {
    case 0 :  if ( ENIR_EN4 == 1 )  ax = 1 ; // ПДФ0
      break;
      //-----------
    case 1 :  if ( ENIR_EN6 == 1 )  ax = 1 ; // ПДФ1
      break;
  }
  return ax ;
}

      //  чтение текущего значения счетчика импульсов,
     // счетчик считает непрерывно, не сбрасывается.
word pdf_drv_read( word num )
{
  word ax ;

  switch ( num )
  {
    case 0 :  ax = ~TMR0;  // счетчик на вычитание => превращаем его на сложение.
      break;
      //-----------
    case 1 :  ax = ~TMR1;
      break;
  }
  return ax ;
}
//-------------------

//   Прерывания для определения направления вращения.

__interrupt void pdf0_Interrupt   (void)
{
  word count , ax ;
//  EIRR_ER4 = 0 ;    // Сброс запроса прерывания перенесён в конец функции .
  //---
     //   Для определения направления прерываемся по переднему
     // фронту F00, а читаем F90
     //   Базовое время ПДФ (10-2=8мс) делим на интервал между импульсами F00 .
     // Чем чаще идут импульсы , тем больше повторов знака должно накопиться .
     // Полученное при делении число пропорционально максимальному количеству
     // повторов знака скорости .
  //---
  if ( PDR2_P25 == 1 ) // направление Назад :
   {
     count = ( (c)( _PDF_base_time * 0.8 ) ) / // Базовое время - 8мс.
               (u)( timer1 - pdf_drv_data[0].time ) ; // Время между F00 .
     pdf_drv_data[0].time = timer1 ; // Запоминаем время прихода фронта F00 .
     count = ~count /*+ 1*/ ; // при направлении Назад инвертируем счетчик и
     // не прибавляем 1 , чтобы +0 соответствовало -1 ( Принцип : -2 -1 | 0 1 ).
     //--- Защита от переполнений :
     if      ( (sw)count < -7 ) count = -7 ;
     else if ( (sw)count > -1 ) count = -1 ;
     //---
     ax = (sw)(sb)pdf_drv_data[0].sign ;
     ax-- ;
     if ( (sw)ax < (sw)count )  pdf_drv_data[0].sign = (sb)count ;
     else                       pdf_drv_data[0].sign = (sb)ax ;
   }
  else                 // направление Вперед :
   {
     count = ( (c)( _PDF_base_time * 0.8 ) ) / // Базовое время - 8мс.
               (u)( timer1 - pdf_drv_data[0].time ) ; // Время между F00 .
     pdf_drv_data[0].time = timer1 ; // Запоминаем время прихода фронта F00 .
     //--- Защита от переполнений :
     if      ( (sw)count > 6 ) count = 6 ;
     //---
     ax = (sw)(sb)pdf_drv_data[0].sign ;
     ax++ ;
     if ( (sw)ax > (sw)count )  pdf_drv_data[0].sign = (sb)count ;
     else                       pdf_drv_data[0].sign = (sb)ax ;
   }
  // Сбрасываем запрос прерывания в конце , чтобы не схватить старые данные с
  // прошедшего фронта .
  EIRR_ER4 = 0 ;    // Сброс запроса прерывания.
  return ;
}

__interrupt void pdf1_Interrupt   (void)
{
  word count , ax ;
//  EIRR_ER6 = 0 ;    // Сброс запроса прерывания перенесён в конец функции .
  //---
     //   Для определения направления прерываемся по переднему
     // фронту F00, а читаем F90 .
     //   Базовое время ПДФ (10-2=8мс) делим на интервал между импульсами F00 .
     // Чем чаще идут импульсы , тем больше повторов знака должно накопиться .
     // Полученное при делении число пропорционально максимальному количеству
     // повторов знака скорости .
  //---
  if ( PDR2_P27 == 1 ) // направление Назад :
   {
     count = ( (c)( _PDF_base_time * 0.8 ) ) / // Базовое время - 8мс.
               (u)( timer1 - pdf_drv_data[0].time ) ; // Время между F00 .
     pdf_drv_data[0].time = timer1 ; // Запоминаем время прихода фронта F00 .
     count = ~count /*+ 1*/ ; // при направлении Назад инвертируем счетчик и
     // не прибавляем 1 , чтобы +0 соответствовало -1 ( Принцип : -2 -1 | 0 1 ).
     //--- Защита от переполнений :
     if      ( (sw)count < -7 ) count = -7 ;
     else if ( (sw)count > -1 ) count = -1 ;
     //---
     ax = (sw)(sb)pdf_drv_data[0].sign ;
     ax-- ;
     if ( (sw)ax < (sw)count )  pdf_drv_data[0].sign = (sb)count ;
     else                       pdf_drv_data[0].sign = (sb)ax ;
   }
  else                 // направление Вперед :
   {
     count = ( (c)( _PDF_base_time * 0.8 ) ) / // Базовое время - 8мс.
               (u)( timer1 - pdf_drv_data[0].time ) ; // Время между F00 .
     pdf_drv_data[0].time = timer1 ; // Запоминаем время прихода фронта F00 .
     //--- Защита от переполнений :
     if      ( (sw)count > 6 ) count = 6 ;
     //---
     ax = (sw)(sb)pdf_drv_data[0].sign ;
     ax++ ;
     if ( (sw)ax > (sw)count )  pdf_drv_data[0].sign = (sb)count ;
     else                       pdf_drv_data[0].sign = (sb)ax ;
   }
  // Сбрасываем запрос прерывания в конце , чтобы не схватить старые данные с
  // прошедшего фронта .
  EIRR_ER6 = 0 ;    // Сброс запроса прерывания.
  return ;
}
