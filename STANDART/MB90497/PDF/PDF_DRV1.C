
void pdf_drv_init( word num )
{
  switch ( num )
  {
    case 0 :  // ПДФ0
         //   Для определения направления прерываемся по переднему
         // фронту F00, а читаем F90
        //Срабатывание по переднему фронту
      ELVR_LALB4 = 0x02;
        //---
    //ДДДДДДДДДДДДДДДДДДДДДДReload timer0ДДДДДДДДДДДДДДДДДДДДДДДДДД
      TMRLR0 = 0xffff; // счетчик на вычитание, перезагружаемый 0xFFFF после достижения нуля.
                      // счетчик внешних событий по обоим фронтам,
      TMCSR0 =0xd93;   //1101 1001 0011 - по внешнему входу, перезагружаемый
      //TMCSR0_TRG = 1; // запуск счетчика
      break;

    case 1 :  // ПДФ1
      ELVR_LALB6 = 0x02;
        //---
    //ДДДДДДДДДДДДДДДДДДДДДДReload timer1ДДДДДДДДДДДДДДДДДДДДДДДДДД
      TMRLR1 = 0xffff;

      TMCSR1 =0xd93;   //1101 1001 0011 - по внешнему входу, перезагружаемый
      //TMCSR1_TRG = 1;
      break;
  }
  pdf_fz_init (num) ; // инициализация оборотного ПДФ .

  pdf_drv_data[num].Tpdf_time = timer1 ;
  pdf_drv_data[num].Tpdf      = _PDF_base_time * 5 ;
  pdf_drv_data[num].Scht_T    =  0 ;
  pdf_drv_data[num].sign      =  0 ;

   //Разрешение прерывания.
  pdf_ei (num) ;

  return ;
}

// Функция разрешения прерывания для определения знака ПДФ .
void pdf_ei ( word num )
{
  switch ( num )
  {
    case 0 :  // ПДФ0
      EIRR_ER4 = 0 ;          // сбрасываем запрос по ЕПА . // ICS01_ICP0 = 0 ;
      ENIR_EN4 = 1 ;          // разрешаем прерывания ЕПА . // ICS01_ICE0 = 1 ;
      ICR06 = _PDF_PRIORITY ; // приоритет прерывания .
      break;
      //-----------
    case 1 :  // ПДФ1
      EIRR_ER6 = 0 ;          // сбрасываем запрос по ЕПА . // ICS23_ICP2 = 0 ;
      ENIR_EN6 = 1 ;          // разрешаем прерывания ЕПА . // ICS23_ICE2 = 1 ;
      ICR08 = _PDF_PRIORITY ; // приоритет прерывания .
      break;
  }
  return ;
}

// Функция запрета прерывания для определения знака ПДФ .
void pdf_di ( word num )
{
  switch ( num )
  {
    case 0 :  // ПДФ0
      EIRR_ER4 = 0 ;          // сбрасываем запрос по ЕПА .  // ICS01_ICP0 = 0 ;
      ENIR_EN4 = 0 ;          // запрещаем прерывания ЕПА .  // ICS01_ICE0 = 0 ;
    //ICR06 = _PDF_PRIORITY ; // приоритет прерывания .
      break;
      //-----------
    case 1 :  // ПДФ1
      EIRR_ER6 = 0 ;          // сбрасываем запрос по ЕПА .  // ICS23_ICP2 = 0 ;
      ENIR_EN6 = 0 ;          // запрещаем прерывания ЕПА .  // ICS23_ICE2 = 0 ;
    //ICR08 = _PDF_PRIORITY ; // приоритет прерывания .
      break;
  }
  return ;
}

// Функция инициализации оборотного ПДФ .
void pdf_fz_init ( word num )
{
  num = num ;

  return ;
}
//-------------------

// Функция подсчета оборотов ПДФ и определения угла поворота ( вызывать в фоне
// или в прерывании - определить выше в инициализации pdf_fz_init () ) :
void pdf_fz ( word num )
{
  num = num ;
  return ;
}
//-------------------

// Состояние прерывания для определения знака ПДФ : 1 - разреш , 0 - запреш .
word pdf_interrupt( word num )
{
  word ax ;
  ax = 0 ;
  switch ( num )
  {
    case 0 :  if ( ENIR_EN4 == 1 )  ax = 1 ; // ПДФ0    // ICS01_ICE0
      break;
      //-----------
    case 1 :  if ( ENIR_EN6 == 1 )  ax = 1 ; // ПДФ1    // ICS23_ICE2
      break;
  }
  return ax ;
}

      //  чтение текущего значения счетчика импульсов,
     // счетчик считает непрерывно, не сбрасывается.
word pdf_drv_read( word num )
{
  word ax ;

  switch ( num )
  {
    case 0 :  ax = ~TMR0;  // счетчик на вычитание => превращаем его на сложение.
      break;
      //-----------
    case 1 :  ax = ~TMR1;
      break;
  }
  return ax ;
}
//-------------------

//   Прерывания для определения направления вращения.
//   и периода импулсов.
__interrupt void pdf0_Interrupt   (void)
{
  word count , ax ;

//  EIRR_ER4 = 0 ;    // Сброс запроса прерывания перенесён в конец функции .

 ax =  pdf_epa_time0 - pdf_drv_data[0].Tpdf_time ; // расчет периода импульсов ПДФ .
 pdf_drv_data[0].Tpdf_time = pdf_epa_time0 ; // время предыдущего прихода импульса F00 .
 //---
#ifdef _T_PDF
 // Усредненный период для скорости вычисляется только в случае, когда период между предыдущим
//и текущим импульсом меньше 50ms.
 if ( PDF[0].flg._.t_ogr_pdf != 1 )
  {
    pdf_drv_data[0].Tpdf += ax ;  // сумма периодов импульсов ПДФ .
    pdf_drv_data[0].Scht_T++ ;    // счетчик периодов импульсов ПДФ .
  }

  PDF[0].flg._.t_ogr_pdf = 0 ; // сброс флага .

 if ( (w)PDF[0].Fpdf > (c)( 20 * _PDF_Kmul ) ) // При количестве пар импульсов ( F00 и F90 )
   {                                           // больше 20 определять знак уже не надо :
    EIRR_ER4 = 0 ;    // Сброс запроса прерывания.
    return ;
   }
#endif
  //---
     //   Для определения направления прерываемся по переднему
     // фронту F00 (вход INT4) , а читаем F90 (вход PDR2_P25 ) .
     //   Базовое время ПДФ (10-2=8мс) делим на интервал между импульсами F00 .
     // Чем чаще идут импульсы , тем больше повторов знака должно накопиться .
     // Полученное при делении число пропорционально максимальному количеству
     // повторов знака скорости .
  //---
  // Базовое время - 8мс делим на время между F00 .
  count = ( (c)( _PDF_base_time * 0.8 ) ) / (u)ax ;
  //---
  if ( PDR2_P25 == 1 ) // направление Назад :
   {
     count = ~count /*+ 1*/ ; // при направлении Назад инвертируем счетчик и
     // не прибавляем 1 , чтобы +0 соответствовало -1 ( Принцип : -2 -1 | 0 1 ).
     //--- Защита от переполнений :
     if      ( (sw)count < -7 ) count = -7 ;
     else if ( (sw)count > -1 ) count = -1 ;
     //---
     ax = (sw)(sb)pdf_drv_data[0].sign ;
     ax-- ;
     if ( (sw)ax < (sw)count )  pdf_drv_data[0].sign = (sb)count ;
     else                       pdf_drv_data[0].sign = (sb)ax ;
   }
  else                 // направление Вперед :
   {
     //--- Защита от переполнений :
     if      ( (sw)count > 6 ) count = 6 ;
     //---
     ax = (sw)(sb)pdf_drv_data[0].sign ;
     ax++ ;
     if ( (sw)ax > (sw)count )  pdf_drv_data[0].sign = (sb)count ;
     else                       pdf_drv_data[0].sign = (sb)ax ;
   }
  // Сбрасываем запрос прерывания в конце , чтобы не схватить старые данные с
  // прошедшего фронта .
  EIRR_ER4 = 0 ;    // Сброс запроса прерывания.

  return ;
}

__interrupt void pdf1_Interrupt   (void)
{
  word count , ax ;

//  EIRR_ER6 = 0 ;    // Сброс запроса прерывания перенесён в конец функции .

 ax =  pdf_epa_time1 - pdf_drv_data[1].Tpdf_time ; // расчет периода импульсов ПДФ .
 pdf_drv_data[1].Tpdf_time = pdf_epa_time1 ; // время предыдущего прихода импульса F00 .
 //---
#ifdef _T_PDF
 // Усредненный период для скорости вычисляется только в случае, когда период между предыдущим
//и текущим импульсом меньше 50ms.
 if ( PDF[1].flg._.t_ogr_pdf != 1 )
  {
    pdf_drv_data[1].Tpdf += ax ;  // сумма периодов импульсов ПДФ .
    pdf_drv_data[1].Scht_T++ ;    // счетчик периодов импульсов ПДФ .
  }

  PDF[1].flg._.t_ogr_pdf = 0 ; // сброс флага .

 if ( (w)PDF[1].Fpdf > (c)( 20 * _PDF_Kmul ) ) // При количестве пар импульсов ( F00 и F90 )
   {                                           // больше 20 определять знак уже не надо :
    EIRR_ER6 = 0 ;    // Сброс запроса прерывания.
    return ;
   }
#endif
  //---
     //   Для определения направления прерываемся по переднему
     // фронту F00 (вход INT6) , а читаем F90 (вход PDR2_P27 ) .
     //   Базовое время ПДФ (10-2=8мс) делим на интервал между импульсами F00 .
     // Чем чаще идут импульсы , тем больше повторов знака должно накопиться .
     // Полученное при делении число пропорционально максимальному количеству
     // повторов знака скорости .
  //---
  // Базовое время - 8мс делим на время между F00 .
  count = ( (c)( _PDF_base_time * 0.8 ) ) / (u)ax ;
  //---
  if ( PDR2_P27 == 1 ) // направление Назад :
   {
     count = ~count /*+ 1*/ ; // при направлении Назад инвертируем счетчик и
     // не прибавляем 1 , чтобы +0 соответствовало -1 ( Принцип : -2 -1 | 0 1 ).
     //--- Защита от переполнений :
     if      ( (sw)count < -7 ) count = -7 ;
     else if ( (sw)count > -1 ) count = -1 ;
     //---
     ax = (sw)(sb)pdf_drv_data[1].sign ;
     ax-- ;
     if ( (sw)ax < (sw)count )  pdf_drv_data[1].sign = (sb)count ;
     else                       pdf_drv_data[1].sign = (sb)ax ;
   }
  else                 // направление Вперед :
   {
     //--- Защита от переполнений :
     if      ( (sw)count > 6 ) count = 6 ;
     //---
     ax = (sw)(sb)pdf_drv_data[1].sign ;
     ax++ ;
     if ( (sw)ax > (sw)count )  pdf_drv_data[1].sign = (sb)count ;
     else                       pdf_drv_data[1].sign = (sb)ax ;
   }
  // Сбрасываем запрос прерывания в конце , чтобы не схватить старые данные с
  // прошедшего фронта .
  EIRR_ER6 = 0 ;    // Сброс запроса прерывания.

  return ;
}
