//Программа стартовой инициализации последовательного порта

void sio_start(void)
{
  //задается скорость, и режим работы нулевого UARTа
  SMR0 = 0x8b; //500 кГц, режим синхронный с выдачей CLK
  //задается наличие контрольных битов(старт/стоп,четность)
  SCR0 = 0x13;//без контроля четности, стартовых и стоповых битов, длина 8 бит
  SSR0 = 0;  //Ргеистр статуса, прерывания выключены
  CDCR0 = 0x88;//делитель прескайлера 16МГц/8
}
// Выдача байта в последовательный порт
void sio_out(byte out)
{
  word ax, bx;
  byte cx;
  //Т.к. порт выдает данные от младшего бита к старшему то мы переворачиваем
  //байт для согласования программ
   cx = ((out&0x55)<<1|(out&0xaa)>>1); //переставляем местами соседние биты
   cx = ((cx&0x33)<<2|(cx&0xcc)>>2);   //переставляем местами соседние пары битов
   cx = ((cx&0x0f)<<4|(cx&0xf0)>>4);   //переставляем местами полубайты

  /*for (ax =0, dx = 0;ax<8;++ax)
  {
    cx = (out>>ax)&0x01;
    dx += cx<<(7-ax);
  } */
  //Выдача в последовательный порт
  SIDR0 = cx;
  //Т.к. мы не можем определить, когда закончилась передача
  //то делаем просто выдержку на 25 мкс
  ax = timer1;
  do
  {
    bx = timer1 - ax;
  }
  while ((u)bx < _MkSec(25));

  return ;
}
//Прием байта из последовательного порта
byte sio_input(void)
{
  word ax, bx;
  byte cx;
  //Для того, чтобы принять данные необходимо записать
  //что-то в порт(в нашем случае FF)
  SIDR0 = 0xff;
  //Выдержка для принятия данных
  ax = timer1;
  do
  {
    bx = timer1 - ax;
  }
  while ((u)bx < _MkSec(25));

  //Считаем, что данные приняты - считываем

  bx = SODR0;
  //Переворачиваем байт для передачи данных в
  //нормальном формате
   cx = ((bx&0x55)<<1|(bx&0xaa)>>1); //переставляем местами соседние биты
   cx = ((cx&0x33)<<2|(cx&0xcc)>>2); //переставляем местами соседние пары битов
   cx = ((cx&0x0f)<<4|(cx&0xf0)>>4); //переставляем местами полубайты


  return cx;
}
