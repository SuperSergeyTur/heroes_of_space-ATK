

/*  ѕрограмма инициализации послед.порта, его прерывани€ и буферов дл€ прерывани€.  */

void  Init_timer ( void )
{
  //ќсновной (I/O) таймер
  TCCS_STOP=1;    /* ƒл€ инициализации останавливаем счетчик*/

// 15: TCCS_FRCK = 0 ;   /* внутренний тактовый генератор */
// ...     ...
//  7: TCCS_IVF  = 0;    /* очищаем флаг запроса */
//  6: TCCS_IVFE = 1;    /* разрешение прерывани€ */
//  5: TCCS_STOP = 1;    /* ƒл€ инициализации останавливаем счетчик*/
//  4: TCCS_MODE = 0;    /* инициализаци€ по сбросу или биту CLR */

//  3: TCCS_CLR  = 1;    /* устанавливаем счетчик в 0X0000  */
//  2: TCCS_CLK2 = 1;    /* ƒискрета - 2 мкс */
//  1: TCCS_CLK1 = 0;
//  0: TCCS_CLK0 = 1;

       TCCS = 0x6d;

  TCCS_STOP=0;    // ¬ключаем счетчик

        //   –азрешаем прерывани€ по таймеру.
  ICR04 = 6;      /*  IRQ19
                      IRQ20 */

  //ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒReload timer0ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ

    TMCSR0 =0x80a;  //1000 0000 1010 - 2.0 мкс дискрета, одноразовый, тактируемый

    ICR03 = _RelTimer0_PRIORITY;      /*  IRQ17 */

  //ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒReload timer1ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ

    TMCSR1 =0x80a;  //1000 0000 1010 - 2.0 мкс дискрета, одноразовый, тактируемый

    ICR12 = _RelTimer1_PRIORITY;;      /*  IRQ36 */

  //ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ »нижиализажип вбее ваймеаов ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ
    timer1 = 0,  Timer1_Ovr = 0,  Timer1_fSec = 0 ;

  return   ;
}
/*ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ-  */

__interrupt void Timer_Interrupt (void)
{
  asm_ei();
  TCCS_IVF = 0;   /* очищаем флаг запроса */
  ++Timer1_Ovr;
      /*--------------------------------------------------------------------------
       *    »спользуетс€ дл€ вывода информации на дисплей в режиме "бегущей строки".
       *  »нформаци€ дл€ вывода беретс€ из того же буфера вывода, что и преры-
       *  ванием по TXD, по-этому эти два прерывани€ одновременно не совместимы.
       *  ѕри переходе от вывода по TXD к выводу по прерывани€м по переполнению
       *  Timer1, необходимо:
       *    int_mask1 &=  ~TXD_IntEnable ; - запретить прерывание по TXD ;
       *    Mon.Pult = 1 ;   - установить признак работы с пультом "бегуща€ строка",
       *      что используетс€ дл€ обхода записи "затравки" в TXD из рабочих программ.
       *
       *  ѕри переходе от вывода по Timer1 к TXD, необходимо:
       *    Mon.Pult = 0 ;   - сбросить признак работы с пультом "бегуща€ строка",
       *       что разрешит запись "затравки" в TXD из рабочих программ дл€ запуска
       *       прерываний по TXD ;
       *    int_mask1 |= TXD_IntEnable  ;   - разрешить прерывание по TXD.
       */
       if ( Mon.UartCAN_Connect == 0 )
       {
         if ( Mon.Pult == 1 )
          {
            if ( --Count_SymbolPauza == 0 )  // отсчет паузы между символами
              {
                Count_SymbolPauza = _SymbolPauza ;
                if ( mTestYesData_in_Buff_TXD() )
                  {
                    mSymbol_from_Buff_TXD( SODR1 ) ;
          }   }   }
       }
	return;
}
/*__interrupt void R_Timer_interrupt (void)
{
  TMCSR1_UF = 0;//сбрасываем запрос прерывани€
  mUSEL_not() ;
  _sifu_epa_time( fr2 );
} */

