

/*  Программа инициализации послед.порта, его прерывания и буферов для прерывания.  */

void  Start_RXD_TXD ( void )
{
    byte al ;
  Reg_ServiceMsg   = 0 ;

  Label          = 0x0u    ;

  M_FirstCall    = 1 ;
  Pult_Prog_Addr = 0 ;
  Klav_Buff = 0 ;
  m_old = 0 ;

  Count_SymbolPauza = _SymbolPauza ;

    Mon.Pult  = 1  ;
//    Mon.Parolle = 0  ;
    Mon.EnableSrvMsg = 1 ;
//    Mon.Otkl_InOut = 0 ;

    Mon.i2c_busy = 0 ;
    Mon.RXBuffOverflow = 0 ;

  OutTxBuffCount = 0x0u   ;
  InTxBuffCount  = 0x01u  ;
  OutRxBuffCount = 0x0u   ;
  InRxBuffCount  = 0x01u  ;

  Mon.UartCAN_Connect = 0 ;
  Mon.RX_Data_ok = 0 ;

/*  'HARDWARE' ИНИЦИАЛИЗАЦИЯ  */

 SODR1_FREE = 1 ;

 /* SODR0 */
 al = SIDR1 ; /* чтобы сбросить лишний запрос */

 /* SMR0 */   /* 19230 Baud, 1-stop, no-parity, LSB-first */
 SMR1   = 0x11 ;
 /* MD1 = 0 ,MD0  = 0 ,CS2 = 0 ,CS1 = 1 ,CS0 = 0 ,REZ =  ,SCKE = 0 ,SOE = 1 */

 /* CDCR0 */
 CDCR1  = 0x80 ;
 /* MD = 1 ,REZ = 0 ,REZ = 0 ,REZ = 0 ,DIV3 = 0 ,DIV2 = 0 ,DIV1 = 0 ,DIV0 = 0 */

 /* SCR0 */
 SCR1  =  0x13 ;
 /* PEN = 0 ,P = 0 , SBL = 0 ,CL  = 1 ,AD  = 0 ,REC = 0 ,RXE = 1 ,TXE = 1 */

 /* SSR0 */
 SSR1  =  0x02 ;
 /* PE = 0 ,ORE = 0 , FRE = 0 ,RDRF = 0 ,TDRE = 0 ,BDS = 0 ,RIE = 1 ,TIE = 0 */

/*  Interrupts: is set in vectors.c   */
 ICR13 = 6;  /*  IRQ37   TXD, RXD
                 IRQ38
              */
  asm_ei() ;

  return   ;
}
/*ДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДД-  */

  void  Speed_Pult ( void )
{
    if ( Mon.Pult != 1 )
      {
       /* SSR1_TIE = 0 ;*/
        Mon.Pult = 1 ;  /* устанавливать после запрета прерывания TXD  */
      }
    else
      {
        Mon.Pult = 0 ;  /* устанавливать до разрешения прерывания  TXD  */
       /* SSR1_TIE = 1 ;*/
      }
    Pult_Prog_Addr = _MainPultProg  ;
    return ;
}

      /*   "TXE_BIT" - в режиме TXD признак того, что из буфера вывода все выбрано,
       * прерывания прекратились и сами по себе не возобновятся, даже если в буфере
       * вывода появятся данные => прерывание нужно вызвать искусственно.
       *   Если установлен бит "Mon.Pult" - признак медленного вывода через ЕПА,
       * то вышесказанное неверно и "искусственных" записей в  порт делать не надо.
       */
void   mRestart_Output( void )
{        /* если порт свободен и есть данные на вывод ...  */
    if ( ( SODR1_FREE == 1  ) && ( mTestYesData_in_Buff_TXD() ) )
    {     /*  и пульт не в режиме медленного вывода то запускаем прерывания: */
         /* разрешаем прерыв., а т.к. TDRE всегда взведен, то прерыв. сразу сработает. */
      if ( Mon.Pult == 0 && Mon.UartCAN_Connect == 0 ) SSR1_TIE = 1 ;
    }
  return ;
}
/*ДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДД-  */

/*   П/п обработки прерываний от последовательного порта по приему.
 *  Принятые байты заносятся в буфер 'RxBuff[]' (массив типа 'unsigned char')
 * в ячейку на которую указывает указатель "InRxBuffCount". После записи
 * очередного символа этот указатель увеличивается на единицу, таким образом
 * он всегда указывает на ячейку в которую будет записан следующий байт
 * (т.е. на пустую). Если указатель дошел до конца буфера , то он возвра-
 * щается снова к его началу и так по кругу. Для того чтобы не надо было
 * контролировать достижение
 * указателем конца буфера размер буфера "RxBuffSize+1" принимается равным 2,4,
 * 8,16,32,64,128,256. В этом случае величина указателя не выходит за сетку
 * 1,2,3,4,5,6,7,8-ми младших битов. Поэтому перемещение указателя к следующей
 * позиции осуществляется так:
 *      InRxBuffCount = ( InRxBuffCount + 1 ) & RxBuffSize ;
 * увеличивается на единицу и на него накладывается маска обрезающая ненужные
 * старшие биты. Таким вот образом имитируется 1,2,3,4,5,6,7,8-ми битовое поле
 * сетки указателя и он, дойдя до конца буфера, в результате "переполнения" своей
 * сетки сам возвращается к началу буфера.
 *  Считывание данных из буфера рабочей программой производится посредством
 * указателя "OutRxBuffCount". Организация этого указателя абсолютно идентична
 * вышеописанной. Он всегда указывает на ячейку из которой ранее было произведено
 * считывание (т.е.пустую). По-этому перед считыванием его следует увеличить на
 * единицу операцией :
 *     "OutRxBuffCount = ( OutRxBuffCount + 1 ) & RxBuffSize ;" ,
 * а после этого прочитать байт из буфера. Указатель "OutRxBuffCount" всегда
 * "отстает" от "InRxBuffCount". Перед считыванием данных из буфера следует
 * убедиться , что они там есть. Для этого необходимо проверить не сравняется
 * ли указатель считывания с указателем записи если первый увеличить на единицу.
 * Если оказывается что они в результате этого станут равными - значит буфер пуст.
 *   Аналогично перед записью данных в буфер в прерывании следует убедиться, что в буфере
 * еще оталось место. Для этого необходимо проверить не сравняется ли указатель
 * записи с указателем считывания если первый увеличить на единицу.
 * Если оказывается что они в результате этого станут равными - значит в буфере
 * места нет и принятый байт записывать некуда, при этом устанавливается
 * признак переполнения "Mon.RXBuffOverflow = 1" и принятый байт теряется.
 */
/*    При считывании "sp_stat" сбрасывается все биты кроме TXE, сколько бы
 * Вы его не считывали.
 *    "TXE" сбрасывается только после записи в порт "TX" одного и более
 * символа, т.е. тогда, когда !сдвиговый регистр! на передачу перестает быть
 * пустым.
 *    А устанавливается "TXE" тогда, когда пуст !сдвиговый регистр! на
 * передачу, т.е. он из себя все выпихнул и поле этого в него ничего не
 * провалилось из его аппаратного буфера порта "TX" => пусты и сдвиговый
 * регистр и его буфер.
 *    При пустых сдвиговом регистре и его буфере в порт TX можно записывать
 * подряд без малейшей задержки два символа. Если записать больше, то
 * все остальные кроме первого будут потеряны.
 *
 *  В связи с вышесказанным в "pts-RXD" можно считывать при приеме пословно,
 * т.к. "sbuf_rx" и "sp_stat" расположены рядом и не бояться, что будет
 * закрыта от "TXD" его личная информация, кроме бита "TI", который при
 * работе в режиме прерываний и не нужен.
 */
__interrupt
void RXD_Interrupt (void)
{
  static char al ;

    asm_ei() ;

    if ( SSR1_FRE == 1 || SSR1_ORE == 1 || SSR1_PE == 1 )
    {
      SCR1 &= ~_SCR1_REC ;
      al = SODR1 ; /* чтобы сбросить лишний запрос */
    }
    else
    {
      //if ( Mon.UartCAN_Connect == 0 ) mSymbol_in_Buff_RXD( SIDR1 ) ;
      //else al = SIDR1 ;
      mSymbol_in_Buff_RXD( SIDR1 ) ;
      Mon.RX_Data_ok = 1 ;
    }
    return ;
}
/*---------------------------------------------------*/
/*   Прерывание от последовательного порта по передаче генерируется тогда,
 *  когда из сдвигового регистра начал передаваться последний бит передавае-
 * мого байта.
 *   П/п обработки прерываний от последовательного порта по передаче.
 *  Передаваемый байт заносится предварительно рабочей программой в буфер
 * 'TxBuff[]' (массив типа 'byte')
 * в ячейку на которую указывает указатель "InTxBuffCount". После записи
 * очередного символа этот указатель должен увеличиваться на единицу, таким образом
 * он всегда указывает на ячейку в которую следует заносить следующий байт
 * (т.е. на пустую). Если указатель дошел до конца буфера , то его возвра-
 * щают снова к его началу и так по кругу. Для того чтобы не надо было
 * контролировать достижение
 * указателем конца буфера, размер буфера "TxBuffSize+1" принимается равным 2,4,
 * 8,16,32,64,128,256. В этом случае величина указателя не выходит за сетку
 * 1,2,3,4,5,6,7,8-ми младших битов. Поэтому перемещение указателя к следующей
 * позиции осуществляется так:
 *     "InTxBuffCount = ( InTxBuffCount + 1 ) & TxBuffSize ;"  -  указатель
 * увеличивается на единицу и на него накладывается маска обрезающая ненужные
 * старшие биты. Таким вот образом имитируется 1,2,3,4,5,6,7,8-ми битовое поле
 * сетки указателя и он, дойдя до конца буфера, в результате "переполнения"
 * своей сетки сам возвращается к началу буфера.
 *  Считывание данных из буфера подпрограммой прерывания производится посредством
 * указателя "OutTxBuffCount". Организация этого указателя абсолютно идентична
 * вышеописанной. Он всегда указывает на ячейку из которой ранее было произведено
 * считывание (т.е.пустую). По-этому перед считыванием его следует увеличить на
 * единицу операцией :
 *      OutTxBuffCount = ( OutTxBuffCount + 1 ) & TxBuffSize ;
 * а после этого прочитать байт из буфера и записать его в буфер порта
 * "sbuf_tx" (если он, конечно, свободен).
 * Указатель "OutTxBuffCount" всегда "отстает" от "InTxBuffCount".
 * Перед считыванием в прерывании данных из буфера следует
 * убедиться , что они там есть. Для этого необходимо проверить не сравняется
 * ли указатель считывания с указателем записи, если первый увеличить на единицу.
 * Если оказывается что они в результате этого станут равными - значит буфер пуст.
 *   Аналогично перед записью данных в буфер в рабочей программе следует
 * убедиться, что в буфере еще осталось место. Для этого необходимо проверить
 * не сравняется ли указатель записи с указателем считывания если первый
 * увеличить на единицу. Если оказывается, что они в результате этого станут
 * равными - значит в буфере места нет и принятый байт записывать некуда, при
 * этом следует либо подождать пока место появится, либо проигнорировать это
 * обстоятельство.
 *  Примечание: порт 'TXD' имеет буфер, что позволяет загружать в порт сразу
 * по два байта и, в результате, передавать их друг после друга без малейшей
 * задержки, непрерывной чередой. Это классно, это огромное достоинство. Но
 * это может стать не посилам медленно принимающей стороне и она не будет
 * успевать вынимать принимаемые байты из своего порта и, в результате, терять
 * их. На этот случай предусмотрена возможность запрета записи в буфер порта
 * второго байта, что приведет к появлению некоторой задержки между передачами
 * отдельных байт, равной минимум времени обработки самого прерывания от 'TXD',
 * и это облегчит условия работы принимающей стороны. Запрет осуществляется
 * установкой в единицу признака " Mon.TXD_PoOdnomuBytu ".
 */

__interrupt void TXD_Interrupt (void)
{
  asm_ei() ;

     /*    Пуст и буфер и сдвигающий регистр => запись в порт первого символа
      * (если таковые в буфере есть), который сразу провалится в сдвигающий
      * регистр. */
    if ( mTestYesData_in_Buff_TXD() && Mon.UartCAN_Connect == 0 )
    {
      mSymbol_from_Buff_TXD( SODR1 ) ;
      SODR1_FREE = 0 ;
    }
    else
    {
      SSR1_TIE = 0 ;  /* запрещаем прерывания TXD, т.к. бит запроса  */
      SODR1_FREE = 1 ; /* прерыв. при отсутствии данных ничем не сбрасыв-ся. */
    }
     /* Несброшенный "TXE_BIT" - признак того, что из буфера вывода все выбрано,
      * прерывания прекратились и сами по себе не возобновятся, даже если в
      * буфере вывода появятся данные.
      * Если в буфере вывода снова появится информация, то чтобы возобновить
      * череду прерываний для ее вывода в порт, необходимо "искусственно"
      * вызвать прерывание. */
  return   ;
}
