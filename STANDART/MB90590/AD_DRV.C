

//     ПРОГРАММА ЗАПУСКА АЦП НА ИЗМЕРЕНИЕ.
//     Т.к. время преобразования АЦП всего 6мксек то прерывания
//  по готовности АЦП и организация очереди при наложении измерений
//  не предусматриваются.
//--------------------------------------------------------

  //  Программа инициализации АЦП без его прерывания и буферов для прерывания.

void  Start_AD ( void )
  {
    OutAdBuffCount = 0 ;
    InAdBuffCount  = 1 ;
    Flg.NoAdBuffInfo  = 1 ;

         // Настройка pin-ов, как дискретных входов.
    DDR6 = 0x00 ;
         // Донастройка pin-ов, как аналоговых входов.
    ADER = 0xFF ;

         //  Настройка времени захвата 4.0мкс и преобразования 22 мкс АЦП.
    ADCR  = 0x0800 ;
     // S10=0 ,ST1=0 ,ST0=0 ,CT1=0 ,CT0=1 ,RES=0 ,D9...D0=0

    ADCS1_INTE = 1; // Разрешение прерывания по АЦП

    ICR10 = 3;      /*  IRQ31      -прерывание по АЦП
                        IRQ32 */

    return ;
 }

/*   Функция для запуска измерения - использует внутри себя аналогичный
 * макрос - из-за чего ремя ее выполнения больше, чем макроса, но затраты
 * памяти при ее использовании меньше ( экономится 105 байт на один вызов ).
 *   Ее имеет смысл использовать в программах не требовательных ко времени.
 */
void  AD_Izm( struct Channel_AD ach , word* AddrResult )
{
  mAD_Izm( ach , AddrResult ) ;
  return ;
}
/*   П/п обработки прерываний от АЦП.
 *  Прерыванием от АЦП используются два буфера:  "AdBuff_AddrResult[]" и
 * "AdBuff_Command[]". В первый из них рабочей програмой заносятся адреса
 * ячеек, в которые необходимо помещать результаты измерений АЦП, а во
 * втором - управляющие слова для мультиплексора АЦП, которыми в случае
 * наличия очереди измерений подключается нужный канал мультиплекора и АЦП
 * тут же из прерывания запускается на новое измерение.
 *  Рабочая программа, при необходимости измерения, посредством специальной
 * п/п заносит в свободные ячейки буферов, на которые указывает указатель
 * "InAdBuffCount" необходимые для измерения данные: управляющее слово
 * мультиплексора и адрес ячейки, в которую необходимо будет положить
 * результат измерения. После очередной записи в буфера этот указатель
 * должен увеличиваться на единицу, таким образом он всегда указывает на
 * ячейки в которые следует заносить, при необходимости, данные для
 * следующего измерения. Если указатель дошел до конца буфера , то его
 * возвращают снова к его началу и так по кругу. Для того чтобы не надо было
 * контролировать достижение указателем конца буфера, размер буфера
 * "AdBuffSize+1" принимается равным 2,4,8,16,32,64,128,256. В этом случае
 * величина указателя не выходит за сетку 1,2,3,4,5,6,7,8-ми младших битов.
 * Это позволяет перемещать указатель к следующей позиции с наименьшими
 * затратами времени следующим образом:
 *     "InAdBuffCount = ++InAdBuffCount & AdBuffSize ;"  -  указатель
 * увеличивается на единицу и на него накладывается маска обрезающая ненужные
 * старшие биты. Таким вот образом имитируется 1,2,3,4,5,6,7,8-ми битовое поле
 * сетки указателя и он, дойдя до конца буфера, в результате "переполнения"
 * своей сетки сам возвращается к началу буфера.
 *   Вышесказанное относится к случаю когда при необходимости сделать измерение
 * оказывается, что АЦП занят т.е. существует очередь. В случае же когда очередь
 * исчерпана и АЦП свободен, признаком чего является взведенный бит "Flg.NoAdBuffInfo"
 * (см.ниже),  рабочая программа, при необходимости измерения, должна
 * сама по управляющему слову мультиплексора подключить нужный канал и запустить
 * АЦП, а адрес ячейки, в которую необходимо будет положить результат измерения,
 * занести в буфер адресов по индексу "OutAdBuffCount", а не "InAdBuffCount"
 * т.к управляющее слово заносилось прямо в АЦП, а не в очередь.
 *  Считывание данных из буфера очереди подпрограммой прерывания производится посредством
 * указателя "OutAdBuffCount". Организация этого указателя абсолютно идентична
 * вышеописанной.
 * Указатель "OutAdBuffCount" всегда "отстает" от "InAdBuffCount".
 * Перед считыванием в прерывании данных из буфера для инициации следующего
 * измерения следует убедиться, что они там есть, т.е. что очередь существует.
 * Для этого необходимо проверить не сравняется ли указатель считывания с
 * указателем записи, если первый увеличить на единицу. Если оказывается что
 * они в результате этого станут равными - значит буфер пуст, очереди нет и
 * данных для следующего измерения нет. При этом взводится признак
 * "Flg.NoAdBuffInfo" указывающий но то, что очередь пуста и отработало последнее
 * прерывание от АЦП. При этом если рабочей программе необходимо будет
 * произветси измерение, она должна сама по управляющему слову мультиплексора
 * подключить нужный канал и запустить АЦП, а адрес ячейки, в которую
 * необходимо будет положить результат измерения, занести в буфер адресов по
 * индексу "OutAdBuffCount", а не "InAdBuffCount" т.к управляющее слово зано-
 * силось прямо в АЦП, а не в очередь.
 *   Аналогично перед записью данных в буфер измерений в рабочей программе следует
 * убедиться, что в буфере еще осталось место. Для этого необходимо проверить
 * не сравняется ли указатель записи с указателем считывания если первый
 * увеличить на единицу. Если оказывается, что они в результате этого станут
 * равными - значит в буфере места нет и принятый байт записывать некуда, при
 * этом следует либо подождать пока место появится, либо проигнорировать это
 * обстоятельство.
 */
__interrupt void AD_Interrupt (void)
{

        //  Поместить результат измерения по заданному адресу.
      *AdBuff_AddrResult [(w)OutAdBuffCount] = ADCR & ~_AD_BUSY ;
         //  Есть ли данные в буфере очереди ?
      if ( ((OutAdBuffCount + 1) & AdBuffSize) != InAdBuffCount )
        {      // Очередь есть.
          OutAdBuffCount = ++OutAdBuffCount & AdBuffSize ;
            // Запуск АЦП по следующему в очереди управляющему слову.
            mSet_MUX( AdBuff_Command [(w)OutAdBuffCount] >> 8 )  ;
          ADCS0 = ((b) AdBuff_Command [(w)OutAdBuffCount] & 0x07) |
                 (((b) AdBuff_Command [(w)OutAdBuffCount] & 0x07) << 3) ;
          ADCS1 = 0xA2   ;
        }
      else
        {      //  Измерения закончились и Очереди нет.
          Flg.NoAdBuffInfo = 1 ;  // Установка флага свободности АЦП.
          ADCS1_INT =0;
        }
      return  ;
}
