#ifndef _ad_drv_h
#define _ad_drv_h
//---------------

extern void  Start_AD ( void ) ;
extern __interrupt void AD_Interrupt (void);

#define AdBuffSize            ((b) 0x0f)  /* все мл.разряды в указателе
                                           * размера должны быть запол-
                                           * нены единицами    */


struct Channel_AD {  word mux  ;
                     word offset ; } ;

/*  Для AD Convereter  */

#define  _AD_BUSY  ( 0x8000 ) // можно задать любой бит старше D9...D0.

#define  _AD_MAX   ( 511 )
#define  _AD_VOLT  ( 205 ) // дискрет на 1вольт
#define  _AD_VOLT_DVUPOL ( 102 )

#define  _AD_MaxOffset  ( 1023 )
#define  _AD_Delta      ( 1 )

#define  _Open_AD_BUFFERs

//----------------------------------------------
//     Т.к. время преобразования АЦП всего 6мксек то прерывания
//  по готовности АЦП и организация очереди при наложении измерений
//  не предусматриваются, НО ИММИТИРУЕТСЯ ВИДИМОСТЬ ЭТОГО ДЛЯ СОВМЕСТИМОСТИ
//  С ПРОГРАММАМИ MCS196.

/*   П/п запуска АЦП на измерение либо, при занятости АЦП, занесения измерения
 * в очередь. При этом используются два буфера:  "AdBuff_AddrResult[]" и
 * "AdBuff_Command[]". В первый из них рабочей программой заносятся адреса
 * ячеек, в которые необходимо помещать результаты измерений АЦП, а во
 * второй - управляющие слова для мультиплексора АЦП, которыми в случае
 * наличия очереди измерений подключается нужный канал мультиплекора и АЦП
 * тут же из прерывания будет запускаться на новое измерение.
 * Вышесказанное относится к случаю когда при необходимости сделать измерение
 * оказывается, что АЦП занят т.е. существует очередь. В случае же когда очередь
 * исчерпана и АЦП свободен, признаком чего является взведенный бит "Flg.NoAdBuffInfo"
 * (см.ниже),  рабочая программа, при необходимости измерения, должна
 * сама по управляющему слову мультиплексора подключить нужный канал и запустить
 * АЦП, а адрес ячейки, в которую необходимо будет положить результат измерения,
 * занести в буфер адресов по индексу "OutAdBuffCount", а не "InAdBuffCount"
 * т.к управляющее слово заносилось прямо в АЦП, а не в очередь.
 *  Считывание данных из буфера очереди подпрограммой прерывания производится
 * посредством указателя "OutAdBuffCount". Организация этого указателя
 * абсолютно идентична вышеописанной.
 *   Перед записью данных в буфер измерений в рабочей программе следует
 * убедиться (чего с целью экономии времени не сделано), что в буфере еще
 * осталось место. Для этого необходимо проверить
 * не сравняется ли указатель записи с указателем считывания если первый
 * увеличить на единицу. Если оказывается, что они в результате этого станут
 * равными - значит в буфере места нет и принятый байт записывать некуда, при
 * этом следует либо подождать пока место появится, либо проигнорировать это
 * обстоятельство.
 */
     /*   Благодаря макросу сокращается 9 команд передачи параметров.
      *
      *   На время операций с буферами во избежание накладок запрещаются
      * прерывания.
      *   В связи с этим установку контрольного бита готовности в ячейке
      * результата надо делать до входа в подпрограмму и НЕЛЬЗЯ после "ei",
      * т.к. тут же после "ei" программа может сразу же вскочить в прерывание
      * за его время АЦП досчитает, запишет в ячейку результат, а мы его
      * сбросим и будем долго ждать у моря погоды.
 * * **
 *
 * struct Channel_AD ach - имя структуры данных для канала АЦП по которому
 *              производится измерение; из этой структуры макрос извлечет
 *              управляющее слово для мультиплексоров данного канала.
 * word* AddrResult - адрес ячейки в которую следует поместить результат
 *                    этого измерения.
 */

   //   _Port_MuxAD = (b) ( (ach).mux >> 8 ) ;                    \
   //   for( RL = (b)timer1; (b)((b)timer1 - RL) < _r.AD_pause;); \

      //   Макрос запуска и ожидания готовности измерения, с помещением
    //  необработанного результат измерения в заданную переменную.

   // ADCS0:-> MD1=0 ,MD0=0 ,ANS2...ANS0=channel ,ANE2...ANE0=channel

   // ADCS1:-> BUSY=1 ,INT=0 ,INTE=0 ,PAUS=0 ,STS1=0 ,STS0=0 ,STRT=0 ,RESV=0

/*#define mAD_Izm( ach , AddrResult )  asm_di() ;    \
      ADCS0  = ((b)(ach).mux & 0x07) | (((b)(ach).mux & 0x07) << 3) ; \
        ADCS1 = 0x82   ;                           \
      while( ADCS1_INT == 0 ) ;                    \
        ADCS1_INT = 0 ;                            \
      *AddrResult = ADCR & ~_AD_BUSY;              \
  asm_ei() ;                                       \
  asm_nop()
/* конец макроса  */

     // Для приложений где нет внешнего мультиплексора.
#ifndef  mSet_MUX
  #define mSet_MUX( num )
#endif

#define mAD_Izm( ach , AddrResult )  asm_di() ;                 \
  if ( Flg.NoAdBuffInfo != 0 )                                  \
    {                                                           \
      Flg.NoAdBuffInfo = 0 ;                                    \
      AdBuff_AddrResult [(w)OutAdBuffCount] = ( AddrResult );   \
        mSet_MUX( (ach).mux >> 8 )  ;                           \
      ADCS0  = ((b)(ach).mux & 0x07) | (((b)(ach).mux & 0x07) << 3) ; \
      ADCS1 = 0xA2   ;                           \
    }                                                           \
  else                                                          \
    {                                                           \
      AdBuff_AddrResult [(w)InAdBuffCount] = ( AddrResult );    \
      AdBuff_Command    [(w)InAdBuffCount] = (ach).mux  ;       \
      InAdBuffCount  = ++InAdBuffCount & AdBuffSize ;           \
    }                                                           \
  asm_ei() ;                                                    \
  asm_nop()

//-------------------------
     /*   АЦП 10-разрядный однополярный. Для измерения двухполярных
      * сигналов сигнал на входе АЦП смещен вверх, примерно, на пол-питания,
      * поэтому после преобразования необходимо вычитать из результата
      * смещение "_r.IzmSmech" равное, примерно, пол-шкалы АЦП.
      *   Вычитание производится таким образом, чтобы получить положитель-
      * ный модуль результата измерения.
      *   В итоге преобразования получаем стандартное знаковое двухбайтное
      * число.
 * * **
 *
 * word  src  - источник: преобразуемый результат измерения в формате
 *                        регистра АЦП "ad_result";
 * word  dest - адресат: ячейка в которую следует поместить результат
 *                       этого преобразования.
 * struct Channel_AD ach - имя структуры данных для канала АЦП по которому
 *              производится измерение; из этой структуры макрос извлечет
 *              смещение для данного канала АЦП.
 */

     // ADCR:-> S10=0 ,ST1=0 ,ST0=1 ,CT1=1 ,CT0=0 ,RES=0 ,D9...D0=0
        /* преобразование со своим смещением в знаковое  */
#define  mIzmData_Conversion( src , dest , ach )  dest = ( (w)(src) & 0x3FF ) - (ach).offset
/* конец макроса  */


/*------------------------------------------------*/
#ifdef   _MAIN_INCLUDE
/*------------------------------------------------*/

  word  t_mux ;

/*------------------------------------------------*/
#else
/*------------------------------------------------*/

  extern  word  t_mux ;

/*------------------------------------------------*/
#endif
#endif
