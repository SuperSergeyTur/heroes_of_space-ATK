
//  Для Fujitsu 21-11-2002
/*  Справка:
  Осталась некорректность в xInit_msgP( word cmd, byte port, byte n_obj, MO_id ):
  - объекты для передачи подготовлены, но DATA[0,...,7] НЕ ГОТОВА.
    (просто для передатчика это не страшно, т. к. при передаче подготовятся,
    но если будет запрос удаленного фреймв к этому МО, - получат ложные данные).

в Load_ptr(byte port, int buf,struct canMSG_Fuj *ptr) готовим данные
   IDRX0(buf) = ptr->id ; (это лишнее)
   DLCR0(buf) = ptr->cfg.dlen ;
   DTR0 - данные
   ВОЗВРАЩАЕТ всегда 0

в Save_ptr(byte port, int buf,struct canMSG_Fuj *ptr) считываем данные
   ptr->id = IDRX0(buf) & _ID11 ;
   ptr->cfg.dlen = DLCR0(buf) ;
   ptr->data[i] = DTR0_BYTE(buf,i) ;
   ВОЗВРАЩАЕТ всегда 0

в canSend( byte port , struct canMSG_Fuj *ptr ) отправляем данные
  - "перекручиваем" buff.lax ( ptr->id не трогаем )
  - Load_ptr()
  - IDRX0(i) = buff.lax;
   ВОЗВРАЩАЕТ 0/1 - взвели/нет TREQR0i для передачи

в canReceive( byte port , struct canMSG_Fuj *ptr ) прием данных
   - проверяется RCRi, при получении данных:
   - Save_ptr();
   - проверяется ROVRR ( при потере сообщения инкрементируем счетчик ошибок
     и повторяем Save_ptr() );
   - "перекручиваем" ptr->id (чтобы в ptr лежал ID в "явном" виде).
   ВОЗВРАЩАЕТ 1/0 - приняты/нет данных

    АПР-овские функции:

в xSend_msg( byte port, byte n_obj, struct canMSG_Fuj *ptr ) отправляем данные
  - "перекручиваем" buff.lax ( ptr->id не трогаем )
  - Load_ptr()
  - IDRX0(n_obj) = buff.lax;
  - взводим TREQR0i для передачи;
   ВОЗВРАЩАЕТ 0/1 - взвели/нет TREQR0i для передачи

в xRead_msg( byte port, byte n_obj, struct canMSG_Fuj *ptr ) прием данных
   - Save_ptr();
   - проверяется ROVRR ( при потере сообщения инкрементируем счетчик ошибок
     и повторяем Save_ptr() );
   - "перекручиваем" ptr->id (чтобы в ptr лежал ID в "явном" виде).
   ВОЗВРАЩАЕТ 1/0 - есть/нет новые данные

в xInquire_msg( byte port, byte n_obj, struct canMSG_Fuj *ptr ) отправляем запрос
  - xSend_msgP()
   ВОЗВРАЩАЕТ то же, что и xSend_msgP()

в xWrite_msgP( byte port, byte n_obj, struct canMSG_Fuj *ptr )
  подготовка данных к ответу на зпрос
  - при отсутствии запроса передачи TREQR0i выполняется
  - Load_ptr(), - обновляются данные
   ВОЗВРАЩАЕТ 1/0 есть/нет условия для обновления данных


1505205
Непонятно:
1.          в Load_ptr(port,14,ptr); есть строка
            IDRX0(14) = ptr->id;
            а после вызова Load_ptr идет следом строка
            IDRX0(14) = buff.lax;
            где buff.lax - это "перекрученный" ptr->id
2.          В canReceive() имеем вызов Save_ptr, где есть строка
            ptr->id = IDRX0(buf) & _ID11 ;
            а далее в canReceive() "перекрутка" в ptr->id?
*/

/* 14062005
1.  НЕ ИСПОЛЬЗУЮТСЯ МО0 и МО15 !!!
(чтобы использовались все объекты для стандартного протокола необходимо брать
для приема МО0, МО1, МО2 (а не МО1, МО2, МО3) и для передачи МО14, МО15
(а не МО13, МО14) );
А вообще-то правильно три приемника МО0, МО1, МО2 "подвинуть" к МО14, МО15,
т. е. для стандартного протокола использовать МО11-МО15, тогда для "АПР-овских"
объектов остаются МО0-МО10

 2. В "canReceive" непонятка с "ret" - надо ли "выворачивать" ID или нет.

 3. Не везде "доделано" для CAN1 формирование буфера из объектов МО2 и МО3

 4. Получается, что у Fuj объект для передачи фрейма данных ничем не
    отличается от приемника (нет DIR = 0/1 как у 196), - поэтому получается
    что для получения данных от универсального протокола (посылка кода
    чтения и индекса переменной и получения ответа) необходим дополнительный
    объект сообщения, при передаче которого необходимо обновлять буфер
    данных, т. к. при приеме данных требуемые для передачи данные теряются.


*/
//--------------------
//      ИНИЦИАЛИЗАЦИЯ ОБЪЕКТОВ СООБЩЕНИЙ  CAN.

 word  can_config ( byte port )
{
register union
{
  lword lax ;
  byte  b[4] ;
} buff ;
register byte ah ;
//register lword lax ;

//        port = port ;// для устранения предупр. о неиспользов. "port"

        if (port == 0)
        {
//196   can_con = 0x01;// Остановить контроллер CAN.
        can0_con = 1  ; // Остановить контроллер CAN.
        CSR0_TOE = 0 ; // Pin - "не CAN", а общего назначения

/*      MsgVal = 0 - нет доступа к объекту сообщения;
        TXIE   = 0 - нет разрешения прерывания по передаче;
        RXIE   = 0 - нет разрешения прерывания по приему;
        IntPnd = 0 - нет отложенного прерывания у данного объекта сообщения;
*/
/*      RmtPnd = 0 - не было удаленного запроса для объекта сообщения;
        TX_REQ = 0 - не задана передача объекту;
        MsgLst = 0 - нет потерянных принимаемых сообщений;
        ( CPUUpd ) - ( передающему объекту разрешена передача );
        NewDat = 0 - не записывалась никакая информация в сегмент данных;
*/

#ifdef   _CAN_SHARED  //  CAN-используется и другими программами, по-этому
                     //  msg4...msg12 не переинициализируем.
        BVALR0_BVAL1  = 0 ;//выключить 1-й объект сообщения
        BVALR0_BVAL2  = 0 ;//выключить 2-й объект сообщения //vmz
        BVALR0_BVAL3  = 0 ;//выключить 3-й объект сообщения //vmz
        BVALR0_BVAL4  = 0 ;//выключить 1-й объект сообщения
        BVALR0_BVAL5  = 0 ;//выключить 2-й объект сообщения //vmz
        BVALR0_BVAL6  = 0 ;//выключить 3-й объект сообщения //vmz
        BVALR0_BVAL13 = 0 ;//выключить 13-й объект сообщения
        BVALR0_BVAL14 = 0 ;//выключить 14-й объект сообщения
#else
           //  CAN-используется только этой программой.
        BVALR0 = 0 ; //все объекты сообщений отключены
#endif

// ****************************************************************************
          //настройка MO15 - прием
            // формируем свой ID.
        buff.lax = SetOwn_ID( port , can_setting(port).addr ) ;
         ah        = buff.b[3] ;
         buff.b[3] = buff.b[0] ;
         buff.b[0] = ah ;
         ah        = buff.b[2] ;
         buff.b[2] = buff.b[1] ;
         buff.b[1] = ah ;

        can0_msg1id = buff.lax ;
        can0_msg2id = buff.lax ; //vmz
        can0_msg3id = buff.lax ; //vmz

        buff.lax = SetOwn_ID( port , can_setting(port).addr_p ) ;
         ah        = buff.b[3] ;
         buff.b[3] = buff.b[0] ;
         buff.b[0] = ah ;
         ah        = buff.b[2] ;
         buff.b[2] = buff.b[1] ;
         buff.b[1] = ah ;

        can0_msg4id = buff.lax ;
        can0_msg5id = buff.lax ; //vmz
        can0_msg6id = buff.lax ; //vmz
      //---------
//196   can_msg15cfg  = _DIR_RECEIVE ;//прием
        IDER0  = 0 ; //все объекты - СТАНДАРТНЫЙ ФРЕЙМ
        TRTRR0 = 0 ; //все объекты - DATA FRAME (не REMOTE FRAME)
//        RFWTR0 = 0 ; //все объекты ожидают удаленного фрейма
        RFWTR0 = 0 ; //немедленная передача фрейма данных после установки
        TIER0 = 0x0000Ul ;

#ifdef _CAN_SLAVE_IRQ
        RIER0 = 0x007EUl ; // 0000 0000 0111 1110
        ICR01 = 6;
#else
        RIER0 = 0x0000Ul ;
        ICR01 = 7;
#endif

// ****************************************************************************
/*      маски: маскируются нулями. */
/*      маски: стандартная - выключена, расширенная - выключена; */

//196   can_sgmsk = 0xffffUl;
        //vmz AMSR0  = 0xfffffffBUl; //для всех объектов принимать маску AMR1,
                               //кроме 1(15)-го объекта сообщений (AMR0)
        AMSR0  = 0xffffEAABUl; //vmz для всех объектов принимать маску AMR1,
                               //кроме 1(15),2,3-го объекта сообщений (AMR0)
        AMRX00 = 0x00000000Ul; // "0" - нет маски AMR00 - для стандартного
        AMRX10 = 0x00000000Ul; // "0" - нет маски AMR10 - для стандартного

        //если делать для остальных МОi без маскирования (независимо от AMRXi)
        //AMSR0  = 0x000000A8Ul; //vmz для всех объектов нет маски,
                               //кроме 1(15),2,3-го объекта сообщений (AMR0)

/*      маски: локальная. */

//196   can_msg15con0 = Set_MsgVal;
        BVALR0_BVAL1 = 1 ;//включить 1-й (15-й) объект сообщения
        BVALR0_BVAL2 = 1 ;//включить 2-й объект сообщения vmz
        BVALR0_BVAL3 = 1 ;//включить 3-й объект сообщения vmz
        BVALR0_BVAL4 = 1 ;//включить 1-й (15-й) объект сообщения
        BVALR0_BVAL5 = 1 ;//включить 2-й объект сообщения vmz
        BVALR0_BVAL6 = 1 ;//включить 3-й объект сообщения vmz

//196   can_msg15con0 = Set_RXIE;


      //---------

       //настройка MO14 - передача
//196   can_msg14cfg  = _DIR_SEND ;//передача для "универсального" обмена

//196   can_msg14con0 = Set_MsgVal;
        can0_msg14id = 0 ;  //  чтобы у 14-го и 13-го не было одинаковых 'id'.
        BVALR0_BVAL14 = 1 ;//включить 14-й объект сообщения
    //    can_msg14con0 = Set_TXIE;

       //настройка MO13 - передача, если занят MO14
//196   can_msg13cfg  = _DIR_SEND ;//передача для "универсального" обмена
//196   can_msg13con0 = Set_MsgVal;
        can0_msg13id = 1 ;  //  чтобы у 14-го и 13-го не было одинаковых 'id'.
        BVALR0_BVAL13 = 1 ;//включить 13-й объект сообщения
    //    can_msg13con0 = Set_TXIE;

            //  формируем свою маску.
        buff.lax = SetOwn_Mask( port ) ;

          //asm  xchb lax   ,lax+3 ;
          //asm  xchb lax+1 ,lax+2 ;
         //buff.lax = lax ;
         ah        = buff.b[3] ;
         buff.b[3] = buff.b[0] ;
         buff.b[0] = ah ;
         ah        = buff.b[2] ;
         buff.b[2] = buff.b[1] ;
         buff.b[1] = ah ;
        //lax = ~buff.lax ;
//196    can_msk15 = lax ;
        //AMRX00 = ~buff.lax ; // маска для 1-го объекта
        AMRX00 = ~buff.lax ; // маска для 1-го, 2-го и 3-го объектов vmz
//--------------------------------------------------------------------------
//        Разрешить модернизацию регистров синхронизации

//196   can_con = 0x41;//Разрешить модернизацию регистров синхронизации

//      три выборки, BRP, TSEG1, TSEG2 = 3; => V = 210 000
//      can_btime0 = 0x43;
//      can_btime1 = 0xff;//b3;
//      три выборки, BRP=0, TSEG1=2, TSEG2 =1; SPL=1 => V =1 112 000

//      can_btime0 = 0xc0;//    0       0       921 000
//      can_btime1 = 0x94;//    1       4       --------

//      Задать скорость CAN-узла = 800 000 бит/сек
//**********************************************************
//      Внимание! У ADAM-4525 это соответствует 1600H
//**********************************************************
//      Задать скорость CAN-узла = 400 000 бит/сек
//**********************************************************
//      Внимание! У ADAM-4525 это соответствует 1601H
//**********************************************************

//      Задать скорость CAN-узла = 125 000 бит/сек
//**********************************************************
//      Внимание! У ADAM-4525 это соответствует 1C03H
//**********************************************************/
        //can_btime0 = 0x00;//    0       0       400 000
        //can_btime1 = 0x7d;//    7       13      --------

// ОЧИСТИТЬ НАКОПИВШИЕСЯ ЗАПРОСЫ ПРЕРЫВАНИЙ.

//196 can_btime0 = can_setting(port).btime0 ; //    0       4       125 000
//196 can_btime1 = can_setting(port).btime1 ; //    7       6       --------

          // задание типовых скоростей.
      if ( can_setting(port).config._.bt_125k == 1 )
      {
        BTR0 =  (w)bt_125k.bt0 | ((w)bt_125k.bt1 << 8);
      }
      else if ( can_setting(port).config._.bt_250k == 1 )
      {
        BTR0 =  (w)bt_250k.bt0 | ((w)bt_250k.bt1 << 8);
      }
      else if ( can_setting(port).config._.bt_1M == 1 )
      {
        BTR0 =  (w)bt_1M.bt0 | ((w)bt_1M.bt1 << 8);
      }
      else // если не задана типовая скорость - задаем скорость пользователя.
      {
        BTR0 =  (w)can_setting(port).btime0 | ((w)can_setting(port).btime1 << 8);
      }

        //Запретить модернизацию регистров синхронизации и запустить контроллер.
//196 can_con = 0x0 ;//0x01;
      CSR0_TOE = 1 ; // Pin - для передачи по CAN

        //Запретить модернизацию регистров синхронизации и запустить контроллер.
      if ( can_setting(port).config._.vkl == 1 )
      {
        can_reInit(port) = 0 ;
        can0_con = 0 ; // Включить контроллер CAN.
      }
      else
      {
        can_reInit(port) = 1 ;
        can0_con = 0x01 ;
      }
    }
    else
    {
        can1_con = 1  ; // Остановить контроллер CAN1.
        CSR1_TOE = 0 ; // Pin - "не CAN", а общего назначения

#ifdef   _CAN_SHARED  //  CAN-используется и другими программами, по-этому
                     //  msg1...msg12 не переинициализируем.
        BVALR1_BVAL1  = 0 ;//выключить 1-й объект сообщения
        BVALR1_BVAL2  = 0 ;//выключить 2-й объект сообщения //vmz1
        BVALR1_BVAL3  = 0 ;//выключить 3-й объект сообщения //vmz1
        BVALR1_BVAL4  = 0 ;//выключить 4-й объект сообщения
        BVALR1_BVAL5  = 0 ;//выключить 5-й объект сообщения //vmz1
        BVALR1_BVAL6  = 0 ;//выключить 6-й объект сообщения //vmz1
        BVALR1_BVAL13 = 0 ;//выключить 13-й объект сообщения
        BVALR1_BVAL14 = 0 ;//выключить 14-й объект сообщения
#else
           //  CAN-используется только этой программой.
        BVALR1 = 0 ; //все объекты сообщений отключены
#endif

// ****************************************************************************
          //настройка MO1 - прием
            // формируем свой ID.
        buff.lax = SetOwn_ID( port , can_setting(port).addr) ;

         ah        = buff.b[3] ;
         buff.b[3] = buff.b[0] ;
         buff.b[0] = ah ;
         ah        = buff.b[2] ;
         buff.b[2] = buff.b[1] ;
         buff.b[1] = ah ;

        can1_msg1id = buff.lax ;
        can1_msg2id = buff.lax ; //vmz1
        can1_msg3id = buff.lax ; //vmz1

          //настройка MO1 - прием
            // формируем свой ID.
        buff.lax = SetOwn_ID( port , can_setting(port).addr_p) ;

         ah        = buff.b[3] ;
         buff.b[3] = buff.b[0] ;
         buff.b[0] = ah ;
         ah        = buff.b[2] ;
         buff.b[2] = buff.b[1] ;
         buff.b[1] = ah ;

        can1_msg4id = buff.lax ;
        can1_msg5id = buff.lax ; //vmz1
        can1_msg6id = buff.lax ; //vmz1

      //---------
        IDER1  = 0 ; //все объекты - СТАНДАРТНЫЙ ФРЕЙМ
        TRTRR1 = 0 ; //все объекты - DATA FRAME (не REMOTE FRAME)
        RFWTR1 = 0 ; //немедленная передача фрейма данных после установки
        TIER1  = 0x0000Ul ;

#ifdef _CAN_SLAVE_IRQ
        RIER1 = 0x007EUl ; // 0000 0000 0111 1110
        ICR02 = 6;
#else
        RIER1 = 0x0000Ul ;
        ICR02 = 7;
#endif

// ****************************************************************************
/*      маски: маскируются нулями. */
/*      маски: стандартная - выключена, расширенная - выключена; */

        //AMSR1  = 0xfffffffBUl; //для всех объектов принимать маску AMR1,
                               //кроме 1(15)-го объекта сообщений (AMR0)
        AMSR1  = 0xffffEAABUl; //vmz1 для всех объектов принимать маску AMR1,
                               //кроме 1(15),2,3-го объекта сообщений (AMR0)
        AMRX01 = 0x00000000Ul; // "0" - нет маски
        AMRX11 = 0x00000000Ul; // "0" - нет маски

        //если делать для остальных МОi без маскирования (независимо от AMRXi)
        //AMSR1  = 0x000000A8Ul; //vmz1 для всех объектов нет маски,
                               //кроме 1(15),2,3-го объекта сообщений (AMR0)

/*      маски: локальная. */

        BVALR1_BVAL1 = 1 ;//включить 1-й (15-й) объект сообщения
        BVALR1_BVAL2 = 1 ;//включить 2-й объект сообщения vmz1
        BVALR1_BVAL3 = 1 ;//включить 3-й объект сообщения vmz1
        BVALR1_BVAL4 = 1 ;//включить 1-й (15-й) объект сообщения
        BVALR1_BVAL5 = 1 ;//включить 2-й объект сообщения vmz1
        BVALR1_BVAL6 = 1 ;//включить 3-й объект сообщения vmz1

      //---------

       //настройка MO14 - передача
        can1_msg14id = 2 ;  //  чтобы у 14-го и 13-го не было одинаковых 'id'.
        BVALR1_BVAL14 = 1 ;//включить 14-й объект сообщения

       //настройка MO13 - передача, если занят MO14
        can1_msg13id = 3 ;  //  чтобы у 14-го и 13-го не было одинаковых 'id'.
        BVALR1_BVAL13 = 1 ;//включить 13-й объект сообщения

            //  формируем свою маску.
        buff.lax = SetOwn_Mask( port ) ;

         ah        = buff.b[3] ;
         buff.b[3] = buff.b[0] ;
         buff.b[0] = ah ;
         ah        = buff.b[2] ;
         buff.b[2] = buff.b[1] ;
         buff.b[1] = ah ;

        //AMRX01 = ~buff.lax ; // маска для 1-го объекта
        AMRX01 = ~buff.lax ; // маска для 1-го, 2-го и 3-го объектов vmz1
//--------------------------------------------------------------------------
//        Разрешить модернизацию регистров синхронизации


//      Задать скорость CAN-узла = 800 000 бит/сек
//**********************************************************
//      Внимание! У ADAM-4525 это соответствует 1600H
//**********************************************************
//      Задать скорость CAN-узла = 400 000 бит/сек
//**********************************************************
//      Внимание! У ADAM-4525 это соответствует 1601H
//**********************************************************

//      Задать скорость CAN-узла = 125 000 бит/сек
//**********************************************************
//      Внимание! У ADAM-4525 это соответствует 1C03H
//**********************************************************/
          // задание типовых скоростей.
      if ( can_setting(port).config._.bt_125k == 1 )
      {
        BTR1 =  (w)bt_125k.bt0 | ((w)bt_125k.bt1 << 8);
      }
      else if ( can_setting(port).config._.bt_250k == 1 )
      {
        BTR1 =  (w)bt_250k.bt0 | ((w)bt_250k.bt1 << 8);
      }
      else if ( can_setting(port).config._.bt_1M == 1 )
      {
        BTR1 =  (w)bt_1M.bt0 | ((w)bt_1M.bt1 << 8);
      }
      else // если не задана типовая скорость - задаем скорость пользователя.
      {
        BTR1 =  (w)can_setting(port).btime0 | ((w)can_setting(port).btime1 << 8);
      }

        //Запретить модернизацию регистров синхронизации и запустить контроллер.
      CSR1_TOE = 1 ; // Pin - для передачи по CAN

        //Запретить модернизацию регистров синхронизации и запустить контроллер.
      if ( can_setting(port).config._.vkl == 1 )
      {
        can_reInit(port) = 0 ;
        can1_con = 0 ; // Включить контроллер CAN.
      }
      else
      {
        can_reInit(port) = 1 ;
        can1_con = 0x01 ;
      }
    }

//      Конец инициализации для CAN;

      //can_dd[port].Error   = 0 ;
      can_dd[port].Avar    = 0 ;
      can_dd[port].Error_send = 0 ;
      can_dd[port].Error_receive = 0 ;
      can_dd[port].Can_stop= 0 ;

        return 0 ;
}
//-------------------------------------------------

word    can_test ( byte port )
{
  if (port==0)
  {
    //    для CAN 0
    // Выключить контроллер CAN и программы.
  if ( tst_can_stop(port) == 1 )
    {    // для возможности работы с CAN из монитора без рабочей программы.
      if ( can_reInit(port) == 0 )
      {
        can_reInit(port) = 1 ; // Для автоматического срабатывания переинициализации.
        can0_con = 1;// Остановить контроллер CAN.
        BVALR0_BVAL1  = 0 ;//выключить 1-й объект сообщения
        BVALR0_BVAL2  = 0 ;//выключить 2-й объект сообщения vmz
        BVALR0_BVAL3  = 0 ;//выключить 3-й объект сообщения vmz
        BVALR0_BVAL4  = 0 ;//выключить 4-й объект сообщения
        BVALR0_BVAL5  = 0 ;//выключить 5-й объект сообщения vmz
        BVALR0_BVAL6  = 0 ;//выключить 6-й объект сообщения vmz
        BVALR0_BVAL13 = 0 ;//выключить 13-й объект сообщения
        BVALR0_BVAL14 = 0 ;//выключить 14-й объект сообщения
      }
      return 1 ;
    }

    // Переинициализация по команде с пульта после смены уставок CAN.
  if ( can_reInit(port) == 1 )
    {
      can_init(port);
      can_reInit(port) = 0 ;
      return 1 ;
    }
   //ДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДД

                // Ошибки - CAN еще не отключился от шины.
            if ((CSR0 & _NS_status) == 0x0100 || (CSR0 & _NS_status) == 0x0200)
              {
                can_dd[port].Avar++ ;
              }

                // CAN отключился от шины - BOff
            if ((CSR0 & _NS_status) == 0x0300 )
              {
//196           can_con &= Res_InitCan;
                 //  одного can_con для перезапуска CAN после i-того отключения
                 //  (коротили шину) не хватало, по-этому поставили
                 //  полную переинициализацию.
                 //  can_con = 0; // Включить контроллер CAN.
                can_init(port);

                mSet_ServiceMsg( _Srv_ResCan ) ;

                  // После Аварии CAN возврат в рабочую программу
                return 2 ;
              }

          // CAN не выставил предупреждение об ошибках
        // Проверка наличия потерянных сообщений. MsgLst = can_msgx_con.15,7,8.
      //----------
            // Проверка: не истекло ли время таймаута на передачу.
//196   if ((can_msg14con1 & _Tst_TxRqst) == _TxRqst )
        if (TREQR0_TREQ14)
//        if (!TCR0_TC14) или так
        {
          if ( (u)(w)(timer1-can_dd[port].time_out_send14) > _TimeOut_send )
          {
//196       can_msg14con1 = Res_TxRqst;//сброс передачи.
            TCANR0_TCAN14 = 1;//сброс запроса передачи.
            can_dd[port].Error_send++ ;
          }
        }
//        else
//        {
//         TCR0_TC14 = 0 ;
//        }
            // Проверка: не истекло ли время таймаута на передачу.
//196   if ((can_msg13con1 & _Tst_TxRqst) == _TxRqst )
        if (TREQR0_TREQ13)
//        if (!TCR0_TC13) или так
        {
          if ( (u)(w)(timer1-can_dd[port].time_out_send13) > _TimeOut_send )
          {
//196       can_msg13con1 = Res_TxRqst;//сброс передачи.
            TCANR0_TCAN13 = 1;//сброс запроса передачи.
            can_dd[port].Error_send++ ;
          }
        }
//        else
//        {
//         TCR0_TC13 = 0 ;
//        }
  }
  else
  {
    //    для CAN 1
    // Выключить контроллер CAN и программы.
  if ( tst_can_stop(port) == 1 )
    {    // для возможности работы с CAN из монитора без рабочей программы.
      if ( can_reInit(port) == 0 )
      {
        can_reInit(port) = 1 ; // Для автоматического срабатывания переинициализации.
        can1_con = 1;// Остановить контроллер CAN1.
        BVALR1_BVAL1  = 0 ;//выключить 1-й объект сообщения CAN1
        BVALR1_BVAL2  = 0 ;//выключить 2-й объект сообщения vmz1
        BVALR1_BVAL3  = 0 ;//выключить 3-й объект сообщения vmz1
        BVALR1_BVAL4  = 0 ;//выключить 4-й объект сообщения CAN1
        BVALR1_BVAL5  = 0 ;//выключить 5-й объект сообщения vmz1
        BVALR1_BVAL6  = 0 ;//выключить 6-й объект сообщения vmz1
        BVALR1_BVAL13 = 0 ;//выключить 13-й объект сообщения CAN1
        BVALR1_BVAL14 = 0 ;//выключить 14-й объект сообщения CAN1
      }
      return 1 ;
    }

    // Переинициализация по команде с пульта после смены уставок CAN.
  if ( can_reInit(port) == 1 )
    {
      can_init(port);
      can_reInit(port) = 0 ;
      return 1 ;
    }
   //ДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДД

                // Ошибки - CAN еще не отключился от шины.
            if ((CSR1 & _NS_status) == 0x0100 || (CSR1 & _NS_status) == 0x0200)
              {
                can_dd[port].Avar++ ;
              }

                // CAN отключился от шины - BOff
            if ((CSR1 & _NS_status) == 0x0300 )
              {
//196           can_con &= Res_InitCan;
                 //  одного can_con для перезапуска CAN после i-того отключения
                 //  (коротили шину) не хватало, по-этому поставили
                 //  полную переинициализацию.
                 //  can_con = 0; // Включить контроллер CAN.
                can_init(port);

                mSet_ServiceMsg( _Srv_ResCan ) ;

                  // После Аварии CAN возврат в рабочую программу
                return 2 ;
              }

          // CAN не выставил предупреждение об ошибках
        // Проверка наличия потерянных сообщений. MsgLst = can_msgx_con.15,7,8.
      //----------
            // Проверка: не истекло ли время таймаута на передачу.
//196   if ((can_msg14con1 & _Tst_TxRqst) == _TxRqst )
        if (TREQR1_TREQ14)
//        if (!TCR1_TC14) или так
        {
          if ( (u)(w)(timer1-can_dd[port].time_out_send14) > _TimeOut_send )
          {
//196       can_msg14con1 = Res_TxRqst;//сброс передачи.
            TCANR1_TCAN14 = 1;//сброс запроса передачи.
            can_dd[port].Error_send++ ;
          }
        }
//        else
//        {
//         TCR0_TC14 = 0 ;
//        }
            // Проверка: не истекло ли время таймаута на передачу.
//196   if ((can_msg13con1 & _Tst_TxRqst) == _TxRqst )
        if (TREQR1_TREQ13)
//        if (!TCR1_TC13) или так
        {
          if ( (u)(w)(timer1-can_dd[port].time_out_send13) > _TimeOut_send )
          {
//196       can_msg13con1 = Res_TxRqst;//сброс передачи.
            TCANR1_TCAN13 = 1;//сброс запроса передачи.
            can_dd[port].Error_send++ ;
          }
        }
//        else
//        {
//         TCR0_TC13 = 0 ;
//        }
  }

  return 0 ;
}
//ДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДД

word canSend( byte port , struct canMSG_Fuj *ptr )
{
  register union
  {
    lword lax ;
    byte  b[4] ;
  } buff ;

//      lax = ptr->id ;
//10.04.03 11:13#ifdef   _CAN_MASTER
  register byte ah ;
//10.04.03 11:13#endif

//        port = port ;// для устранения предупр. о неиспользов. "port"

      buff.lax = ptr->id ;
//10.04.03 11:14#ifdef   _CAN_MASTER   // для чистого slave переворачивание не имеет смысла
          //asm  xchb lax   ,lax+3 ; // т.к. он какой ID принял такой и отослал
          //asm  xchb lax+1 ,lax+2 ;
  //      buff.lax = lax ;
      //if ( can_setting(port).config._.master== 1 )
      //{
         ah        = buff.b[3] ;
         buff.b[3] = buff.b[0] ;
         buff.b[0] = ah ;
         ah        = buff.b[2] ;
         buff.b[2] = buff.b[1] ;
         buff.b[1] = ah ;
      //}
//        lax = buff.lax ;
//10.04.03 11:14#endif
  //    ptr->id = lax; нельзя, иначе это изменит в источнике

          //  У более чем одного передающего объекта не могут лежать
          // одинаковые адреса передачи даже если передает только один т.к.:
          // если передает старший по номеру объект, после его передачи будут
          // просканированы все объекты сооб. от младшего к старшему
          // и первый у кого будет найден переданный адрес будет ошибочно
          // принят как передающий и у него будет сброшен запрос передачи
          // (хотя он и не был взведен), а настоящий передающий объект
          // останется взведенным и будет передавать бесконечно.
          //
      if ( port==0 )
      {
        //для CAN 0
               // Проверка: не занят ли 14-й канал передачи.
//196   if ( ((can_msg14con1 & _Tst_TxRqst) != _TxRqst ) &&
//196                                       ( can_msg13id != ptr->id ))
                                // при проверке срезаем лишние кроме 11-ти старших разрядов
        if ( (!TREQR0_TREQ14) && ((IDRX0(13)&_ID11) != buff.lax) )//IDRX14 ))
                                       //(IDRX0(13) != ptr->id) - проверить
        {
        //у MO14 нет запроса на передачу И ID у MO13 не тот, что требуется сейчас

//196     can_msg14con1 = Set_CpuUpd;
          //can_msg14con1 = Set_NewDat;
//196       *(struct canMSG_Fuj*)&can_msg14id = *ptr;
//196       can_msg14id = lax;

//            BVALR0_BVAL14 = 0 ;
            Load_ptr(port,14,ptr);
            //IDRX0(14) = lax;
            IDRX0(14) = buff.lax;
//            BVALR0_BVAL14 = 1 ;
       //   can_msg14con0 = Res_IntPnd;  без прерываний
             //пытаюсь отправить
//196     can_msg14con1 = Set_NewDat & Res_CpuUpd & Set_TxRqst;
          TREQR0_TREQ14 = 1 ;

          //can_msg14con1 = Set_TxRqst;//пытаюсь отправить
          can_dd[port].time_out_send14 = timer1 ;
        }    // Проверка: не занят ли 13-й канал передачи.
//196   else if ( ((can_msg13con1 & _Tst_TxRqst) != _TxRqst ) &&
//196                                       ( can_msg14id != ptr->id ))
        else if ( (!TREQR0_TREQ13) &&  ((IDRX0(14)&_ID11) != buff.lax) )
                                       //(IDRX0(14) != ptr->id) - проверить
        {
        //у MO13 нет запроса на передачу И ID у MO14 не тот, что требуется сейчас
//196     can_msg13con1 = Set_CpuUpd;
//196       *(struct canMSG_Fuj*)&can_msg13id = *ptr;
//196       can_msg13id = lax ;
//            BVALR0_BVAL13 = 0 ;
            Load_ptr(port,13,ptr);
//            IDRX0(13) = lax;
            IDRX0(13) = buff.lax;
//            BVALR0_BVAL13 = 1 ;

             //пытаюсь отправить
//196     can_msg13con1 = Set_NewDat & Res_CpuUpd & Set_TxRqst;
          TREQR0_TREQ13 = 1 ;
          can_dd[port].time_out_send13 = timer1 ;
        }
        else
        {
          //09.04.06 00:36can_dd[port].Error_send++ ;
               //------------
          return 1 ;
        }
  return 0 ;
      }
      else
      {
        //для CAN 1
               // Проверка: не занят ли 14-й канал передачи.
        if ( (!TREQR1_TREQ14) &&  ((IDRX1(13)&_ID11) != buff.lax) )//IDRX14 ))
        {
        //у MO14 нет запроса на передачу И ID у MO13 не тот, что требуется сейчас

            Load_ptr(port,14,ptr);
            //IDRX0(14) = lax;
            IDRX1(14) = buff.lax;
//            BVALR0_BVAL14 = 1 ;
       //   can_msg14con0 = Res_IntPnd;  без прерываний
             //пытаюсь отправить
//196     can_msg14con1 = Set_NewDat & Res_CpuUpd & Set_TxRqst;
          TREQR1_TREQ14 = 1 ;

          //can_msg14con1 = Set_TxRqst;//пытаюсь отправить
          can_dd[port].time_out_send14 = timer1 ;
        }    // Проверка: не занят ли 13-й канал передачи.
//196   else if ( ((can_msg13con1 & _Tst_TxRqst) != _TxRqst ) &&
//196                                       ( can_msg14id != ptr->id ))
        else if ( (!TREQR1_TREQ13) &&  ((IDRX1(14)&_ID11) != buff.lax) )
                                       //(IDRX0(14) != ptr->id) - проверить
        {
        //у MO13 нет запроса на передачу И ID у MO14 не тот, что требуется сейчас
//            BVALR0_BVAL13 = 0 ;
            Load_ptr(port,13,ptr);
//            IDRX1(13) = lax;
            IDRX1(13) = buff.lax;
//            BVALR1_BVAL13 = 1 ;

             //пытаюсь отправить
//196     can_msg13con1 = Set_NewDat & Res_CpuUpd & Set_TxRqst;
          TREQR1_TREQ13 = 1 ;
          can_dd[port].time_out_send13 = timer1 ;
        }
        else
        {
          //09.04.06 00:37can_dd[port].Error_send++ ;
               //------------
          return 1 ;
        }
  return 0 ;
      }

}

//ДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДД

word canReceive( byte port , struct canMSG_Fuj *ptr )
{
//10.04.03 11:15#ifdef   _CAN_MASTER
  register union
  {
    lword lax ;
    byte  b[4] ;
  } buff ;
  register byte ah ;
//10.04.03 11:15#endif
//  register lword lax ;
//        port = port ;// для устранения предупр. о неиспользов. "port"
   if ( port==0 )
   {
    //для CAN 0
//196 if (can_int==0x02) //Есть операция с МО15
    if (RCR0_RC1) //Есть операция с МО1(MO15) - был прием
    {
       // считывание 15-го объекта сообщения.
//196 *ptr = *(struct canMSG_Fuj*)&can_msg15id ;
povtor:
       // считывание 1(15)-го объекта сообщения.
      Save_ptr(port,1,ptr) ;
      if (ROVRR0_ROVR1)
      {
       //если есть переполнение может быть наложение "старых"
       //и "новых" данных - необходимо перечитать данные
       ROVRR0_ROVR1 = 0 ;
       can_dd[port].Error_receive++ ;
       goto povtor ;
      }
       //переполнения не было - данные действительны
       RCR0_RC1 = 0 ;
//196 can_msg15con0 = Res_IntPnd;
//196 can_msg15con1 = Res_NewDat & Res_RmtPnd;
      goto ret ;
    }
//vmz beg
    if (RCR0_RC2) //Есть операция с МО2
    {
povtor2:
       // считывание 2-го объекта сообщения.
      Save_ptr(port,2,ptr) ;
      if (ROVRR0_ROVR2)
      {
       //если есть переполнение может быть наложение "старых"
       //и "новых" данных - необходимо перечитать данные
       ROVRR0_ROVR2 = 0 ;
       can_dd[port].Error_receive++ ;
       goto povtor2 ;
      }
       //переполнения не было - данные действительны
       RCR0_RC2 = 0 ;
      goto ret ;
    }
//----------------------------------
    if (RCR0_RC3) //Есть операция с МО3
    {
povtor3:
       // считывание 3-го объекта сообщения.
      Save_ptr(port,3,ptr) ;
      if (ROVRR0_ROVR3)
      {
       //если есть переполнение может быть наложение "старых"
       //и "новых" данных - необходимо перечитать данные
       ROVRR0_ROVR3 = 0 ;
       can_dd[port].Error_receive++ ;
       goto povtor3 ;
      }
       //переполнения не было - данные действительны
       RCR0_RC3 = 0 ;
      goto ret ;
    }
//----------------------------------
    if (RCR0_RC4) //Есть операция с МО3
    {
povtor04:
       // считывание 3-го объекта сообщения.
      Save_ptr(port,4,ptr) ;
      if (ROVRR0_ROVR4)
      {
       //если есть переполнение может быть наложение "старых"
       //и "новых" данных - необходимо перечитать данные
       ROVRR0_ROVR4 = 0 ;
       can_dd[port].Error_receive++ ;
       goto povtor04;
      }
       //переполнения не было - данные действительны
       RCR0_RC4 = 0 ;
      goto ret ;
    }
//----------------------------------
    if (RCR0_RC5) //Есть операция с МО3
    {
povtor05:
       // считывание 3-го объекта сообщения.
      Save_ptr(port,5,ptr) ;
      if (ROVRR0_ROVR5)
      {
       //если есть переполнение может быть наложение "старых"
       //и "новых" данных - необходимо перечитать данные
       ROVRR0_ROVR5 = 0 ;
       can_dd[port].Error_receive++ ;
       goto povtor05;
      }
       //переполнения не было - данные действительны
       RCR0_RC5 = 0 ;
      goto ret ;
    }
//----------------------------------
    if (RCR0_RC6) //Есть операция с МО3
    {
povtor06:
       // считывание 3-го объекта сообщения.
      Save_ptr(port,6,ptr) ;
      if (ROVRR0_ROVR6)
      {
       //если есть переполнение может быть наложение "старых"
       //и "новых" данных - необходимо перечитать данные
       ROVRR0_ROVR6 = 0 ;
       can_dd[port].Error_receive++ ;
       goto povtor06;
      }
       //переполнения не было - данные действительны
       RCR0_RC6 = 0 ;
      goto ret ;
    }
  return 0 ;
   }
   else
   {
    //для CAN 1
//196 if (can_int==0x02) //Есть операция с МО15
    if (RCR1_RC1) //Есть операция с МО1(MO15) - был прием
    {
       // считывание 15-го объекта сообщения.
//196 *ptr = *(struct canMSG_Fuj*)&can_msg15id ;
povtor1:
       // считывание 1(15)-го объекта сообщения.
      Save_ptr(port,1,ptr) ;
      if (ROVRR1_ROVR1)
      {
       //если есть переполнение может быть наложение "старых"
       //и "новых" данных - необходимо перечитать данные
       ROVRR1_ROVR1 = 0 ;
       can_dd[port].Error_receive++ ;
       goto povtor1 ;
      }
       //переполнения не было - данные действительны
       RCR1_RC1 = 0 ;
      goto ret ;
    }
//vmz1 beg
    if (RCR1_RC2) //Есть операция с МО2
    {
povtor4:
       // считывание 2-го объекта сообщения.
      Save_ptr(port,2,ptr) ;
      if (ROVRR1_ROVR2)
      {
       //если есть переполнение может быть наложение "старых"
       //и "новых" данных - необходимо перечитать данные
       ROVRR1_ROVR2 = 0 ;
       can_dd[port].Error_receive++ ;
       goto povtor4 ;
      }
       //переполнения не было - данные действительны
       RCR1_RC2 = 0 ;
      goto ret ;
    }
//----------------------------------
    if (RCR1_RC3) //Есть операция с МО3
    {
povtor5:
       // считывание 3-го объекта сообщения.
      Save_ptr(port,3,ptr) ;
      if (ROVRR1_ROVR3)
      {
       //если есть переполнение может быть наложение "старых"
       //и "новых" данных - необходимо перечитать данные
       ROVRR1_ROVR3 = 0 ;
       can_dd[port].Error_receive++ ;
       goto povtor5 ;
      }
       //переполнения не было - данные действительны
       RCR1_RC3 = 0 ;
      goto ret ;
    }
//----------------------------------
    if (RCR1_RC4) //Есть операция с МО4
    {
povtor14:
       // считывание 3-го объекта сообщения.
      Save_ptr(port,4,ptr) ;
      if (ROVRR1_ROVR4)
      {
       //если есть переполнение может быть наложение "старых"
       //и "новых" данных - необходимо перечитать данные
       ROVRR1_ROVR4 = 0 ;
       can_dd[port].Error_receive++ ;
       goto povtor14 ;
      }
       //переполнения не было - данные действительны
       RCR1_RC4 = 0 ;
      goto ret ;
    }
//----------------------------------
    if (RCR1_RC5) //Есть операция с МО5
    {
povtor15:
       // считывание 3-го объекта сообщения.
      Save_ptr(port,5,ptr) ;
      if (ROVRR1_ROVR5)
      {
       //если есть переполнение может быть наложение "старых"
       //и "новых" данных - необходимо перечитать данные
       ROVRR1_ROVR5 = 0 ;
       can_dd[port].Error_receive++ ;
       goto povtor15 ;
      }
       //переполнения не было - данные действительны
       RCR1_RC5 = 0 ;
      goto ret ;
    }
//----------------------------------
    if (RCR1_RC6) //Есть операция с МО6
    {
povtor16:
       // считывание 3-го объекта сообщения.
      Save_ptr(port,6,ptr) ;
      if (ROVRR1_ROVR6)
      {
       //если есть переполнение может быть наложение "старых"
       //и "новых" данных - необходимо перечитать данные
       ROVRR1_ROVR6 = 0 ;
       can_dd[port].Error_receive++ ;
       goto povtor16 ;
      }
       //переполнения не было - данные действительны
       RCR1_RC6 = 0 ;
      goto ret ;
    }
  return 0 ;
   }

ret:
//10.04.03 11:15#ifdef   _CAN_MASTER   // для чистого slave переворачивание не имеет смысла
  //if ( can_setting(port).config._.master== 1 )
  //{
    buff.lax = ptr->id ;
//      lax = ptr->id ;
          //asm  xchb lax   ,lax+3 ;
          //asm  xchb lax+1 ,lax+2 ;
       ah        = buff.b[3] ;
       buff.b[3] = buff.b[0] ;
       buff.b[0] = ah ;
       ah        = buff.b[2] ;
       buff.b[2] = buff.b[1] ;
       buff.b[1] = ah ;
//        lax = buff.lax ;
    ptr->id = buff.lax;
  //}
//10.04.03 11:16#endif

  return 1 ; // приняты данные для 'slave'.

}

//-----------------------------------------------
word Load_ptr(byte port, int buf,struct canMSG_Fuj *ptr)
// Переложить из структуры в регистры объекта сообщения
// id, dlen, data[8]
{
  register byte i ;
  if ( port==0 )
  {
   //для CAN 0
   IDRX0(buf) = ptr->id ;
   DLCR0(buf) = ptr->cfg.dlen ;
   for ( i=0; i < 8; i += 2  )
    {
     DTR0_WORD(buf,i/2) = (w)(ptr->data[i]) | ((w)(ptr->data[i+1]) << 8) ;
     // *(char*)&(DTR0_BYTE(buf,i)) = ptr->data[i] ; по-байтно не работает.
    }
   return 0 ;
  }
  else
  {
   //для CAN 1
   IDRX1(buf) = ptr->id ;
   DLCR1(buf) = ptr->cfg.dlen ;
   for ( i=0; i < 8; i += 2  )
    {
     DTR1_WORD(buf,i/2) = (w)(ptr->data[i]) | ((w)(ptr->data[i+1]) << 8) ;
    }
   return 0 ;
  }

}
//-----------------------------------------------
word Save_ptr(byte port, int buf,struct canMSG_Fuj *ptr)
// Переложить из регистра объекта сообщения в структуру
// id, dlen, data[8]
{
  register byte i ;

  if ( port==0 )
  {
   //для CAN 0
   ptr->id = IDRX0(buf) & _ID11 ; // срезаем лишние кроме 11-ти старших разрядов,
   ptr->cfg.dlen = DLCR0(buf) ;  // т.к. CAN-контроллер иногда заглючивает и
                                //  помещает в них мусор, а затем у мастера
                               // срабатывает защита по несовпадению id.
   //            for ( i=0; i < 8; i=i+2 )
   for ( i=0; i < 8; i++ )
    {
      //ptr->data[i]   = DTR0_WORD(buf,i) ;
      //ptr->data[i+1] = DTR0_WORD(buf,i) >> 8 ;
      ptr->data[i] = DTR0_BYTE(buf,i) ;
    }
  return 0;
  }
  else
  {
   //для CAN 1
   ptr->id = IDRX1(buf) & _ID11 ;
   ptr->cfg.dlen = DLCR1(buf) ;
   //            for ( i=0; i < 8; i=i+2 )
   for ( i=0; i < 8; i++ )
    {
      ptr->data[i] = DTR1_BYTE(buf,i) ;
    }
  return 0;
  }

}

//++++++++++++++++++++++++++++++++

//-----------------------------------------

#ifdef _Micro_Master

//
//Программа инициализации дополнительных (не для основного протокола) объектов
//MO1-MO12 для реализации дополнительного CAN-протокола типа конкретного протокола для АПР2.
//
        // MO4-MO12 - для ДОПОЛНИТЕЛЬНОГО протокола
        // MO1, MO2, MO3, MO13, MO14 - для ОСНОВНОГО протокола


//"Ошибка инициализации CAN" - сообщение формируется только в этом месте.

// ВОЗВРАЩАЕМЫЙ КОД ОШИБКИ:
//Возвращает содержимое error_init_CAN.

//"0" - инициализация произведена без ошибок.
//"1" - инициализация произведена, но есть предупреждение "Ошибка инициализации CAN", -
//(в структуре задан стандартный идентификатор, но похож на расширенный - ненулевые незначащие разряды).

// > "1" - инициализация объекта не выполнена, - "Ошибка инициализации CAN".

//   "2" - уже существует Объект Сообщений с данным идентификатором.
//   "3" - ошибочный номер Объекта Сообщений (должен быть 1-:-12)
//   "4" - несоответствие структуры smsg->cfg.dir и команды "w"
//   "5" - несоответствие структуры smsg->cfg.dir и команды "r", "i", "I"
//   "6" - несуществующий код команды, - должна быть команда "w", "r", "i", "I"

//word  xInit_msgP( word cmd, byte port, byte n_obj, struct canMSG_Fuj *ptr )
word  xInit_msg( word cmd, byte port, byte n_obj, lword MO_id )
{

register union
{
  lword lax ;
  byte  b[4] ;
} buff ;

register byte ah ;
register byte ax ;

byte error_init_CAN ;

/* cmd   - код команды: W,w - посылать дынные ;
                        R,r - читать присланные данные ;
   port  -  номер CAN-порта. для 196 - игнорируется
   n_obj -  номер объекта сообщения, через который выполнить команду.

   ptr     -  должна быть подготовлена,
   ptr->id       -  идентификатор, с которым послать или запросить данные,
   ptr->cfg.xtd  - стандартный(0)/расширенный идентификатор(1),
   ptr->cfg.dir  - приемник(0)/передатчик(1),
   ptr->cfg.dlen - длина передаваемых данных,
   ptr->data[i]  - передаваемые/принятые данные.



struct canMSG_196 {
        lword  id ;
        struct
        {
          unsigned int rezerv :2 ;
          unsigned int xtd    :1 ;
          unsigned int dir    :1 ;
          unsigned int dlen   :4 ;
        } cfg ;
        byte data[8];
} ;
*/

  //smsg->cfg.xtd = 0 ; // на будущее для расширенного фрейма.

  error_init_CAN = 0 ;

  //смещения в адресном пространстве CAN-ячеек 196
  //smes_b  = (n_obj-1)*16 ;//для байт
  //smes_lw = (n_obj-1)*4 ;//для 4-х байт слов


  //Проверка корректности номера Объекта Сообщения
  if ( (n_obj < 7) || (n_obj > 12) )
   {
     // ошибочный номер Объекта Сообщений (должен быть 4-:-12)
     mSet_ServiceMsg( _Srv_NotInitOkCan ) ; /* "Ошибка инициализации CAN" */
     error_init_CAN = 3 ;
     return error_init_CAN ;
   }

    //lax = ptr->id ;
    //asm_xchb( lax   ,lax+3 );
    //asm_xchb( lax+1 ,lax+2 );

    buff.lax = MO_id ;
    ah        = buff.b[3] ;
    buff.b[3] = buff.b[0] ;
    buff.b[0] = ah ;
    ah        = buff.b[2] ;
    buff.b[2] = buff.b[1] ;
    buff.b[1] = ah ;

   //Проверка корректности задания идентификатора Объекта Сообщения.
   //Поиск идентичного заданному идентификатора для всех активных дополнительных
   //МО исключая заданный.
   for ( ax = 7 ; ax <= 12 ; ax++ )
   {
    //if ( (*((b*)&can_msg1con0+ax*0x10) & 0x3f) == 0x80 )

    //if ( (*(w*)((w)&BVALR0(число)+smes_port[port])  & Res_Bit[ax]) != 0 )
    if ( (*(w*)((w)&BVALR0+smes_port[port])  & Res_Bit[ax]) != 0 )
    //if ( (*(&BVALR0(адр слова)+smes_port[port]/2)  & Res_Bit[ax]) != 0 )
     {
      //если объект включен, - проверить

      //if ( smsg->cfg.xtd )
      // {
      //  //для расширенного идентификатора
      //  if ( lax == (*((lw*)&can_msg1id+ax*4)) && ((w)(n_obj-1) != ax))
      //   {
      //    //Уже существует Объект Сообщений с данным идентификатором (расширенным)
      //    mSet_ServiceMsg( _Srv_NotInitOkCan ) ; /* "Ошибка инициализации CAN" */
      //    error_init_CAN = 2 ;
      //    return error_init_CAN ;
      //   }
      // }
      //else
       {
        //для стандартного идентификатора
        //не могут быть одинаковые ID (только, если один приемника
        //а другой передатчик)

        //if ( (lax & 0x0000fffful) ==
        //           ((*((lw*)&can_msg1id+ax*4)) & 0x0000fffful )
        //                   && ((w)(n_obj-1) != ax))

        if ( (*(w*)((w)&IDRX0(ax)+smesB_port[port]) & _ID11 == buff.lax & _ID11 )
                && ((w)(n_obj) != ax) )
         {
          //Уже существует Объект Сообщений с данным идентификатором (стандартным)
//          if ( ((w*)(&RFWTR0+smesB_port[port]) & Res_Bit[ax])
//           == ((w*)(&RFWTR0+smesB_port[port]) & Res_Bit[n_obj]) )
//          {
           //объект, имеющий этот же ID имеет и одинаковый режим
           //0 - передача(фрейма данных или запроса удаленного фрейма)
           //1 - передача ответа на запрос
           //(одинаковый ID для разных режимов допустим)

          if ( (*(w*)((w)&TRTRR0+smesB_port[port]) & Res_Bit[ax])
            == (*(w*)((w)&TRTRR0+smesB_port[port]) & Res_Bit[n_obj]) )
           {
            //объект, имеющий этот же ID имеет и одинаковый режим
            //0 - передача фрейма данных
            //1 - передача запроса удаленного фрейма
            //(одинаковый ID для разных режимов допустим)
            mSet_ServiceMsg( _Srv_NotInitOkCan ) ; /* "Ошибка инициализации CAN" */
            error_init_CAN = 2 ;
            return error_init_CAN ;
           }
         }
        }
     }
   }

/*      MsgVal = 0 - нет доступа к объекту сообщения;
        TXIE   = 0 - нет разрешения прерывания по передаче;
        RXIE   = 0 - нет разрешения прерывания по приему;
        IntPnd = 0 - нет отложенного прерывания у данного объекта сообщения;

        RmtPnd = 0 - не было удаленного запроса для объекта сообщения;
        TX_REQ = 0 - не задана передача объекту;
        MsgLst = 0 - нет потерянных принимаемых сообщений;
        ( CPUUpd ) - ( передающему объекту разрешена передача );
        NewDat = 0 - не записывалась никакая информация в сегмент данных;
*/

/*      DLC     = 0 - код длины данных;
        DIR     = 0 - направление ПРИЕМ;
        Xtd     = 0 - стандартный идентификатор;
        Rezerv  = 0 - резервные разряды;
*/
      //деактивация МО
      //*((b*)&can_msg1con0+smes_b) = 0x55  ;
      //*((b*)&can_msg1con1+smes_b) = 0x55  ;
      //BVALR0 = BVALR0 & (~Res_Bit[n_obj]) ;
     *(w*)((w)&BVALR0+smes_port[port]) = *(w*)((w)&BVALR0+smes_port[port])
                                      & (~Res_Bit[n_obj]) ;

      //запись идентификатора
      //*((lw*)&can_msg1id+smes_lw) = lax ;


  switch ( cmd )
  {
    //case 'W' :    //передатчик
    case 's' :    //передатчик - посылка фрейма данных

        //объект - DATA FRAME (не REMOTE FRAME)
        //TRTRR0 = TRTRR0  & (~Res_Bit[n_object]) ; //объект - DATA FRAME (не REMOTE FRAME)
       *(w*)((w)&TRTRR0+smesB_port[port]) = *(w*)((w)&TRTRR0+smesB_port[port])
                                          & (~Res_Bit[n_obj]) ;
        //Загрузить ID и DATA[8]
        //проверить Load_ptr(port,n_obj,ptr) ;//?
        //если передаю не ptr, а ID и "убираю" Load_ptr(port,n_obj,ptr), -
        //Загрузить ID
        *(w*)((w)&IDRX0(n_obj)+smesB_port[port]) = buff.lax;

/*
   IDRX0(buf) = ptr->id ;
   DLCR0(buf) = ptr->cfg.dlen ;
   for ( i=0; i < 8; i += 2  )
    {
     DTR0_WORD(buf,i/2) = (w)(ptr->data[i]) | ((w)(ptr->data[i+1]) << 8) ;
     // *(char*)&(DTR0_BYTE(buf,i)) = ptr->data[i] ; по-байтно не работает.
    }
*/

        break ;

    case 'w' :    //передатчик - подготовка данных на запрос удаленного фрейма

        //TRTRR0 = TRTRR0 | Res_Bit[n_object] ; //объект - REMOTE FRAME
       *(w*)((w)&TRTRR0+smesB_port[port]) = *(w*)((w)&TRTRR0+smesB_port[port])
                                          | Res_Bit[n_obj] ;
        //Загрузить ID и DATA[8]
        //проверить xWrite_msgP(port,n_obj,ptr) ; //?может не выполниться

        //Загрузить ID
        *(w*)((w)&IDRX0(n_obj)+smesB_port[port]) = buff.lax;

    //            П Е Р Е Д А Ч А

        break ;

    //case 'R' :    //приемник
    case 'r' :    //приемник - прием фрейма данных
    case 'i' :    //приемник - прием ответа на запрос удаленного фрейма

    //            П Р И Е М
         //объект - DATA FRAME (не REMOTE FRAME)
        //TRTRR0 = TRTRR0  & (~Res_Bit[n_object]) ;
       *(w*)((w)&TRTRR0+smesB_port[port]) = *(w*)((w)&TRTRR0+smesB_port[port])
                                          & (~Res_Bit[n_obj]) ;
        //Загрузить ID и DATA[8]
        //проверить Load_ptr(port,n_obj,ptr) ;//?
        //Загрузить ID
        *(w*)((w)&IDRX0(n_obj)+smesB_port[port]) = buff.lax;

        break ;

    default:

      //Неверно указан код команды, - должна быть команда "w", "r", "i", "I"
      mSet_ServiceMsg( _Srv_NotInitOkCan ) ; /* "Ошибка инициализации CAN" */
      error_init_CAN = 6 ;
      return error_init_CAN ;
  }

        //*((b*)&can_msg1con0+smes_b) = Set_RXIE ;
        //*((b*)&can_msg1con0+smes_b) = Set_MsgVal ;

      //активация объекта сообщения
      //BVALR0 = BVALR0 | Res_Bit[n_obj] ;
     *(w*)((w)&BVALR0+smes_port[port]) = *(w*)((w)&BVALR0+smes_port[port])
                                      | Res_Bit[n_obj] ;

      mClr_ServiceMsg( _Srv_NotInitOkCan ) ; /*Сброс сообщения "Ошибка инициализации CAN" */

      return error_init_CAN ;
}

//---------------------------

//---------------------------
//
//  Набор функций для реализации CAN-протокола типа протокола для АПР2.
//
//----------
//   cmd   - код команды: W,w - послать дынные ;
//                        R,r - прочитать присланные данные ;
//                        I,i - запросить данные.
//   port  -  номер CAN-порта.
//   n_obj  -  номер объекта сообщения, через который выполнить команду.
//   id    -  идентификатор, с которым послать или запросить данные.
//   *dscr -  перечень номеров посылаемых/принимаемых переменных из var_tab[].
//

//**************** П Е Р Е Д А Ч А *******************************
//****************************************************************
// Послать сообщение через Порт - port;  МО - n_obj; ID, dlen, data - smsg
word  xSend_msg( byte port, byte n_obj, struct canMSG_Fuj *ptr )
{

  register union
  {
    lword lax ;
    byte  b[4] ;
  } buff ;

  register byte ah ;//?

  //word Zapros ;

      buff.lax = ptr->id ;
      //?
         ah        = buff.b[3] ;
         buff.b[3] = buff.b[0] ;
         buff.b[0] = ah ;
         ah        = buff.b[2] ;
         buff.b[2] = buff.b[1] ;
         buff.b[1] = ah ;
      //?

      if ( port==0 )
       {
        //для CAN 0
          // Проверка: не занят ли n_obj-й канал передачи.
        //if ( (TREQR0 && Res_TREQR[n_obj]) == 0  )
        if ( (TREQR0 & Res_Bit[n_obj]) == 0  )

         /*Zapros = ( TREQR0 >> (n_obj-1) ) && 0x0001 ;
         if ( !Zapros )*/
                                       //(IDRX0(13) != ptr->id) - проверить
         {
          //у MO[n_obj] нет запроса на передачу
          // Передача состоялась (или еще ни разу не осуществлялась)
          // Данные отосланы

          Load_ptr(port,n_obj,ptr);

          IDRX0(n_obj) = buff.lax;
          //IDRX0(n_obj) = ptr->id;

          //отправить - взвести признак передачи
          //TREQR0 = TREQR0 || Res_TREQR[n_obj] ;
          TREQR0 = TREQR0 | Res_Bit[n_obj] ;
          return 0 ;
         }
        else
         {
          //Прошлая передача еще не завершилась, -
          //новая передача не может осуществится
          //can_dd[port].Error_send++ ;
          return 1 ;
         }
       }
      else
       {
        //для CAN 1
          // Проверка: не занят ли n_obj-й канал передачи.
        if ( (TREQR1 & Res_Bit[n_obj]) == 0  )

         /*Zapros = ( TREQR0 >> (n_obj-1) ) && 0x0001 ;
         if ( !Zapros )*/
                                       //(IDRX0(13) != ptr->id) - проверить
         {
          //у MO[n_obj] нет запроса на передачу
          // Передача состоялась (или еще ни разу не осуществлялась)
          // Данные отосланы

          Load_ptr(port,n_obj,ptr);

          IDRX1(n_obj) = buff.lax;
          //IDRX1(n_obj) = ptr->id;

          //отправить - взвести признак передачи
          TREQR1 = TREQR1 | Res_Bit[n_obj] ;
          return 0 ;
         }
        else
         {
          //Прошлая передача еще не завершилась, -
          //новая передача не может осуществится
          //can_dd[port].Error_send++ ;
          return 1 ;
         }
       }
}
//------------------------------------------------------------------------
// Послать сообщение через Порт - port;  МО - n_obj; ID, dlen, data - smsg
word  xSend_msgP( byte port, byte n_obj, struct canMSG_Fuj *ptr )
{
  register union
  {
    lword lax ;
    byte  b[4] ;
  } buff ;

  register byte ah ;

  //word Zapros ;

      buff.lax = ptr->id ;
      //?
         ah        = buff.b[3] ;
         buff.b[3] = buff.b[0] ;
         buff.b[0] = ah ;
         ah        = buff.b[2] ;
         buff.b[2] = buff.b[1] ;
         buff.b[1] = ah ;
      //?

          // Проверка: не занят ли n_obj-й канал передачи.
        //if ( (TREQR0 && Res_TREQR[n_obj]) == 0  )
        if ( (*(w*)((w)&TREQR0+smes_port[port]) & Res_Bit[n_obj]) == 0  )

         /*Zapros = ( TREQR0 >> (n_obj-1) ) && 0x0001 ;
         if ( !Zapros )*/
                                       //(IDRX0(13) != ptr->id) - проверить
         {
          //у MO[n_obj] нет запроса на передачу
          // Передача состоялась (или еще ни разу не осуществлялась)
          // Данные отосланы

          Load_ptr(port,n_obj,ptr);

          //IDRX0(n_obj) = buff.lax;
          *(w*)((w)&IDRX0(n_obj)+smesB_port[port]) = buff.lax;
          //IDRX0(n_obj) = ptr->id;

          //отправить - взвести признак передачи
          //TREQR0 = TREQR0 || Res_TREQR[n_obj] ;
          //TREQR0 = TREQR0 || Res_Bit[n_obj] ;
          *(w*)((w)&TREQR0+smes_port[port]) = *(w*)((w)&TREQR0+smes_port[port])
                                            | Res_Bit[n_obj] ;
          return 0 ;
         }
        else
         {
          //Прошлая передача еще не завершилась, -
          //новая передача не может осуществится
          //can_dd[port].Error_send++ ;
          return 1 ;
         }
}

//**************** П Р И Е М *************************************
//****************************************************************
// Принять сообщение через Порт - port;  МО - n_obj; ID, dlen, data - smsg
word   xRead_msg( byte port, byte n_obj, struct canMSG_Fuj *ptr )
{
  register union
  {
    lword lax ;
    byte  b[4] ;
  } buff ;

  register byte ah ;

// Обнулять ли после приема длину принятых данных
   if ( port==0 )
   {
    //для CAN 0
    //if (RCR0 && Res_RCR[n_obj]) //Есть операция с МО_n_obj - был прием
    if (RCR0 & Res_Bit[n_obj]) //Есть операция с МО_n_obj - был прием
     {
povtor:
       // считывание n_obj-го объекта сообщения.
      Save_ptr(port,n_obj,ptr) ;
      //if (ROVRR0 && Res_ROVRR[n_obj])
      if (ROVRR0 & Res_Bit[n_obj])
       {
        //если есть переполнение может быть наложение "старых"
        //и "новых" данных - необходимо перечитать данные
        //ROVRR0 = ROVRR0 && (~ROVRR[n_obj]) ;
        ROVRR0 = ROVRR0 & (~Res_Bit[n_obj]) ;
        can_dd[port].Error_receive++ ;
        goto povtor ;
       }
      //переполнения не было - данные действительны
      //RCR0 = RCR0 &&  Res_RCR[n_obj] ;
      RCR0 = RCR0 & (~Res_Bit[n_obj]) ;
      goto ret ;
      //return 1 ;
     }
    else
     {
      // Отсутствуют новые данные в объекте n_obj
      return 0 ;
     }
   }
  else
   {
    //для CAN 1
    if (RCR1 & Res_Bit[n_obj]) //Есть операция с МО_n_obj - был прием
     {
       // считывание n_obj-го объекта сообщения.
povtor1:
       // считывание n_obj-го объекта сообщения.
      Save_ptr(port,n_obj,ptr) ;
      if (ROVRR1 & Res_Bit[n_obj])
       {
        //если есть переполнение может быть наложение "старых"
        //и "новых" данных - необходимо перечитать данные
        ROVRR1 = ROVRR1 & (~Res_Bit[n_obj]) ;
        can_dd[port].Error_receive++ ;
        goto povtor1 ;
       }
      //переполнения не было - данные действительны
      RCR1 = RCR1 & (~Res_Bit[n_obj]) ;
      goto ret ;
      //return 1 ;
     }
    else
     {
      // Отсутствуют новые данные в объекте n_obj
      return 0 ;
     }
   }
ret:
//10.04.03 11:15#ifdef   _CAN_MASTER   // для чистого slave переворачивание не имеет смысла
  //if ( can_setting(port).config._.master== 1 )
  //{
    buff.lax = ptr->id ;
//      lax = ptr->id ;
          //asm  xchb lax   ,lax+3 ;
          //asm  xchb lax+1 ,lax+2 ;
       ah        = buff.b[3] ;
       buff.b[3] = buff.b[0] ;
       buff.b[0] = ah ;
       ah        = buff.b[2] ;
       buff.b[2] = buff.b[1] ;
       buff.b[1] = ah ;
//        lax = buff.lax ;
    ptr->id = buff.lax;
  //}
//10.04.03 11:16#endif

  return 1 ; // приняты данные для 'slave'.

}
//------------------------------------------------------------------------
// Принять сообщение через Порт - port;  МО - n_obj; ID, dlen, data - smsg
word   xRead_msgP( byte port, byte n_obj, struct canMSG_Fuj *ptr )
{
  register union
  {
    lword lax ;
    byte  b[4] ;
  } buff ;

  register byte ah ;

// Обнулять ли после приема длину принятых данных

    //для CAN 0
    //if (RCR0 && Res_RCR[n_obj]) //Есть операция с МО_n_obj - был прием
    //if (RCR0 && Res_Bit[n_obj]) //Есть операция с МО_n_obj - был прием
    if ( *(w*)((w)&RCR0+smes_port[port]) & Res_Bit[n_obj]) //Есть операция с МО_n_obj - был прием
     {
       // считывание n_obj-го объекта сообщения.
povtor:
       // считывание n_obj-го объекта сообщения.
      Save_ptr(port,n_obj,ptr) ;
      //if (ROVRR0 && Res_ROVRR[n_obj])
      //if (ROVRR0 && Res_Bit[n_obj])
      if (*(w*)((w)&ROVRR0+smes_port[port]) & Res_Bit[n_obj])
       {
        //если есть переполнение может быть наложение "старых"
        //и "новых" данных - необходимо перечитать данные
        //ROVRR0 = ROVRR0 && (~ROVRR[n_obj]) ;
        //ROVRR0 = ROVRR0 && (~Res_Bit[n_obj]) ;
        *(w*)((w)&ROVRR0+smes_port[port]) = *(w*)((w)&ROVRR0+smes_port[port])
                                          & (~Res_Bit[n_obj]) ;
        can_dd[port].Error_receive++ ;
        goto povtor ;
       }
      //переполнения не было - данные действительны
      //RCR0 = RCR0 &&  Res_RCR[n_obj] ;
      //RCR0 = RCR0 &&  Res_Bit[n_obj] ;
      *(w*)((w)&RCR0+smes_port[port]) = *(w*)((w)&RCR0+smes_port[port])
                                      & (~Res_Bit[n_obj]) ;
      goto ret ;
      //return 1 ;
     }
    else
     {
      // Отсутствуют новые данные в объекте n_obj
      return 0 ;
     }
ret:
//10.04.03 11:15#ifdef   _CAN_MASTER   // для чистого slave переворачивание не имеет смысла
  //if ( can_setting(port).config._.master== 1 )
  //{
    buff.lax = ptr->id ;
//      lax = ptr->id ;
          //asm  xchb lax   ,lax+3 ;
          //asm  xchb lax+1 ,lax+2 ;
       ah        = buff.b[3] ;
       buff.b[3] = buff.b[0] ;
       buff.b[0] = ah ;
       ah        = buff.b[2] ;
       buff.b[2] = buff.b[1] ;
       buff.b[1] = ah ;
//        lax = buff.lax ;
    ptr->id = buff.lax;
  //}
//10.04.03 11:16#endif

  return 1 ; // приняты данные для 'slave'.

}

// Запросить сообщение через Порт - port;  МО - n_obj; ID, dlen, data - smsg
//**************** П О С Ы Л   З А П Р О С А *********************
//****************************************************************
// Послать запрос через Порт - port;  МО - n_obj; ID, dlen, data - ptr
word xInquire_msg( byte port, byte n_obj, struct canMSG_Fuj *ptr )
{
  return xSend_msgP(port,n_obj,ptr ) ;

   // Передача состоялась (или еще ни разу не осуществлялась)
   // Данные отосланы
   //return 1 ;

   //Прошлый запрос еще не завершился, -
   //новый запрос не может осуществится
   //return 0 ;
}

//**************** ПОДГОТОВКА К ПЕРЕДАЧЕ *************************
//********* Передатчик готовит данные на случай запроса **********

// Подготовить сообщение через Порт - port;  МО - n_obj; ID, dlen, data - smsg
word xWrite_msgP( byte port, byte n_obj, struct canMSG_Fuj *ptr )
{
  register union
  {
    lword lax ;
    byte  b[4] ;
  } buff ;

  register byte ah ;

  buff.lax = ptr->id ;

  ah        = buff.b[3] ;
  buff.b[3] = buff.b[0] ;
  buff.b[0] = ah ;
  ah        = buff.b[2] ;
  buff.b[2] = buff.b[1] ;
  buff.b[1] = ah ;

 if ( (*(w*)((w)&TREQR0+smes_port[port]) & Res_Bit[n_obj]) == 0  )

 //если это только для ответа на запрос удаленного фрейма
  {
   //можно обновить данные
   Load_ptr(port, n_obj, ptr) ;
   //IDRX0(n_obj) = buff.lax;
   *(w*)((w)&IDRX0(n_obj)+smesB_port[port]) = buff.lax;
   return 1 ;
  }
 else
  {
   //выставлен запрос передачи, - нельзя обновить данные
   //(если во время обновления произойдет передача, - могут быть
   //искаженные данные)
   return 0 ;
  }
}

//---------------------------------------------------------------------------
#endif
//---------------------------------------------------------------------------

__interrupt  void CAN0_RX_Interrupt ( void )
{
  canSlaveDrive(_CAN0_Port);
}

__interrupt  void CAN1_RX_Interrupt ( void )
{
  canSlaveDrive(_CAN1_Port);
}





