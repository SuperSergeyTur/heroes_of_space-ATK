
//         ПРОГРАММЫ ПРЕДВАРИТЕЛЬНОЙ ОБРАБОТКИ ВНЕШНИХ СИГНАЛОВ .
//------------------------------------------------------------------

        //  Все разрозненные сигналы собираем в один порт.
byte read_Pi1 ( void )
{
  register byte al ;
          //   ЪДДДДДДДДДДДДДДДДДДДДДДДДДДДДДP92
          //   і   ЪДДДДДДДДДДДДДДДДДДДДДДДДДP02
          //   і   і           ЪДДДДДДДДДДДВДP40...P43 (поав С, аазапдл 4-7)
          // ЪДБДВДБДВДДДВДДДТДБДВДДДВДДДВДБДї
          // і 7 і 6 і 5 і 4 є 3 і 2 і 1 і 0 і
          // АДДДБДДДБДДДБДДДРДДДБДДДБДДДБДДДЩ

          // P40...P43           P92                P02
        al = Port55_C | ((PDR9 & 0x04)<<5) | ((PDR0 & 0x04)<<4) ;
        //al = (PDR2 & 0x3F) | (PDR8 & 0x40) | ((PDR9 & 0x04)<<5) ;

  return al ;
}
/* Диагаамма аабовл дилмваа даебезга и помее.

    є ибеоднлй бигнал
    є   ЪДДДї    ЪДДДДДДДї ЪДДДДДДДДДДДДДДДДДДДї   ЪДДДДДї     ЪДДї
    є   і   і    і       і і                   і   і     і     і  і
    є   і   і    і       і і                   і   і     і     і  і
  ННОНННПНННПННННПНННННННПНПНННННННННННННННННННПНННПНННННПНННННПННПННННННННННН>
                                                                          t,o.e.

    є Д<Даанее блл задикбиаован "0"                      задикбиаован "0"Д>Дґ
    є                                ГД<Дзадикбиаована "1"
 по-* Д  Д  Д  Д  Д  Д  Д  Д  Д  Д   ЪДДДДДДДДДї   ЪДДДДДї     ЪДДї         і
рог є интегратора                  ЪДЩ         АДї і     АДї   і  АДї
    є   фильтра        ЪДї       ЪДЩ             АДЩ       АДї і    АДї     і
    є                ЪДЩ і     ЪДЩ                           АДЩ      АДї
    є     ЪДї      ЪДЩ   і   ЪДЩ                                        АДї
    є   ЪДЩ і    ЪДЩ     і ЪДЩ                                            АДї
  ННОНННПНННПННННПНННННННПНПННННННННННННННННННННННННННННННННННННННННННННННННПН>
                                                                          t,o.e.
    є
    є отфильтрованный сигнал         ЪДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДї
    є                                і                                      і
    є                                і                                      і
  ННОННННННННННННННННННННННННННННННННПННННННННННННННННННННННННННННННННННННННПН>
    є                                                                     t,o.e.
*/
//--------------------------------------------------------

//    Программа централизованной обработки внешних входных дискретных
//  сигналов.
//    Программа осуществляет нормализацию уровней, маскирование и
// антидребезг/фильтрацию сигналов.
//    Точность отслеживания постоянных времени фильтрации сигналов
// прямо пропорциональна частоте отработок данной программы .

void  Port_input ( word code )
{
    _register byte  al ;
    _register word  ax , bx ;
    _register lword  lax ;

        /*   Фиксация полного времени для данного момента.
         * Полное время состоит из показаний рабочего таймера и счетчика
         * его переполнений.
         * Дискрета рабочего таймера = 0.868мксек.
         * Дискрета счетчика переполнений рабочего таймера = 0.569сек.
         *  Алгоритм считывания показаний имеет особенность из-за того,
         * что считывание производится в два приема: считывание таймера и
         * считыание счетчика переполнений - а в интервале между считываниями
         * может иметь место переполнение таймера с переносом в счетчик.
         * Если последнее не учитывать, то будет вероятна ошибка считывания.
         *   Для учета данной особености считывания используется алгоритм
         * рекомендуемый в литературе для применения в 8-разрядных микро-
         * контроллерах для считывания показаний 16-разрядных таймеров.
         *   Алгоритм, применительно к нашему случаю, заключается в следующем:
         * 1. считывание счетчика переполнений => 'ax' ;
         * 2. считывание таймера => 'bx' ;
         * 3. сравнений счетчика переполнений с ранее считанным его значением
         *    хранящимся в 'ax' ;
         * 4. при несовпадении значений, что является признаком переполнения
         *    таймера между считываниями, возврат к пункту 1.
         */
    do { ax = Timer1_Ovr , bx = timer1 ; } while ( ax != Timer1_Ovr ) ;
    ax <<= 8 ;      //  Из четырехбайтного полного значения времени
    ax  += (bx>>8); // для работы берутся средние два байта прини-
                    // мающие значения в диапазоне 0.25мсек-12.0сек.

  switch ( code )
  {    //  Стартовая инициализация.
    case 0 :

        mDD3_Read( al ) ;
        Pi0_c.all = al ;
        Pi0_cf.all = al ;
        Pi0_nm.all = Pi0_f.all = al ^ _r.Pi0_Normal ;
        for ( bx = 0 ; bx < 8 ; bx++ )  P0_t[bx] = ax ;

        mDD5_Read( al ) ;
        Pi1_c.all = al ;
        Pi1_cf.all = al ;
        Pi1_nm.all = Pi1_f.all = al ^ _r.Pi1_Normal ;
        for ( bx = 0 ; bx < 8 ; bx++ )  P1_t[bx] = ax ;

        mDD6_Read( al ) ;
        Pi2_c.all = al ;
        Pi2_cf.all = al ;
        Pi2_nm.all = Pi2_f.all = al ^ _r.Pi2_Normal ;
        for ( bx = 0 ; bx < 8 ; bx++ )  P2_t[bx] = ax ;

        al =  read_Pi1 () ;
        Pi3_c.all = al ;
        Pi3_cf.all = al ;
        Pi3_nm.all = Pi3_f.all = al ^ _r.Pi3_Normal ;
        for ( bx = 0 ; bx < 8 ; bx++ )  P3_t[bx] = ax ;

      break;

    case 3 :

        // чтение состояния ДЗВ
        al =  read_Pi1 () ;
        al ^= _r.Pi3_Normal ;
        Pi3_nm.all = al ;

      break;
    //---------------------

    default:
    case 1 :


/*ДДДДДДДДДДДДДДДД  Pi0  ДДДДДДДДДДДДДДДДДДД*/

//   Нормализация, т.е. приведение посредством уставки реальных активных
// уровней сигналов к общепринятому уровню активного сигнала, и маскирование
// заданных уставкой сигналов порта.
    mDD3_Read( al ) ;
     Pi0_c.all = al ,  al ^= _r.Pi0_Normal ;

//            Фильтрация дискретных сигналов портов .
//   Фильтрация осуществляется отдельно, как для каждого из портов,
// так и для отдельных сигналов в порту.

    lax = (lw)(w)Pi0_f.all << 24 ;
    lax += (lw)(w)Pi0_nm.all << 16;
    lax += (lw)(w)al << 8 ;

    for ( bx = 0 ; bx < 8 ; bx++ , lax >>= 1 )
       {
         if((lax & 0x1000000L) != 0)
          {
             if( (lax & 0x10100L) == 0 )
              {
                if ( (u)((w)(ax - P0_t[ bx ])) >= P0_tu[ bx ] )
                  {
                    P0_t[ bx ] = ax ;
                    lax &= 0xfeffffff ;
                  }
                continue ;
              }
             else  P0_t[ bx ] = ax ;
             continue ;
          }
         else
          {
             if( (lax & 0x10100L) == 0x10100L )
              {
                if ( (u)((w)(ax - P0_t[ bx ])) >= P0_tu[ bx ] )
                  {
                    P0_t[ bx ] = ax ;
                    lax |= 0x01000000 ;
                  }
                continue ;
              }
             else P0_t[ bx ] = ax ;
             continue ;
           }
       }
    //   Возвращение обработанных сигналов в память.
      Pi0_f.all = lax >> 16 ;
      Pi0_nm.all = lax;

           // Производим обратное инвертирование, чтобы получить
          // отфильтрованное, но ненормированное значение.
      Pi0_cf.all = Pi0_f.all ^ _r.Pi0_Normal ;
/*ДДДДДДДДДДДДДДДД  Pi1  ДДДДДДДДДДДДДДДДДДД*/

//   Нормализация, т.е. приведение посредством уставки реальных активных
// уровней сигналов к общепринятому уровню активного сигнала, и маскирование
// заданных уставкой сигналов порта.
    mDD5_Read( al ) ;
     Pi1_c.all = al ,  al ^= _r.Pi1_Normal ;

//            Фильтрация дискретных сигналов портов .
//   Фильтрация осуществляется отдельно, как для каждого из портов,
// так и для отдельных сигналов в порту.

    lax = (lw)(w)Pi1_f.all << 24 ;
    lax += (lw)(w)Pi1_nm.all << 16;
    lax += (lw)(w)al << 8 ;

    for ( bx = 0 ; bx < 8 ; bx++ , lax >>= 1 )
       {
         if((lax & 0x1000000L) != 0)
          {
             if( (lax & 0x10100L) == 0 )
              {
                if ( (u)((w)(ax - P1_t[ bx ])) >= P1_tu[ bx ] )
                  {
                    P1_t[ bx ] = ax ;
                    lax &= 0xfeffffff ;
                  }
                continue ;
              }
             else  P1_t[ bx ] = ax ;
             continue ;
          }
         else
          {
             if( (lax & 0x10100L) == 0x10100L )
              {
                if ( (u)((w)(ax - P1_t[ bx ])) >= P1_tu[ bx ] )
                  {
                    P1_t[ bx ] = ax ;
                    lax |= 0x01000000 ;
                  }
                continue ;
              }
             else P1_t[ bx ] = ax ;
             continue ;
           }
       }
    //   Возвращение обработанных сигналов в память.
      Pi1_f.all = lax >> 16 ;
      Pi1_nm.all = lax;

           // Производим обратное инвертирование, чтобы получить
          // отфильтрованное, но ненормированное значение.
      Pi1_cf.all = Pi1_f.all ^ _r.Pi1_Normal ;

/*ДДДДДДДДДДДДДДДД  Pi2  ДДДДДДДДДДДДДДДДДДД*/

//   Нормализация, т.е. приведение посредством уставки реальных активных
// уровней сигналов к общепринятому уровню активного сигнала, и маскирование
// заданных уставкой сигналов порта.
    mDD6_Read( al ) ;
     Pi2_c.all = al ,  al ^= _r.Pi2_Normal ;

//            Фильтрация дискретных сигналов портов .
//   Фильтрация осуществляется отдельно, как для каждого из портов,
// так и для отдельных сигналов в порту.

    lax = (lw)(w)Pi2_f.all << 24 ;
    lax += (lw)(w)Pi2_nm.all << 16;
    lax += (lw)(w)al << 8 ;

    for ( bx = 0 ; bx < 8 ; bx++ , lax >>= 1 )
       {
         if((lax & 0x1000000L) != 0)
          {
             if( (lax & 0x10100L) == 0 )
              {
                if ( (u)((w)(ax - P2_t[ bx ])) >= P2_tu[ bx ] )
                  {
                    P2_t[ bx ] = ax ;
                    lax &= 0xfeffffff ;
                  }
                continue ;
              }
             else  P2_t[ bx ] = ax ;
             continue ;
          }
         else
          {
             if( (lax & 0x10100L) == 0x10100L )
              {
                if ( (u)((w)(ax - P2_t[ bx ])) >= P2_tu[ bx ] )
                  {
                    P2_t[ bx ] = ax ;
                    lax |= 0x01000000 ;
                  }
                continue ;
              }
             else P2_t[ bx ] = ax ;
             continue ;
           }
       }
    //   Возвращение обработанных сигналов в память.
      Pi2_f.all = lax >> 16 ;
      Pi2_nm.all = lax;

           // Производим обратное инвертирование, чтобы получить
          // отфильтрованное, но ненормированное значение.
      Pi2_cf.all = Pi2_f.all ^ _r.Pi2_Normal ;
/*ДДДДДДДДДДДДДДДД  Pi3  ДДДДДДДДДДДДДДДДДДД*/

//   Нормализация, т.е. приведение посредством уставки реальных активных
// уровней сигналов к общепринятому уровню активного сигнала, и маскирование
// заданных уставкой сигналов порта.
     al =  read_Pi1 () ;
     Pi3_c.all = al ,  al ^= _r.Pi3_Normal ;

//            Фильтрация дискретных сигналов портов .
//   Фильтрация осуществляется отдельно, как для каждого из портов,
// так и для отдельных сигналов в порту.

    lax = (lw)(w)Pi3_f.all << 24 ;
    lax += (lw)(w)Pi3_nm.all << 16;
    lax += (lw)(w)al << 8 ;

    for ( bx = 0 ; bx < 8 ; bx++ , lax >>= 1 )
       {
         if((lax & 0x1000000L) != 0)
          {
             if( (lax & 0x10100L) == 0 )
              {
                if ( (u)((w)(ax - P3_t[ bx ])) >= P3_tu[ bx ] )
                  {
                    P3_t[ bx ] = ax ;
                    lax &= 0xfeffffff ;
                  }
                continue ;
              }
             else  P3_t[ bx ] = ax ;
             continue ;
          }
         else
          {
             if( (lax & 0x10100L) == 0x10100L )
              {
                if ( (u)((w)(ax - P3_t[ bx ])) >= P3_tu[ bx ] )
                  {
                    P3_t[ bx ] = ax ;
                    lax |= 0x01000000 ;
                  }
                continue ;
              }
             else P3_t[ bx ] = ax ;
             continue ;
           }
       }
    //   Возвращение обработанных сигналов в память.
      Pi3_f.all = lax >> 16 ;
      Pi3_nm.all = lax;

           // Производим обратное инвертирование, чтобы получить
          // отфильтрованное, но ненормированное значение.
      Pi3_cf.all = Pi3_f.all ^ _r.Pi3_Normal ;
     /*ДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДД*/
    break;
  }

  return  ;
}

/*ДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДД*/


        //  Все разрозненные сигналы собираем в один порт.
void  Port_output ( void )
{
  Po0_nm.all = Po0_c.all ; // Нормализация выходных сигналов .
  mDD2_Write( Po0_nm.all );

  #ifdef _mWrite_PO1

  _mWrite_PO1( Po1_c.all );

  #endif
  return  ;
}

      //  Для программ стартовой очистки выходных портов.
void  Port_output_clr ( void )
{
  Po0_c.all = 0;
  Po1_c.all = 0;

#ifdef _PoX

  PoX_c.all = 0;

#endif

  Port_output ();
  return ;
}

#ifdef _DI8

void  Port_DI8 ( word code )
{
    _register byte  al ;
    _register word  ax , bx ;
    _register lword  lax ;

        /*   Фиксация полного времени для данного момента.
         * Полное время состоит из показаний рабочего таймера и счетчика
         * его переполнений.
         * Дискрета рабочего таймера = 0.868мксек.
         * Дискрета счетчика переполнений рабочего таймера = 0.569сек.
         *  Алгоритм считывания показаний имеет особенность из-за того,
         * что считывание производится в два приема: считывание таймера и
         * считыание счетчика переполнений - а в интервале между считываниями
         * может иметь место переполнение таймера с переносом в счетчик.
         * Если последнее не учитывать, то будет вероятна ошибка считывания.
         *   Для учета данной особености считывания используется алгоритм
         * рекомендуемый в литературе для применения в 8-разрядных микро-
         * контроллерах для считывания показаний 16-разрядных таймеров.
         *   Алгоритм, применительно к нашему случаю, заключается в следующем:
         * 1. считывание счетчика переполнений => 'ax' ;
         * 2. считывание таймера => 'bx' ;
         * 3. сравнений счетчика переполнений с ранее считанным его значением
         *    хранящимся в 'ax' ;
         * 4. при несовпадении значений, что является признаком переполнения
         *    таймера между считываниями, возврат к пункту 1.
         */
    do { ax = Timer1_Ovr , bx = timer1 ; } while ( ax != Timer1_Ovr ) ;
    ax <<= 8 ;      //  Из четырехбайтного полного значения времени
    ax  += (bx>>8); // для работы берутся средние два байта прини-
                    // мающие значения в диапазоне 0.25мсек-12.0сек.

  switch ( code )
  {    //  Стартовая инициализация.
    case 0 :

        mAI1_DD1_Read( al ) ;
        Pi4_c.all = al ;
        Pi4_cf.all = al ;
        Pi4_nm.all = Pi4_f.all = al ^ _r.Pi4_Normal ;
        for ( bx = 0 ; bx < 8 ; bx++ )  P4_t[bx] = ax ;

      break;
    //---------------------
    default:
    case 1 :


/*ДДДДДДДДДДДДДДДД  Pi4  ДДДДДДДДДДДДДДДДДДД*/

//   Нормализация, т.е. приведение посредством уставки реальных активных
// уровней сигналов к общепринятому уровню активного сигнала, и маскирование
// заданных уставкой сигналов порта.
    mAI1_DD1_Read( al ) ;
     Pi4_c.all = al ,  al ^= _r.Pi4_Normal ;

//            Фильтрация дискретных сигналов портов .
//   Фильтрация осуществляется отдельно, как для каждого из портов,
// так и для отдельных сигналов в порту.

    lax = (lw)(w)Pi4_f.all << 24 ;
    lax += (lw)(w)Pi4_nm.all << 16;
    lax += (lw)(w)al << 8 ;

    for ( bx = 0 ; bx < 8 ; bx++ , lax >>= 1 )
       {
         if((lax & 0x1000000L) != 0)
          {
             if( (lax & 0x10100L) == 0 )
              {
                if ( (u)((w)(ax - P4_t[ bx ])) >= P4_tu[ bx ] )
                  {
                    P4_t[ bx ] = ax ;
                    lax &= 0xfeffffff ;
                  }
                continue ;
              }
             else  P4_t[ bx ] = ax ;
             continue ;
          }
         else
          {
             if( (lax & 0x10100L) == 0x10100L )
              {
                if ( (u)((w)(ax - P4_t[ bx ])) >= P4_tu[ bx ] )
                  {
                    P4_t[ bx ] = ax ;
                    lax |= 0x01000000 ;
                  }
                continue ;
              }
             else P4_t[ bx ] = ax ;
             continue ;
           }
       }
    //   Возвращение обработанных сигналов в память.
      Pi4_f.all = lax >> 16 ;
      Pi4_nm.all = lax;

           // Производим обратное инвертирование, чтобы получить
          // отфильтрованное, но ненормированное значение.
      Pi4_cf.all = Pi4_f.all ^ _r.Pi4_Normal ;
     /*ДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДД*/
    break;
  }

  return  ;
}

#endif

#ifdef _PORTE2_

void  Port2_Filtr ( word code )
{
    _register byte  al ;
    _register word  ax , bx ;
    _register lword  lax ;

        /*   Фиксация полного времени для данного момента.
         * Полное время состоит из показаний рабочего таймера и счетчика
         * его переполнений.
         * Дискрета рабочего таймера = 0.868мксек.
         * Дискрета счетчика переполнений рабочего таймера = 0.569сек.
         *  Алгоритм считывания показаний имеет особенность из-за того,
         * что считывание производится в два приема: считывание таймера и
         * считыание счетчика переполнений - а в интервале между считываниями
         * может иметь место переполнение таймера с переносом в счетчик.
         * Если последнее не учитывать, то будет вероятна ошибка считывания.
         *   Для учета данной особености считывания используется алгоритм
         * рекомендуемый в литературе для применения в 8-разрядных микро-
         * контроллерах для считывания показаний 16-разрядных таймеров.
         *   Алгоритм, применительно к нашему случаю, заключается в следующем:
         * 1. считывание счетчика переполнений => 'ax' ;
         * 2. считывание таймера => 'bx' ;
         * 3. сравнений счетчика переполнений с ранее считанным его значением
         *    хранящимся в 'ax' ;
         * 4. при несовпадении значений, что является признаком переполнения
         *    таймера между считываниями, возврат к пункту 1.
         */
    do { ax = Timer1_Ovr , bx = timer1 ; } while ( ax != Timer1_Ovr ) ;
    ax <<= 8 ;      //  Из четырехбайтного полного значения времени
    ax  += (bx>>8); // для работы берутся средние два байта прини-
                    // мающие значения в диапазоне 0.25мсек-12.0сек.

  switch ( code )
  {    //  Стартовая инициализация.
    case 0 :

        mXCS6_Read( al ) ;
        Pi4_c.all = al ;
        Pi4_cf.all = al ;
        Pi4_nm.all = Pi4_f.all = al ^ _r.Pi4_Normal ;
        for ( bx = 0 ; bx < 8 ; bx++ )  P4_t[bx] = ax ;

        mXCS7_Read( al ) ;
        Pi5_c.all = al ;
        Pi5_cf.all = al ;
        Pi5_nm.all = Pi5_f.all = al ^ _r.Pi5_Normal ;
        for ( bx = 0 ; bx < 8 ; bx++ )  P5_t[bx] = ax ;

        mXCS8_Read( al ) ;
        Pi6_c.all = al ;
        Pi6_cf.all = al ;
        Pi6_nm.all = Pi6_f.all = al ^ _r.Pi6_Normal ;
        for ( bx = 0 ; bx < 8 ; bx++ )  P2_t[bx] = ax ;

      break;
    //---------------------
    default:
    case 1 :


/*ДДДДДДДДДДДДДДДД  Pi4  ДДДДДДДДДДДДДДДДДДД*/

//   Нормализация, т.е. приведение посредством уставки реальных активных
// уровней сигналов к общепринятому уровню активного сигнала, и маскирование
// заданных уставкой сигналов порта.
    mXCS6_Read( al ) ;
     Pi4_c.all = al ,  al ^= _r.Pi4_Normal ;

//            Фильтрация дискретных сигналов портов .
//   Фильтрация осуществляется отдельно, как для каждого из портов,
// так и для отдельных сигналов в порту.

    lax = (lw)(w)Pi4_f.all << 24 ;
    lax += (lw)(w)Pi4_nm.all << 16;
    lax += (lw)(w)al << 8 ;

    for ( bx = 0 ; bx < 8 ; bx++ , lax >>= 1 )
       {
         if((lax & 0x1000000L) != 0)
          {
             if( (lax & 0x10100L) == 0 )
              {
                if ( (u)((w)(ax - P4_t[ bx ])) >= P4_tu[ bx ] )
                  {
                    P4_t[ bx ] = ax ;
                    lax &= 0xfeffffff ;
                  }
                continue ;
              }
             else  P4_t[ bx ] = ax ;
             continue ;
          }
         else
          {
             if( (lax & 0x10100L) == 0x10100L )
              {
                if ( (u)((w)(ax - P4_t[ bx ])) >= P4_tu[ bx ] )
                  {
                    P4_t[ bx ] = ax ;
                    lax |= 0x01000000 ;
                  }
                continue ;
              }
             else P4_t[ bx ] = ax ;
             continue ;
           }
       }
    //   Возвращение обработанных сигналов в память.
      Pi4_f.all = lax >> 16 ;
      Pi4_nm.all = lax;

           // Производим обратное инвертирование, чтобы получить
          // отфильтрованное, но ненормированное значение.
      Pi4_cf.all = Pi4_f.all ^ _r.Pi4_Normal ;
/*ДДДДДДДДДДДДДДДД  Pi5  ДДДДДДДДДДДДДДДДДДД*/

//   Нормализация, т.е. приведение посредством уставки реальных активных
// уровней сигналов к общепринятому уровню активного сигнала, и маскирование
// заданных уставкой сигналов порта.
     mXCS7_Read( al ) ;
     Pi5_c.all = al ,  al ^= _r.Pi5_Normal ;

//            Фильтрация дискретных сигналов портов .
//   Фильтрация осуществляется отдельно, как для каждого из портов,
// так и для отдельных сигналов в порту.

    lax = (lw)(w)Pi5_f.all << 24 ;
    lax += (lw)(w)Pi5_nm.all << 16;
    lax += (lw)(w)al << 8 ;

    for ( bx = 0 ; bx < 8 ; bx++ , lax >>= 1 )
       {
         if((lax & 0x1000000L) != 0)
          {
             if( (lax & 0x10100L) == 0 )
              {
                if ( (u)((w)(ax - P5_t[ bx ])) >= P5_tu[ bx ] )
                  {
                    P5_t[ bx ] = ax ;
                    lax &= 0xfeffffff ;
                  }
                continue ;
              }
             else  P5_t[ bx ] = ax ;
             continue ;
          }
         else
          {
             if( (lax & 0x10100L) == 0x10100L )
              {
                if ( (u)((w)(ax - P5_t[ bx ])) >= P5_tu[ bx ] )
                  {
                    P5_t[ bx ] = ax ;
                    lax |= 0x01000000 ;
                  }
                continue ;
              }
             else P5_t[ bx ] = ax ;
             continue ;
           }
       }
    //   Возвращение обработанных сигналов в память.
      Pi5_f.all = lax >> 16 ;
      Pi5_nm.all = lax;

           // Производим обратное инвертирование, чтобы получить
          // отфильтрованное, но ненормированное значение.
      Pi5_cf.all = Pi5_f.all ^ _r.Pi5_Normal ;

/*ДДДДДДДДДДДДДДДД  Pi6  ДДДДДДДДДДДДДДДДДДД*/

//   Нормализация, т.е. приведение посредством уставки реальных активных
// уровней сигналов к общепринятому уровню активного сигнала, и маскирование
// заданных уставкой сигналов порта.
    mXCS8_Read( al ) ;
     Pi6_c.all = al ,  al ^= _r.Pi6_Normal ;

//            Фильтрация дискретных сигналов портов .
//   Фильтрация осуществляется отдельно, как для каждого из портов,
// так и для отдельных сигналов в порту.

    lax = (lw)(w)Pi6_f.all << 24 ;
    lax += (lw)(w)Pi6_nm.all << 16;
    lax += (lw)(w)al << 8 ;

    for ( bx = 0 ; bx < 8 ; bx++ , lax >>= 1 )
       {
         if((lax & 0x1000000L) != 0)
          {
             if( (lax & 0x10100L) == 0 )
              {
                if ( (u)((w)(ax - P6_t[ bx ])) >= P6_tu[ bx ] )
                  {
                    P6_t[ bx ] = ax ;
                    lax &= 0xfeffffff ;
                  }
                continue ;
              }
             else  P6_t[ bx ] = ax ;
             continue ;
          }
         else
          {
             if( (lax & 0x10100L) == 0x10100L )
              {
                if ( (u)((w)(ax - P6_t[ bx ])) >= P6_tu[ bx ] )
                  {
                    P6_t[ bx ] = ax ;
                    lax |= 0x01000000 ;
                  }
                continue ;
              }
             else P6_t[ bx ] = ax ;
             continue ;
           }
       }
    //   Возвращение обработанных сигналов в память.
      Pi6_f.all = lax >> 16 ;
      Pi6_nm.all = lax;

           // Производим обратное инвертирование, чтобы получить
          // отфильтрованное, но ненормированное значение.
      Pi6_cf.all = Pi6_f.all ^ _r.Pi6_Normal ;
     /*ДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДД*/
    break;
  }

  return  ;

}

#endif
