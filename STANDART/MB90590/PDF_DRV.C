
void pdf_drv_init( word num )
{
  //num = num ;

      // в prt_cpu.c // 0/0  P5.6 - TIN - вход счетного таймера (F00+F90), для ПДФ.
                     // 0/0  P0.0 - вход F00 ПДФ
                     // 0/0  P0.1 - вход F90 ПДФ
                     // 0/0  P0.2 - оборотный ПДФ
         //   Для определения направления прерываемся по переднему(заднему)
         // фронту F00, а читаем F90.
         // т.к. сигналы заведены на ЕПА, то использ. соотв.функции.
      ICS01 |= _CAP0_POS_EDGE ;  //P0.0 - вход F00 ПДФ
      ICS23 |= _CAP2_NEG_EDGE ;  //P0.2 - оборотный ПДФ
      pdf_ei (num) ; // разрешение прерывания для определения знака ПДФ .
      pdf_fz_init (num) ; // инициализация оборотного ПДФ .
      //---
      pdf_drv_data[num].Tpdf_time = timer1 ;
      pdf_drv_data[num].Tpdf      = _PDF_base_time * 5 ;
      pdf_drv_data[num].Scht_T    =  0 ;
      pdf_drv_data[num].sign      =  0 ;
      //---
    //ДДДДДДДДДДДДДДДДДДДДДДReload timer0ДДДДДДДДДДДДДДДДДДДДДДДДДД
      //DDR5_D56 = 0;    в prt_drv.c
      TMRLR0 = 0xffff; // счетчик на вычитание, перезагружаемый 0xFFFF после достижения нуля.
                      // счетчик внешних событий по обоим фронтам,
      TMCSR0 =0xd93;   //1101 1001 0011 - по внешнему входу, перезагружаемый
      //TMCSR0_TRG = 1; // запуск счетчика

  return ;
}
//-------------------

// Функция разрешения прерывания для определения знака ПДФ .
void pdf_ei ( word num )
{
  num = num ;
  ICS01_ICP0 = 0 ;        // сбрасываем запрос по ЕПА .
  ICS01_ICE0 = 1 ;        // разрешаем прерывания ЕПА .
  ICR07 = _PDF_PRIORITY ; // приоритет прерывания .
  return ;
}
//-------------------

// Функция запрета прерывания для определения знака ПДФ .
void pdf_di ( word num )
{
  num = num ;
  ICS01_ICP0 = 0 ;        // сбрасываем запрос по ЕПА .
  ICS01_ICE0 = 0 ;        // запрещаем прерывания ЕПА .
//ICR07 = _PDF_PRIORITY ; // приоритет прерывания .
  return ;
}
//-------------------

// Функция инициализации оборотного ПДФ .
void pdf_fz_init ( word num )
{
  num = num ;
  //PDF[num].fz = 0 ;     // инициализация счетчика оборотов в PDF.C .
  ICS23_ICP2 = 0 ;        // сбрасываем запрос по ЕПА .
//ICS23_ICE2 = 1 ;        // разрешаем прерывания ЕПА .
//ICR08 = __PRIORITY ;    // приоритет прерывания .
  // Прерывания по этому входу не разрешаем , и приоритет не задаем , т.к.
  // при даже при скорости 1500 об/мин , в 1 мс будет 1500/60000=0.025 оборот .
  // 0.025*360=9грд . Если такая точность удовлетворительна , то подсчет
  // оборотов можно производить в фоне .

  return ;
}
//-------------------

// Функция подсчета оборотов ПДФ и определения угла поворота ( вызывать в фоне
// или в прерывании - определить выше в инициализации pdf_fz_init () ) :
void pdf_fz ( word num )
{
  //num = num ;
  if ( ICS23_ICP2 == 1 )
   {
     if ( (sb)pdf_drv_data[num].sign > 0 ) PDF[num].fz++ ;
     else                                  PDF[num].fz-- ;
     ICS23_ICP2 = 0 ;         // сбрасываем запрос по ЕПА .
   }
  // Определение угла поворота в градусах пока не продумывал ...
  return ;
}
//-------------------

      //  чтение текущего значения счетчика импульсов,
     // счетчик считает непрерывно, не сбрасывается.
word pdf_drv_read( word num )
{
  num = num ;

  return (~TMR0) ;  // счетчик на вычитание => превращаем его на сложение.
}
//-------------------

//   Прерывания для определения направления вращения.
//   и периода импулсов.
__interrupt void pdf0_Interrupt   (void)
{
  word count , ax ;
  pP( 1 ) ;
 // ICS01_ICP0 = 0 ;  // Сброс запроса прерывания перенесён в конец функции.

 ax =  pdf_epa_time - pdf_drv_data[0].Tpdf_time ; // расчет периода импульсов ПДФ .
 pdf_drv_data[0].Tpdf_time = pdf_epa_time ; // время предыдущего прихода импульса F00 .
 //---
#ifdef _T_PDF
 // Усредненный период для скорости вычисляется только в случае, когда период между предыдущим
//и текущим импульсом меньше 50ms.
 if ( PDF[0].flg._.t_ogr_pdf != 1 )
  {
    pdf_drv_data[0].Tpdf += ax ;  // сумма периодов импульсов ПДФ .
    pdf_drv_data[0].Scht_T++ ;    // счетчик периодов импульсов ПДФ .
  }

  PDF[0].flg._.t_ogr_pdf = 0 ; // сброс флага .

 if ( (w)PDF[0].Fpdf > (c)( 20 * _PDF_Kmul ) ) // При количестве пар импульсов ( F00 и F90 )
   {                                           // больше 20 определять знак уже не надо :
    ICS01_ICP0 = 0 ;  // Сброс запроса прерывания.
    return ;
   }
#endif
  //---
     //   Для определения направления прерываемся по переднему
     // фронту F00, а читаем F90 .
     //   Базовое время ПДФ (10-2=8мс) делим на интервал между импульсами F00 .
     // Чем чаще идут импульсы , тем больше повторов знака должно накопиться .
     // Полученное при делении число пропорционально максимальному количеству
     // повторов знака скорости .
  //---
  // Базовое время - 8мс делим на время между F00 .
  count = ( (c)( _PDF_base_time * 0.8 ) ) / (u)ax ;
  //---
  if ( PDR0_P01 == 1 ) // направление Назад :
   {
     count = ~count /*+ 1*/ ; // при направлении Назад инвертируем счетчик и
     // не прибавляем 1 , чтобы +0 соответствовало -1 ( Принцип : -2 -1 | 0 1 ).
     //--- Защита от переполнений :
     if      ( (sw)count < -7 ) count = -7 ;
     else if ( (sw)count > -1 ) count = -1 ;
     //---
     ax = (sw)(sb)pdf_drv_data[0].sign ;
     ax-- ;
     if ( (sw)ax < (sw)count )  pdf_drv_data[0].sign = (sb)count ;
     else                       pdf_drv_data[0].sign = (sb)ax ;
   }
  else                 // направление Вперед :
   {
     //--- Защита от переполнений :
     if      ( (sw)count > 6 ) count = 6 ;
     //---
     ax = (sw)(sb)pdf_drv_data[0].sign ;
     ax++ ;
     if ( (sw)ax > (sw)count )  pdf_drv_data[0].sign = (sb)count ;
     else                       pdf_drv_data[0].sign = (sb)ax ;
   }
  // Сбрасываем запрос прерывания в конце , чтобы не схватить старые данные с
  // прошедшего фронта .
  ICS01_ICP0 = 0 ;  // Сброс запроса прерывания.
  pP( 0 ) ;
  return ;
}
