void sio_start(void)
{
  //„астота передачи определ€етс€ по формуле F= ‘/(SMD*div)
  //где ‘ - тактова€ частота(16ћ√ц);
  //SMD - число, задаваемое битами SMD0-SMD2 регистра SMCS
  // в зависимости от комбинации битов эточисло принимает сл. значени€:
  //  SMD2 SMD1 SMD0    значение
  //   0    0    0         2
  //   0    0    1         4
  //   0    1    0         16
  //   0    1    1         32
  //   1    0    0         64
  //div - коэфициент делени€ прескалера, определ€емый битами DIV0-DIV3 регистра CDCR
  // DIV3 DIV2 DIV1 DIV0  значение
  //  1    1    0    1       3
  //  1    1    0    0       4
  //  1    0    1    1       5
  //  1    0    1    0       6
  //  1    0    0    1       7
  //  1    0    0    0       8
  //  ¬ нашем случае частота 500 к√ц
  //    SMCS:                                             SCDR:
  //D15 SMD2  0 \                                      D7 MD   1 - прескалер вкл.
  //D14 SMD1  0  > 4                                      111  -  D4-D6 -не исп.
  //D13 SMD0  1 /
  //D12 SIE   0 - прерывани€ выключены                 D3 DIV3 1  \
  //                                                   D2 DIV2 0    \ 8
  //D11 SIR   0 - запрос прерываний                    D1 DIV1 0    /
  //D10 BUSY  0 - только чтение                        D0 DIV0 0  /
  //D9  STOP  1 - передача остановлена
  //D8  STRT  0 /

  //    0000  - D4-D7 не используютс€

  // D3 MODE  1  - передача/прием по записи/чтению SDR
  // D2 BDS   1  - передача от старшего бита
  // D1 SOE   1  - выход последовательного порта вкл.
  // D0 SCOE  1  - выход SCK вкл.

  SMCS = 0x2207;
  CDCR = 0xf8;

  SMCS_STOP = 0;
  SMCS_STRT = 1;
}
/*void sio_out(byte out)
{
  SDR = out;
  //SMCS_STRT = 1;
  while ( SMCS_BUSY == 1 );
  return ;
}
byte sio_in (void)
{
  byte ax;
  //while ( SMCS_BUSY == 1 );
  ax = SDR;
  return ax;
}*/
