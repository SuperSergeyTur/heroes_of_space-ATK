

/*  Программа инициализации послед.порта, его прерывания и буферов для прерывания.  */

void  Start_RXD_TXD ( void )
{
  Reg_ServiceMsg   = 0 ;

  Label          = 0x0u    ;

  M_FirstCall    = 1 ;
  Pult_Prog_Addr = 0 ;
  Klav_Buff = 0 ;
  m_old = 0 ;

  Count_SymbolPauza = _SymbolPauza ;

    Mon.Pult  = 1  ;
//    Mon.Parolle = 0  ;
    Mon.EnableSrvMsg = 1 ;
//    Mon.Otkl_InOut = 0 ;

    Mon.i2c_busy = 0 ;
    Mon.RXBuffOverflow = 0 ;

  OutTxBuffCount = 0x0u   ;
  InTxBuffCount  = 0x01u  ;
  OutRxBuffCount = 0x0u   ;
  InRxBuffCount  = 0x01u  ;

  Mon.UartCAN_Connect = 0 ;
  Mon.RX_Data_ok = 0 ;

/*  'HARDWARE' ИНИЦИАЛИЗАЦИЯ  */

  TXD_FREE = 1 ;

  URD0 = 0x2C;
 // BCH = 0, RC3 = 0, RC2 =1, RC1 =0, RC0 =1 , BCH0 =1, P= 0, D8 =0
  //при 16Мгц/4, baud = 19200.

  DDR3_D34 = 1 ;  // Pins: SOT0 - выход
  DDR3_D36 = 0 ;  //       SIN0 - вход

  UMC0 = 0x19;
  //PEN = 0, SBL =0, MC1 =0, MC0 = 1, SMDE = 1, RFC =0 , SCKE = 0, SOE = 1

  USR0 = 0x08;
  //RDRF = 0, ORFE = 0, PE = 0, TDRE = 0, RIE = 1, TIE = 0, RBF = 0, TBF = 0

    ICR12 = 6;      /*  IRQ35
                        IRQ36 */
  asm_ei() ;

  return   ;
}
/*ДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДД-  */

  void  Speed_Pult ( void )
{
    if ( Mon.Pult != 1 )
      {
        //USR0_TIE = 0 ;
        Mon.Pult = 1 ;  // устанавливать после запрета прерывания TXD
      }
    else
      {
        Mon.Pult = 0 ;  // устанавливать до разрешения прерывания  TXD
        //USR0_TIE = 1 ;
      }
    Pult_Prog_Addr = _MainPultProg  ;
    return ;
}

      /*   "TXE_BIT" - в режиме TXD признак того, что из буфера вывода все выбрано,
       * прерывания прекратились и сами по себе не возобновятся, даже если в буфере
       * вывода появятся данные => прерывание нужно вызвать искусственно.
       *   Если установлен бит "Mon.Pult" - признак медленного вывода через ЕПА,
       * то вышесказанное неверно и "искусственных" записей в  порт делать не надо.
       */
void   mRestart_Output( void )
{        /* если порт свободен и есть данные на вывод ...  */
    if ( ( TXD_FREE == 1  ) && ( mTestYesData_in_Buff_TXD() ) )
    {     /*  и пульт не в режиме медленного вывода то запускаем прерывания: */
         /* разрешаем прерыв., а т.к. TDRE всегда взведен, то прерыв. сразу сработает. */
      if ( Mon.Pult == 0 && Mon.UartCAN_Connect == 0 ) USR0_TIE = 1 ;
    }
  return ;
}
/*ДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДД-  */

/*   П/п обработки прерываний от последовательного порта по приему.
 *  Принятые байты заносятся в буфер 'RxBuff[]' (массив типа 'unsigned char')
 * в ячейку на которую указывает указатель "InRxBuffCount". После записи
 * очередного символа этот указатель увеличивается на единицу, таким образом
 * он всегда указывает на ячейку в которую будет записан следующий байт
 * (т.е. на пустую). Если указатель дошел до конца буфера , то он возвра-
 * щается снова к его началу и так по кругу. Для того чтобы не надо было
 * контролировать достижение
 * указателем конца буфера размер буфера "RxBuffSize+1" принимается равным 2,4,
 * 8,16,32,64,128,256. В этом случае величина указателя не выходит за сетку
 * 1,2,3,4,5,6,7,8-ми младших битов. Поэтому перемещение указателя к следующей
 * позиции осуществляется так:
 *      InRxBuffCount = ( InRxBuffCount + 1 ) & RxBuffSize ;
 * увеличивается на единицу и на него накладывается маска обрезающая ненужные
 * старшие биты. Таким вот образом имитируется 1,2,3,4,5,6,7,8-ми битовое поле
 * сетки указателя и он, дойдя до конца буфера, в результате "переполнения" своей
 * сетки сам возвращается к началу буфера.
 *  Считывание данных из буфера рабочей программой производится посредством
 * указателя "OutRxBuffCount". Организация этого указателя абсолютно идентична
 * вышеописанной. Он всегда указывает на ячейку из которой ранее было произведено
 * считывание (т.е.пустую). По-этому перед считыванием его следует увеличить на
 * единицу операцией :
 *     "OutRxBuffCount = ( OutRxBuffCount + 1 ) & RxBuffSize ;" ,
 * а после этого прочитать байт из буфера. Указатель "OutRxBuffCount" всегда
 * "отстает" от "InRxBuffCount". Перед считыванием данных из буфера следует
 * убедиться , что они там есть. Для этого необходимо проверить не сравняется
 * ли указатель считывания с указателем записи если первый увеличить на единицу.
 * Если оказывается что они в результате этого станут равными - значит буфер пуст.
 *   Аналогично перед записью данных в буфер в прерывании следует убедиться, что в буфере
 * еще оталось место. Для этого необходимо проверить не сравняется ли указатель
 * записи с указателем считывания если первый увеличить на единицу.
 * Если оказывается что они в результате этого станут равными - значит в буфере
 * места нет и принятый байт записывать некуда, при этом устанавливается
 * признак переполнения "Mon.RXBuffOverflow = 1" и принятый байт теряется.
 */
/*    При считывании "sp_stat" сбрасывается все биты кроме TXE, сколько бы
 * Вы его не считывали.
 *    "TXE" сбрасывается только после записи в порт "TX" одного и более
 * символа, т.е. тогда, когда !сдвиговый регистр! на передачу перестает быть
 * пустым.
 *    А устанавливается "TXE" тогда, когда пуст !сдвиговый регистр! на
 * передачу, т.е. он из себя все выпихнул и поле этого в него ничего не
 * провалилось из его аппаратного буфера порта "TX" => пусты и сдвиговый
 * регистр и его буфер.
 *    При пустых сдвиговом регистре и его буфере в порт TX можно записывать
 * подряд без малейшей задержки два символа. Если записать больше, то
 * все остальные кроме первого будут потеряны.
 *
 *  В связи с вышесказанным в "pts-RXD" можно считывать при приеме пословно,
 * т.к. "sbuf_rx" и "sp_stat" расположены рядом и не бояться, что будет
 * закрыта от "TXD" его личная информация, кроме бита "TI", который при
 * работе в режиме прерываний и не нужен.
 */
__interrupt void RXD_Interrupt (void)
{
  static char al ;

    asm_ei() ;

    if ( USR0_ORFE == 1 || USR0_PE == 1 )
    {
      al = UIDR0 ; //чтобы сбросить запрос, для OVERRUN ERROR
      UMC0_RFC = 0 ; //чтобы сбросить запрос, для FRAMING and PARITY ERROR
    }
    else
    {
      //if ( Mon.UartCAN_Connect == 0 ) mSymbol_in_Buff_RXD( UIDR0 ) ;
      //else al = UIDR0 ;
      mSymbol_in_Buff_RXD( UIDR0 ) ;
      Mon.RX_Data_ok = 1 ;
    }
    return ;
}
/*---------------------------------------------------*/
/*   Прерывание от последовательного порта по передаче генерируется тогда,
 *  когда из сдвигового регистра начал передаваться последний бит передавае-
 * мого байта.
 *   П/п обработки прерываний от последовательного порта по передаче.
 *  Передаваемый байт заносится предварительно рабочей программой в буфер
 * 'TxBuff[]' (массив типа 'byte')
 * в ячейку на которую указывает указатель "InTxBuffCount". После записи
 * очередного символа этот указатель должен увеличиваться на единицу, таким образом
 * он всегда указывает на ячейку в которую следует заносить следующий байт
 * (т.е. на пустую). Если указатель дошел до конца буфера , то его возвра-
 * щают снова к его началу и так по кругу. Для того чтобы не надо было
 * контролировать достижение
 * указателем конца буфера, размер буфера "TxBuffSize+1" принимается равным 2,4,
 * 8,16,32,64,128,256. В этом случае величина указателя не выходит за сетку
 * 1,2,3,4,5,6,7,8-ми младших битов. Поэтому перемещение указателя к следующей
 * позиции осуществляется так:
 *     "InTxBuffCount = ( InTxBuffCount + 1 ) & TxBuffSize ;"  -  указатель
 * увеличивается на единицу и на него накладывается маска обрезающая ненужные
 * старшие биты. Таким вот образом имитируется 1,2,3,4,5,6,7,8-ми битовое поле
 * сетки указателя и он, дойдя до конца буфера, в результате "переполнения"
 * своей сетки сам возвращается к началу буфера.
 *  Считывание данных из буфера подпрограммой прерывания производится посредством
 * указателя "OutTxBuffCount". Организация этого указателя абсолютно идентична
 * вышеописанной. Он всегда указывает на ячейку из которой ранее было произведено
 * считывание (т.е.пустую). По-этому перед считыванием его следует увеличить на
 * единицу операцией :
 *      OutTxBuffCount = ( OutTxBuffCount + 1 ) & TxBuffSize ;
 * а после этого прочитать байт из буфера и записать его в буфер порта
 * "sbuf_tx" (если он, конечно, свободен).
 * Указатель "OutTxBuffCount" всегда "отстает" от "InTxBuffCount".
 * Перед считыванием в прерывании данных из буфера следует
 * убедиться , что они там есть. Для этого необходимо проверить не сравняется
 * ли указатель считывания с указателем записи, если первый увеличить на единицу.
 * Если оказывается что они в результате этого станут равными - значит буфер пуст.
 *   Аналогично перед записью данных в буфер в рабочей программе следует
 * убедиться, что в буфере еще осталось место. Для этого необходимо проверить
 * не сравняется ли указатель записи с указателем считывания если первый
 * увеличить на единицу. Если оказывается, что они в результате этого станут
 * равными - значит в буфере места нет и принятый байт записывать некуда, при
 * этом следует либо подождать пока место появится, либо проигнорировать это
 * обстоятельство.
 *  Примечание: порт 'TXD' имеет буфер, что позволяет загружать в порт сразу
 * по два байта и, в результате, передавать их друг после друга без малейшей
 * задержки, непрерывной чередой. Это классно, это огромное достоинство. Но
 * это может стать не посилам медленно принимающей стороне и она не будет
 * успевать вынимать принимаемые байты из своего порта и, в результате, терять
 * их. На этот случай предусмотрена возможность запрета записи в буфер порта
 * второго байта, что приведет к появлению некоторой задержки между передачами
 * отдельных байт, равной минимум времени обработки самого прерывания от 'TXD',
 * и это облегчит условия работы принимающей стороны. Запрет осуществляется
 * установкой в единицу признака " Mon.TXD_PoOdnomuBytu ".
 */

__interrupt void TXD_Interrupt (void)
{
  asm_ei() ;

     /*    Пуст и буфер и сдвигающий регистр => запись в порт первого символа
      * (если таковые в буфере есть), который сразу провалится в сдвигающий
      * регистр. */
    if ( mTestYesData_in_Buff_TXD() && Mon.UartCAN_Connect == 0 )
    {
      mSymbol_from_Buff_TXD( UODR0 ) ;
      TXD_FREE = 0 ;
    }
    else
    {
      USR0_TIE = 0 ;  // запрещаем прерывания TXD, т.к. бит запроса
      TXD_FREE = 1 ; // прерыв. при отсутствии данных ничем не сбрасыв-ся.
    }
     /* Несброшенный "TXE_BIT" - признак того, что из буфера вывода все выбрано,
      * прерывания прекратились и сами по себе не возобновятся, даже если в
      * буфере вывода появятся данные.
      * Если в буфере вывода снова появится информация, то чтобы возобновить
      * череду прерываний для ее вывода в порт, необходимо "искусственно"
      * вызвать прерывание. */
  return   ;
}
void Set_Uart_Speed (word baud)
{
    word ax;
    ax = baud;
}
