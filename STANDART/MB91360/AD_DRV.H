#ifndef _ad_drv_h
#define _ad_drv_h
//---------------

extern void  Start_AD ( void ) ;

#define AdBuffSize            ((b) 0x0f)  /* все мл.разряды в указателе
                                           * размера должны быть запол-
                                           * нены единицами    */


struct Channel_AD {  word mux  ;
                     word offset ; } ;

//  Для AD Converter

#define  _AD_BUSY  ( 0x8000 ) // можно задать любой бит старше D9...D0.

#define  _AD_MAX   ( 511 )
#define  _AD_VOLT  ( 205 ) // дискрет на 1вольт

#define  _AD_MaxOffset  ( 1023 )
#define  _AD_Delta      ( 1 )

#define  _Ch0_Numb     0x0000
#define  _Ch1_Numb     0x0001
#define  _Ch2_Numb     0x0002
#define  _Ch3_Numb     0x0003
#define  _Ch4_Numb     0x0004
#define  _Ch5_Numb     0x0005
#define  _Ch6_Numb     0x0006
#define  _Ch7_Numb     0x0007
#define  _Ch8_Numb     0x0008
#define  _Ch9_Numb     0x0009
#define  _Ch10_Numb    0x000a
#define  _Ch11_Numb    0x000b
#define  _Ch12_Numb    0x000c
#define  _Ch13_Numb    0x000d
#define  _Ch14_Numb    0x000e
//----------------------------------------------
//     Т.к. время преобразования АЦП всего 6мксек то прерывания
//  по готовности АЦП и организация очереди при наложении измерений
//  не предусматриваются, НО ИММИТИРУЕТСЯ ВИДИМОСТЬ ЭТОГО ДЛЯ СОВМЕСТИМОСТИ
//  С ПРОГРАММАМИ MCS196.

/*   П/п запуска АЦП на измерение либо, при занятости АЦП, занесения измерения
 * в очередь. При этом используются два буфера:  "AdBuff_AddrResult[]" и
 * "AdBuff_Command[]". В первый из них рабочей программой заносятся адреса
 * ячеек, в которые необходимо помещать результаты измерений АЦП, а во
 * второй - управляющие слова для мультиплексора АЦП, которыми в случае
 * наличия очереди измерений подключается нужный канал мультиплекора и АЦП
 * тут же из прерывания будет запускаться на новое измерение.
 * Вышесказанное относится к случаю когда при необходимости сделать измерение
 * оказывается, что АЦП занят т.е. существует очередь. В случае же когда очередь
 * исчерпана и АЦП свободен, признаком чего является взведенный бит "Flg.NoAdBuffInfo"
 * (см.ниже),  рабочая программа, при необходимости измерения, должна
 * сама по управляющему слову мультиплексора подключить нужный канал и запустить
 * АЦП, а адрес ячейки, в которую необходимо будет положить результат измерения,
 * занести в буфер адресов по индексу "OutAdBuffCount", а не "InAdBuffCount"
 * т.к управляющее слово заносилось прямо в АЦП, а не в очередь.
 *  Считывание данных из буфера очереди подпрограммой прерывания производится
 * посредством указателя "OutAdBuffCount". Организация этого указателя
 * абсолютно идентична вышеописанной.
 *   Перед записью данных в буфер измерений в рабочей программе следует
 * убедиться (чего с целью экономии времени не сделано), что в буфере еще
 * осталось место. Для этого необходимо проверить
 * не сравняется ли указатель записи с указателем считывания если первый
 * увеличить на единицу. Если оказывается, что они в результате этого станут
 * равными - значит в буфере места нет и принятый байт записывать некуда, при
 * этом следует либо подождать пока место появится, либо проигнорировать это
 * обстоятельство.
 */
     /*   Благодаря макросу сокращается 9 команд передачи параметров.
      *
      *   На время операций с буферами во избежание накладок запрещаются
      * прерывания.
      *   В связи с этим установку контрольного бита готовности в ячейке
      * результата надо делать до входа в подпрограмму и НЕЛЬЗЯ после "ei",
      * т.к. тут же после "ei" программа может сразу же вскочить в прерывание
      * за его время АЦП досчитает, запишет в ячейку результат, а мы его
      * сбросим и будем долго ждать у моря погоды.
 * * **
 *
 * struct Channel_AD ach - имя структуры данных для канала АЦП по которому
 *              производится измерение; из этой структуры макрос извлечет
 *              управляющее слово для мультиплексоров данного канала.
 * word* AddrResult - адрес ячейки в которую следует поместить результат
 *                    этого измерения.
 */

   //   _Port_MuxAD = (b) ( (ach).mux >> 8 ) ;                    \
   //   for( RL = (b)timer1; (b)((b)timer1 - RL) < _r.AD_pause;); \

      //   Макрос запуска и ожидания готовности измерения, с помещением
    //  необработанного результат измерения в заданную переменную.

#define mAD_Izm( ach , AddrResult ) asm_di() ;\
        ADCH  = ((b)(ach).mux & 0x0f) | (((b)(ach).mux & 0x0f) << 4) ; \
        ADCS = 0x82; \
      while( ADCS_INT == 0 ) ;\
        ADCS_INT = 0 ;\
      *AddrResult = ADCD;\
      asm_ei()
// конец макроса

//-------------------------
     /*   АЦП 10-разрядный однополярный. Для измерения двухполярных
      * сигналов сигнал на входе АЦП смещен вверх, примерно, на пол-питания,
      * поэтому после преобразования необходимо вычитать из результата
      * смещение "_r.IzmSmech" равное, примерно, пол-шкалы АЦП.
      *   Вычитание производится таким образом, чтобы получить положитель-
      * ный модуль результата измерения.
      *   В итоге преобразования получаем стандартное знаковое двухбайтное
      * число.
 * * **
 *
 * word  src  - источник: преобразуемый результат измерения в формате
 *                        регистра АЦП "ad_result";
 * word  dest - адресат: ячейка в которую следует поместить результат
 *                       этого преобразования.
 * struct Channel_AD ach - имя структуры данных для канала АЦП по которому
 *              производится измерение; из этой структуры макрос извлечет
 *              смещение для данного канала АЦП.
 */

     // ADCR:-> S10=0 ,ST1=0 ,ST0=1 ,CT1=1 ,CT0=0 ,RES=0 ,D9...D0=0
        /* преобразование со своим смещением в знаковое  */
#define  mIzmData_Conversion( src , dest , ach )  dest = ( (w)(src) & 0x3FF ) - (ach).offset
/* конец макроса  */


//---------------
#endif
