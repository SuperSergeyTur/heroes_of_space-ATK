
#ifndef _asm_def
#define _asm_def

#ifdef _MAIN_INCLUDE

word   flg_nul;
lword  lw_src1, lw_src2 ;
slword slw_src1, slw_src2 ;
//lword  *lw_src2 ;
word  w_src1 , w_src2 ;
 byte  b_src1 , b_src2 ;
 sbyte sb_src1 ,sb_src2 ;

#else

extern word   flg_nul;
extern lword  lw_src1, lw_src2 ;
extern slword  slw_src1, slw_src2 ;
//extern lword  *lw_src2;
extern  lword  w_src1 , w_src2 ;
extern  byte  b_src1 , b_src2 ;
extern sbyte sb_src1 ,sb_src2 ;

#endif

/*ДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДД-*/

/*   Макрос для знакового и беззнакового умножения операндов из двух источников
 * и размещением результата в приемнике.
 *   Параметры:
 *      src1  -  первый источник - двухбайтный, задается любым типом адресации;
 *      src2  -  второй источник - двухбайтный, задается любым типом адресации;
 *      dest  -  приемник - четырехбайтный, задается регистровым типом адресации.
 */
#define   asm_mul( dest , src1 , src2 )  dest =  __mul( src1 , src2 )
                 /*asm {                        \
                         ld   dest  , src1 ;    \
                         mul  dest  , src2 ;    \
                       }
                 */
#define   asm_mulu( dest , src1 , src2 )  dest =  __mulu( src1 , src2 )
                 /*asm {                        \
                         ld   dest  , src1 ;    \
                         mulu dest  , src2 ;    \
                       }
                 */
/*ДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДД-*/

/*   Макросы для знакового и беззнакового деления (четырехбайтного на
 * двухбайтное) из двух источников и размещением результата в первом источнике.
 *   Параметры:
 *      src1  - перед делением, как первый источник:
                - делимое  - четырехбайтный, задается регистровым типом адресации;
 *            - после деления, как приемник:
 *              -  младшее слово - целая часть результата ;
 *              -  старшее слово - остаток результата ;
 *      src2  -  второй источник - делитель - двухбайтный, задается любым типом адресации.
 */
      /* src1 = __div( src1, src2 )*/
#define   asm_div( src1, src2 ) \
{  \
    src1 =(src1/src2);\
}

#define   asm_divu( src1, src2 )    \
{           lw_src1 = src1 ;  \
            lw_src2 = src2 ;  \
            __asm( " stm ( r2, r3 ,r13 ) "); \
            __asm(" ldi:32 #_lw_src1, r13 ");  \
            __asm(" ld @r13, r2 ");  \
            __asm(" mov  r2 , mdl ");   \
            __asm(" ldi:32 #_lw_src2, r3 ");  \
            __asm(" ld @r3, r2 ");  \
            __asm(" div0u r2"); \
            __asm(" div1 r2"); \
            __asm(" div1 r2"); \
            __asm(" div1 r2"); \
            __asm(" div1 r2"); \
            __asm(" div1 r2"); \
            __asm(" div1 r2"); \
            __asm(" div1 r2"); \
            __asm(" div1 r2"); \
            __asm(" div1 r2"); \
            __asm(" div1 r2"); \
            __asm(" div1 r2"); \
            __asm(" div1 r2"); \
            __asm(" div1 r2"); \
            __asm(" div1 r2"); \
            __asm(" div1 r2"); \
            __asm(" div1 r2"); \
            __asm(" div1 r2"); \
            __asm(" div1 r2"); \
            __asm(" div1 r2"); \
            __asm(" div1 r2"); \
            __asm(" div1 r2"); \
            __asm(" div1 r2"); \
            __asm(" div1 r2"); \
            __asm(" div1 r2"); \
            __asm(" div1 r2"); \
            __asm(" div1 r2"); \
            __asm(" div1 r2"); \
            __asm(" div1 r2"); \
            __asm(" div1 r2"); \
            __asm(" div1 r2"); \
            __asm(" div1 r2"); \
            __asm(" div1 r2"); \
            __asm(" mov mdh, r3"); \
            __asm(" lsl #16, r3"); \
            __asm(" ldi:32 #_lw_src1, r13 ");  \
            __asm(" st r3, @r13"); \
            src1 = lw_src1;\
            __asm(" mov mdl, r3"); \
            __asm(" ldi #65535, r2 ");  \
            __asm(" and r2, r3 ");  \
            __asm(" ldi:32 #_lw_src1, r13 ");  \
            __asm(" st r3, @r13"); \
            src1 +=lw_src1 ;\
            __asm(" ldm ( r2, r3, r13)"); \
          }



/*ДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДД-*/

/*   Макросы для знакового и беззнакового деления (двухбайтного на
 * однобайтное) из двух источников и размещением результата в первом источнике.
 *   Параметры:
 *      src1  - перед делением, как первый источник:
                - делимое  - двухбайтный, задается регистровым типом адресации;
 *            - после деления, как приемник:
 *              -  младший байт - целая часть результата ;
 *              -  старший байт - остаток результата ;
 *      src2  -  второй источник - делитель - однобайтный, задается любым типом адресации.
 */
/*            __asm(" extsb r2 ");  \
            __asm(" extsh r2 ");  \*/

#define   asm_divb( src1,src2 )      \
{            lw_src1 = src1 ;  \
             lw_src2 = src2 ;  \
            __asm( " stm ( r2, r3 ,r13 ) "); \
            __asm(" ldi:32 #_lw_src1, r13 ");  \
            __asm(" lduh @r13, r2 ");  \
            __asm(" mov  r2 , mdl ");   \
            __asm(" ldi:32 #_lw_src2, r3 ");  \
            __asm(" ldub @r3, r2 ");  \
            __asm(" div0s r2"); \
            __asm(" div1 r2"); \
            __asm(" div1 r2"); \
            __asm(" div1 r2"); \
            __asm(" div1 r2"); \
            __asm(" div1 r2"); \
            __asm(" div1 r2"); \
            __asm(" div1 r2"); \
            __asm(" div1 r2"); \
            __asm(" div1 r2"); \
            __asm(" div1 r2"); \
            __asm(" div1 r2"); \
            __asm(" div1 r2"); \
            __asm(" div1 r2"); \
            __asm(" div1 r2"); \
            __asm(" div1 r2"); \
            __asm(" div1 r2"); \
            __asm(" div1 r2"); \
            __asm(" div1 r2"); \
            __asm(" div1 r2"); \
            __asm(" div1 r2"); \
            __asm(" div1 r2"); \
            __asm(" div1 r2"); \
            __asm(" div1 r2"); \
            __asm(" div1 r2"); \
            __asm(" div1 r2"); \
            __asm(" div1 r2"); \
            __asm(" div1 r2"); \
            __asm(" div1 r2"); \
            __asm(" div1 r2"); \
            __asm(" div1 r2"); \
            __asm(" div1 r2"); \
            __asm(" div1 r2"); \
            __asm(" div2 r2"); \
            __asm(" div3"); \
            __asm(" div4s"); \
            __asm(" mov mdh, r3"); \
            __asm(" lsl #8, r3"); \
            __asm(" ldi:32 #_lw_src1, r13 ");  \
            __asm(" st r3, @r13"); \
            src1 = lw_src1;\
            __asm(" mov mdl, r3"); \
            __asm(" ldi #255, r2 ");  \
            __asm(" and r2, r3 ");  \
            __asm(" ldi:32 #_lw_src1, r13 ");  \
            __asm(" st r3, @r13"); \
            src1 +=lw_src1 ;\
            __asm(" ldm ( r2, r3, r13)"); \
}

#define   asm_divub( src1, src2 )     \
{           lw_src1 = src1 ;  \
            lw_src2 = src2 ;  \
            __asm( " stm ( r2, r3 ,r13 ) "); \
            __asm(" ldi:32 #_lw_src1, r13 ");  \
            __asm(" ld @r13, r2 ");  \
            __asm(" mov  r2 , mdl ");   \
            __asm(" ldi:32 #_lw_src2, r3 ");  \
            __asm(" ld @r3, r2 ");  \
            __asm(" div0u r2"); \
            __asm(" div1 r2"); \
            __asm(" div1 r2"); \
            __asm(" div1 r2"); \
            __asm(" div1 r2"); \
            __asm(" div1 r2"); \
            __asm(" div1 r2"); \
            __asm(" div1 r2"); \
            __asm(" div1 r2"); \
            __asm(" div1 r2"); \
            __asm(" div1 r2"); \
            __asm(" div1 r2"); \
            __asm(" div1 r2"); \
            __asm(" div1 r2"); \
            __asm(" div1 r2"); \
            __asm(" div1 r2"); \
            __asm(" div1 r2"); \
            __asm(" div1 r2"); \
            __asm(" div1 r2"); \
            __asm(" div1 r2"); \
            __asm(" div1 r2"); \
            __asm(" div1 r2"); \
            __asm(" div1 r2"); \
            __asm(" div1 r2"); \
            __asm(" div1 r2"); \
            __asm(" div1 r2"); \
            __asm(" div1 r2"); \
            __asm(" div1 r2"); \
            __asm(" div1 r2"); \
            __asm(" div1 r2"); \
            __asm(" div1 r2"); \
            __asm(" div1 r2"); \
            __asm(" div1 r2"); \
            __asm(" mov mdh, r3"); \
            __asm(" lsl #8, r3"); \
            __asm(" ldi:32 #_lw_src1, r13 ");  \
            __asm(" st r3, @r13"); \
            src1 = lw_src1;\
            __asm(" mov mdl, r3"); \
            __asm(" ldi #255, r2 ");  \
            __asm(" and r2, r3 ");  \
            __asm(" ldi:32 #_lw_src1, r13 ");  \
            __asm(" st r3, @r13"); \
            src1 +=lw_src1 ;\
            __asm(" ldm ( r2, r3, r13)"); \
          }

/*
 */
/*ДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДД-*/

/*   Макрос для пересылки двухбайтного операнда из источника в приемник.
 *   Параметры:
 *      src   -  источник - двухбайтный, задается любым типом адресации;
 *      dest  -  приемник - двухбайтный, задается регистровым типом адресации.
 */
/*#define   asm_ld( dest , src )                \
                 asm {                        \
                       ld   dest  , src ;     \
                     }*/

/*   Макрос для пересылки однобайтного операнда из источника в приемник.
 *   Параметры:
 *      src   -  источник - однобайтный, задается любым типом адресации;
 *      dest  -  приемник - однобайтный, задается регистровым типом адресации.
 */
/*#define   asm_ldb( dest , src )               \
                 asm {                        \
                       ldb   dest  , src ;    \
                     }*/

/*   Макрос для пересылки двухбайтного операнда из источника в приемник.
 *   Параметры:
 *      src   -  источник - двухбайтный, задается любым типом адресации;
 *      dest  -  приемник - двухбайтный, задается регистровым типом адресации.
 */
/*#define   asm_st( src , dest )                \
                 asm {                        \
                       st   scr  , dest ;     \
                     }*/

/*   Макрос для пересылки однобайтного операнда из источника в приемник.
 *   Параметры:
 *      src   -  источник - однобайтный, задается любым типом адресации;
 *      dest  -  приемник - однобайтный, задается регистровым типом адресации.
 */
/*#define   asm_stb( src , dest )               \
                 asm {                        \
                       stb   src , dest  ;    \
                     }*/

/*ДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДД-*/

/*   Макросы для логических операций. */
/*   Логическое "И" - параметры:
 *      src   -  источник - задается любым типом адресации;
 *      dest  -  источник/приемник - задается регистровым типом адресации.
 */
/*#define   asm_and( dest , src )               \
                 asm {                        \
                       and   dest  , src ;    \
                     }

#define   asm_andb( dest , src )               \
                 asm {                         \
                       andb   dest  , src ;    \
                     }*/

/*   Логическое "ИЛИ" - параметры:
 *      src   -  источник - задается любым типом адресации;
 *      dest  -  источник/приемник - задается регистровым типом адресации.
 */
/*#define   asm_or( dest , src )               \
                 asm {                       \
                       or   dest  , src ;    \
                     }

#define   asm_orb( dest , src )               \
                 asm {                        \
                       orb   dest  , src ;    \
                     }*/

/*ДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДД-*/

/*   Макросы для команды сравнения. */
/*   Параметры:
 *      src1  -  источник - задается регистровым типом адресации;
 *      src2  -  источник - задается любым типом адресации.
 */
/*#define   asm_cmp( src1 , src2 )               \
                 asm {                         \
                       cmp   src1 , src2 ;     \
                     }*/

/*ДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДД-*/

/*   Макросы для двухбайтного команд сдвига. */
/*   Параметры:
 *      src1  -  источник/приемник - сдвигаемый операнд, задается регистровым типом адресации;
 *      src2  -  источник - количество сдвигов, задается любым типом адресации.
 */
/*#define   asm_shl( src1 , src2 )               \
                 asm {                         \
                       shl   src1 , src2 ;     \
                     }

#define   asm_shr( src1 , src2 )               \
                 asm {                         \
                       shr   src1 , src2 ;     \
                     }*/
/*ДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДД-*/

/*   Макросы работы со стеком.
 *   Параметры:
 *      src   -  источник - двухбайтный, задается любым типом адресации;
 */
/*#define   asm_push( src )            \
                 asm {               \
                       push  src  ;  \
                     }

#define   asm_pop( src )             \
                 asm {               \
                       pop  src  ;   \
                     }*/

/*ДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДД-*/

/*   Макрос очистки (обнуления) операнда.
 *   Параметры:
 *      src   -  обнуляемый операнд - двухбайтный.
 */
/*#define   asm_clr( src )                      \
                 asm {                        \
                       clr  src ;             \
                     }*/

/*ДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДД-*/

/*   Макросы проверки признака нуля. */

/*   Параметры:
 *      label  -  метка перехода в случае не нуля.
 */
#define   asm_bne( label )   if (flg_nul == 0) goto label  \
/*ДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДД-*/

/*   Макросы проверки признака знака "минус".   */

/*   Параметры:
 *      label  -  метка перехода в случае 'минуса'.
 */
/*#define   asm_blt( label )                    \
                 asm {                        \
                       blt  label ;           \
                     }*/

/*ДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДД-*/

/*   Макросы проверки признака переполнения. */

/*   Параметры:
 *      label  -  метка перехода в случае отсутствия переполнения.
 */
/*#define   asm_bnv( label )                    \
                 asm {                        \
                       bnv  label ;           \
                     }*/

/*   Параметры:
 *      label  -  метка перехода в случае наличия переполнения.
 */
/*#define   asm_bv( label )                     \
                 asm {                        \
                       bv  label ;            \
                     }*/

/*   Макросы проверки признака переноса. */

/*   Параметры:
 *      label  -  метка перехода в случае признак переноса очищен.
 */
/*#define   asm_bnc( label )                    \
                 asm {                        \
                       bnc  label ;           \
                     }*/

/*   Макросы проверки признаков нуля и переноса. */

/*   Параметры:
 *      label  -  метка перехода в случае если "больше".
 */
/*#define   asm_bh( label )                    \
                 asm {                       \
                       bh  label ;           \
                     }*/

/*ДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДД-*/

/*   Макросы тестирования заданного бита в заданном байте и перехода. */

/*   Параметры:
 *      src1   -  заданный байт.
 *      src2   -  заданый бит в заданном байте.
 *      label  -  метка перехода в случае нулевого значения бита.
 */
/*#define   asm_bbc( src1 , src2 , label )       \
                 asm {                         \
                       bbc src1, src2, label ; \
                     }*/

/*   Параметры:
 *      src1   -  заданный байт.
 *      src2   -  заданый бит в заданном байте.
 *      label  -  метка перехода в случае единичного значения бита.
 */
/*#define   asm_bbs( src1 , src2 , label )       \
                 asm {                         \
                       bbs src1, src2, label ; \
                     }*/

/*ДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДД-*/

/*   Макросы запрета/разрешения прерываний. */

/*  Без параметров.
 */
#define   asm_ei()     __EI()
                 /*asm {               \
                        ei ;           \
                       }
                 */
#define   asm_di()      __DI()
                 /*asm {                \
                         di ;           \
                       }
                 */

/*   Макросы запрета/разрешения pts-прерываний. */

/*  Без параметров.
 */
#define   asm_epts()
                /* asm {                \
                         epts ;         \
                       }
                */
#define   asm_dpts()
                /* asm {                \
                         dpts ;         \
                       }
                */

/*   Макрос сброса процессора. */

/*  Без параметров.
 */
#define   asm_rst()  __asm("reset")

/*   Макрос холостой операции. */

/*  Без параметров.
 */
#define   asm_nop()  __asm("nop")

/*ДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДД-*/

/*   Макрос для команды нормализации четырехбайтного операнда.
 *   Параметры:
 *      src   -  источник - четырехбайтный, задается регистровым типом адресации;
 *      dest  -  приемник - однобайтный, задается регистровым типом адресации.
 */
#define   asm_norml( src , dest )     \
                 { \
                   for (dest = 0; (slw)src >=  0; ++ dest) \
                   {\
                     src<<=1;\
                     if ( dest > 31) \
                     {\
                       break;\
                     }\
                   }\
                   if(src == 0) flg_nul = 1;\
                   else flg_nul = 0;\
                 }
/*ДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДД-*/

/*   Макрос для команды обмена местами двух однобайтных операндов.
 *   Параметры:
 *      src1  -  первый источник/приемник, задается регистровым типом адресации;
 *      src2  -  второй источник/приемник, задается любым типом адресации;
 */
/*#define   asm_xchb( src1 , src2 )             \
                 asm {                        \
                       xchb src1 , src2 ;     \
                     }*/

/*ДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДД-*/


#endif

