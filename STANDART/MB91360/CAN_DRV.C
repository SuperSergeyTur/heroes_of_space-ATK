
//  Для Fujitsu 21-11-2002
/*  Справка:
  Осталась некорректность в xInit_msgP( word cmd, byte port, byte n_obj, MO_id ):
  - объекты для передачи подготовлены, но DATA[0,...,7] НЕ ГОТОВА.
    (просто для передатчика это не страшно, т. к. при передаче подготовятся,
    но если будет запрос удаленного фреймв к этому МО, - получат ложные данные).

в Load_ptr(byte port, int buf,struct canMSG_Fuj *ptr) готовим данные
   IDRX0(buf) = ptr->id ; (это лишнее)
   DLCR0(buf) = ptr->cfg.dlen ;
   DTR0 - данные
   ВОЗВРАЩАЕТ всегда 0

в Save_ptr(byte port, int buf,struct canMSG_Fuj *ptr) считываем данные
   ptr->id = IDRX0(buf) & _ID11 ;
   ptr->cfg.dlen = DLCR0(buf) ;
   ptr->data[i] = DTR0_BYTE(buf,i) ;
   ВОЗВРАЩАЕТ всегда 0

в canSend( byte port , struct canMSG_Fuj *ptr ) отправляем данные
  - "перекручиваем" buff.lax ( ptr->id не трогаем )
  - Load_ptr()
  - IDRX0(i) = buff.lax;
   ВОЗВРАЩАЕТ 0/1 - взвели/нет TREQR0i для передачи

в canReceive( byte port , struct canMSG_Fuj *ptr ) прием данных
   - проверяется RCRi, при получении данных:
   - Save_ptr();
   - проверяется ROVRR ( при потере сообщения инкрементируем счетчик ошибок
     и повторяем Save_ptr() );
   - "перекручиваем" ptr->id (чтобы в ptr лежал ID в "явном" виде).
   ВОЗВРАЩАЕТ 1/0 - приняты/нет данных

    АПР-овские функции:

в xSend_msg( byte port, byte n_obj, struct canMSG_Fuj *ptr ) отправляем данные
  - "перекручиваем" buff.lax ( ptr->id не трогаем )
  - Load_ptr()
  - IDRX0(n_obj) = buff.lax;
  - взводим TREQR0i для передачи;
   ВОЗВРАЩАЕТ 0/1 - взвели/нет TREQR0i для передачи

в xRead_msg( byte port, byte n_obj, struct canMSG_Fuj *ptr ) прием данных
   - Save_ptr();
   - проверяется ROVRR ( при потере сообщения инкрементируем счетчик ошибок
     и повторяем Save_ptr() );
   - "перекручиваем" ptr->id (чтобы в ptr лежал ID в "явном" виде).
   ВОЗВРАЩАЕТ 1/0 - есть/нет новые данные

в xInquire_msg( byte port, byte n_obj, struct canMSG_Fuj *ptr ) отправляем запрос
  - xSend_msgP()
   ВОЗВРАЩАЕТ то же, что и xSend_msgP()

в xWrite_msgP( byte port, byte n_obj, struct canMSG_Fuj *ptr )
  подготовка данных к ответу на зпрос
  - при отсутствии запроса передачи TREQR0i выполняется
  - Load_ptr(), - обновляются данные
   ВОЗВРАЩАЕТ 1/0 есть/нет условия для обновления данных


1505205
Непонятно:
1.          в Load_ptr(port,14,ptr); есть строка
            IDRX0(14) = ptr->id;
            а после вызова Load_ptr идет следом строка
            IDRX0(14) = buff.lax;
            где buff.lax - это "перекрученный" ptr->id
2.          В canReceive() имеем вызов Save_ptr, где есть строка
            ptr->id = IDRX0(buf) & _ID11 ;
            а далее в canReceive() "перекрутка" в ptr->id?
*/

/* 14062005
1.  НЕ ИСПОЛЬЗУЮТСЯ МО0 и МО15 !!!
(чтобы использовались все объекты для стандартного протокола необходимо брать
для приема МО0, МО1, МО2 (а не МО1, МО2, МО3) и для передачи МО14, МО15
(а не МО13, МО14) );
А вообще-то правильно три приемника МО0, МО1, МО2 "подвинуть" к МО14, МО15,
т. е. для стандартного протокола использовать МО11-МО15, тогда для "АПР-овских"
объектов остаются МО0-МО10

 2. В "canReceive" непонятка с "ret" - надо ли "выворачивать" ID или нет.

 3. Не везде "доделано" для CAN1 формирование буфера из объектов МО2 и МО3

 4. Получается, что у Fuj объект для передачи фрейма данных ничем не
    отличается от приемника (нет DIR = 0/1 как у 196), - поэтому получается
    что для получения данных от универсального протокола (посылка кода
    чтения и индекса переменной и получения ответа) необходим дополнительный
    объект сообщения, при передаче которого необходимо обновлять буфер
    данных, т. к. при приеме данных требуемые для передачи данные теряются.


*/

//--------------------
//      ИНИЦИАЛИЗАЦИЯ ОБЪЕКТОВ СООБЩЕНИЙ  CAN.

 word  can_config ( byte port )
{
  lword lax, lax1, lax2, lax3, lax4 ;

        if (port == 0)
        {
        can0_con = 1  ; // Остановить контроллер CAN.
        CSR0_TOE = 0 ; // Pin - "не CAN", а общего назначения


#ifdef   _CAN_SHARED  //  CAN-используется и другими программами, по-этому
                     //  msg4...msg12 не переинициализируем.
        BVALR0_BVAL1  = 0 ;//выключить 1-й объект сообщения
        BVALR0_BVAL2  = 0 ;//выключить 2-й объект сообщения //vmz
        BVALR0_BVAL3  = 0 ;//выключить 3-й объект сообщения //vmz
        BVALR0_BVAL4  = 0 ;//выключить 1-й объект сообщения
        BVALR0_BVAL5  = 0 ;//выключить 2-й объект сообщения //vmz
        BVALR0_BVAL6  = 0 ;//выключить 3-й объект сообщения //vmz
        BVALR0_BVAL13 = 0 ;//выключить 13-й объект сообщения
        BVALR0_BVAL14 = 0 ;//выключить 14-й объект сообщения
#else
           //  CAN-используется только этой программой.
        BVALR0 = 0 ; //все объекты сообщений отключены
#endif

// ****************************************************************************
          //настройка MO15 - прием
            // формируем свой ID.
        lax = SetOwn_ID( port, can_setting(port).addr ) ;

        lax1 = (lax & 0xFF000000) >> 8;
        lax2 = (lax & 0x00FF0000) << 8;
        lax3 = (lax & 0x0000FF00) >> 8;
        lax4 = (lax & 0x000000FF) << 8;
        lax = lax1 + lax2 + lax3 + lax4;

        can0_msg1id = lax ;
        can0_msg2id = lax ; //vmz
        can0_msg3id = lax ; //vmz

        lax = SetOwn_ID( port, can_setting(port).addr_p ) ;

        lax1 = (lax & 0xFF000000) >> 8;
        lax2 = (lax & 0x00FF0000) << 8;
        lax3 = (lax & 0x0000FF00) >> 8;
        lax4 = (lax & 0x000000FF) << 8;
        lax = lax1 + lax2 + lax3 + lax4;

        can0_msg4id = lax ;
        can0_msg5id = lax ; //vmz
        can0_msg6id = lax ; //vmz
      //---------
        IDER0  = 0 ; //все объекты - СТАНДАРТНЫЙ ФРЕЙМ
        TRTRR0 = 0 ; //все объекты - DATA FRAME (не REMOTE FRAME)
        RFWTR0 = 0 ; //немедленная передача фрейма данных после установки
        TIER0 = 0x0000Ul ;

#ifdef _CAN_SLAVE_IRQ
        RIER0 = 0x007EUl ; // 0000 0000 0111 1110
        ICR11 = 30;
#else
        RIER0 = 0x0000Ul ;
        ICR11 = 31;
#endif

// ****************************************************************************
/*      маски: маскируются нулями. */
/*      маски: стандартная - выключена, расширенная - выключена; */

        AMSR0  = 0xEAABFFFFUl; //vmz для всех объектов принимать маску AMR1,
                               //кроме 1(15),2,3-го объекта сообщений (AMR0)
        AMRX00 = 0x00000000Ul; // "0" - нет маски AMR00 - для стандартного
        AMRX10 = 0x00000000Ul; // "0" - нет маски AMR10 - для стандартного

        BVALR0_BVAL1 = 1 ;//включить 1-й (15-й) объект сообщения
        BVALR0_BVAL2 = 1 ;//включить 2-й объект сообщения vmz
        BVALR0_BVAL3 = 1 ;//включить 3-й объект сообщения vmz
        BVALR0_BVAL4 = 1 ;//включить 1-й (15-й) объект сообщения
        BVALR0_BVAL5 = 1 ;//включить 2-й объект сообщения vmz
        BVALR0_BVAL6 = 1 ;//включить 3-й объект сообщения vmz
      //---------

       //настройка MO14 - передача
        can0_msg14id = 0 ;  //  чтобы у 14-го и 13-го не было одинаковых 'id'.
        BVALR0_BVAL14 = 1 ;//включить 14-й объект сообщения

       //настройка MO13 - передача, если занят MO14
        can0_msg13id = 1 ;  //  чтобы у 14-го и 13-го не было одинаковых 'id'.
        BVALR0_BVAL13 = 1 ;//включить 13-й объект сообщения

            //  формируем свою маску.
        lax = SetOwn_Mask( port ) ;
        lax1 = (lax & 0xFF000000) >> 8;
        lax2 = (lax & 0x00FF0000) << 8;
        lax3 = (lax & 0x0000FF00) >> 8;
        lax4 = (lax & 0x000000FF) << 8;
        lax = lax1 + lax2 + lax3 + lax4;

        AMRX00 = ~lax ; // маска для 1-го, 2-го и 3-го объектов vmz

          // задание типовых скоростей.
      if ( can_setting(port).config._.bt_125k == 1 )
      {
        BTR0 =  (w)bt_125k.bt0 | ((w)bt_125k.bt1 << 8);
      }
      else if ( can_setting(port).config._.bt_250k == 1 )
      {
        BTR0 =  (w)bt_250k.bt0 | ((w)bt_250k.bt1 << 8);
      }
      else if ( can_setting(port).config._.bt_1M == 1 )
      {
        BTR0 =  (w)bt_1M.bt0 | ((w)bt_1M.bt1 << 8);
      }
      else // если не задана типовая скорость - задаем скорость пользователя.
      {
        BTR0 =  (w)can_setting(port).btime0 | ((w)can_setting(port).btime1 << 8);
      }

        //Запретить модернизацию регистров синхронизации и запустить контроллер.
      CSR0_TOE = 1 ; // Pin - для передачи по CAN

        //Запретить модернизацию регистров синхронизации и запустить контроллер.
      if ( can_setting(port).config._.vkl == 1 )
      {
        can_reInit(port) = 0 ;
        can0_con = 0 ; // Включить контроллер CAN.
      }
      else
      {
        can_reInit(port) = 1 ;
        can0_con = 0x01 ;
      }
    }
    else
    {
      if ( port == 1 )
      {
        can1_con = 1  ; // Остановить контроллер CAN1.
        CSR1_TOE = 0 ; // Pin - "не CAN", а общего назначения

#ifdef   _CAN_SHARED  //  CAN-используется и другими программами, по-этому
                     //  msg1...msg12 не переинициализируем.
        BVALR1_BVAL1  = 0 ;//выключить 1-й объект сообщения
        BVALR1_BVAL2  = 0 ;//выключить 2-й объект сообщения //vmz1
        BVALR1_BVAL3  = 0 ;//выключить 3-й объект сообщения //vmz1
        BVALR1_BVAL4  = 0 ;//выключить 1-й объект сообщения
        BVALR1_BVAL5  = 0 ;//выключить 2-й объект сообщения //vmz1
        BVALR1_BVAL6  = 0 ;//выключить 3-й объект сообщения //vmz1
        BVALR1_BVAL13 = 0 ;//выключить 13-й объект сообщения
        BVALR1_BVAL14 = 0 ;//выключить 14-й объект сообщения
#else
           //  CAN-используется только этой программой.
        BVALR1 = 0 ; //все объекты сообщений отключены
#endif

// ****************************************************************************
          //настройка MO1 - прием
            // формируем свой ID.
        lax = SetOwn_ID( port, can_setting(port).addr ) ;
        lax1 = (lax & 0xFF000000) >> 8;
        lax2 = (lax & 0x00FF0000) << 8;
        lax3 = (lax & 0x0000FF00) >> 8;
        lax4 = (lax & 0x000000FF) << 8;
        lax = lax1 + lax2 + lax3 + lax4;

        can1_msg1id = lax ;
        can1_msg2id = lax ; //vmz1
        can1_msg3id = lax ; //vmz1

        lax = SetOwn_ID( port, can_setting(port).addr_p ) ;
        lax1 = (lax & 0xFF000000) >> 8;
        lax2 = (lax & 0x00FF0000) << 8;
        lax3 = (lax & 0x0000FF00) >> 8;
        lax4 = (lax & 0x000000FF) << 8;
        lax = lax1 + lax2 + lax3 + lax4;

        can1_msg4id = lax ;
        can1_msg5id = lax ; //vmz1
        can1_msg6id = lax ; //vmz1

      //---------
        IDER1  = 0 ; //все объекты - СТАНДАРТНЫЙ ФРЕЙМ
        TRTRR1 = 0 ; //все объекты - DATA FRAME (не REMOTE FRAME)
        RFWTR1 = 0 ; //немедленная передача фрейма данных после установки
        TIER1  = 0x0000Ul ;

#ifdef _CAN_SLAVE_IRQ
        RIER1 = 0x007EUl ; // 0000 0000 0111 1110
        ICR13 = 30;
#else
        RIER1 = 0x0000Ul ;
        ICR13 = 31;
#endif

// ****************************************************************************
/*      маски: маскируются нулями. */
/*      маски: стандартная - выключена, расширенная - выключена; */

        //AMSR1  = 0xfffffffBUl; //для всех объектов принимать маску AMR1,
                               //кроме 1(15)-го объекта сообщений (AMR0)
        AMSR1  = 0xEAABFFFFUl; //vmz1 для всех объектов принимать маску AMR1,
                               //кроме 1(15),2,3-го объекта сообщений (AMR0)
        AMRX01 = 0x00000000Ul; // "0" - нет маски
        AMRX11 = 0x00000000Ul; // "0" - нет маски

/*      маски: локальная. */

        BVALR1_BVAL1 = 1 ;//включить 1-й (15-й) объект сообщения
        BVALR1_BVAL2 = 1 ;//включить 2-й объект сообщения vmz1
        BVALR1_BVAL3 = 1 ;//включить 3-й объект сообщения vmz1
        BVALR1_BVAL4 = 1 ;//включить 1-й (15-й) объект сообщения
        BVALR1_BVAL5 = 1 ;//включить 2-й объект сообщения vmz1
        BVALR1_BVAL6 = 1 ;//включить 3-й объект сообщения vmz1

      //---------

       //настройка MO14 - передача
        can1_msg14id = 2 ;  //  чтобы у 14-го и 13-го не было одинаковых 'id'.
        BVALR1_BVAL14 = 1 ;//включить 14-й объект сообщения

       //настройка MO13 - передача, если занят MO14
        can1_msg13id = 3 ;  //  чтобы у 14-го и 13-го не было одинаковых 'id'.
        BVALR1_BVAL13 = 1 ;//включить 13-й объект сообщения

            //  формируем свою маску.
        lax = SetOwn_Mask( port ) ;
        lax1 = (lax & 0xFF000000) >> 8;
        lax2 = (lax & 0x00FF0000) << 8;
        lax3 = (lax & 0x0000FF00) >> 8;
        lax4 = (lax & 0x000000FF) << 8;
        lax = lax1 + lax2 + lax3 + lax4;

        AMRX01 = ~lax ; // маска для 1-го, 2-го и 3-го объектов vmz1

          // задание типовых скоростей.
      if ( can_setting(port).config._.bt_125k == 1 )
      {
        BTR1 =  (w)bt_125k.bt0 | ((w)bt_125k.bt1 << 8);
      }
      else if ( can_setting(port).config._.bt_250k == 1 )
      {
        BTR1 =  (w)bt_250k.bt0 | ((w)bt_250k.bt1 << 8);
      }
      else if ( can_setting(port).config._.bt_1M == 1 )
      {
        BTR1 =  (w)bt_1M.bt0 | ((w)bt_1M.bt1 << 8);
      }
      else // если не задана типовая скорость - задаем скорость пользователя.
      {
        BTR1 =  (w)can_setting(port).btime0 | ((w)can_setting(port).btime1 << 8);
      }

        //Запретить модернизацию регистров синхронизации и запустить контроллер.
      CSR1_TOE = 1 ; // Pin - для передачи по CAN

        //Запретить модернизацию регистров синхронизации и запустить контроллер.
      if ( can_setting(port).config._.vkl == 1 )
      {
        can_reInit(port) = 0 ;
        can1_con = 0 ; // Включить контроллер CAN.
      }
      else
      {
        can_reInit(port) = 1 ;
        can1_con = 0x01 ;
      }
      } else {
        // CAN2
        can2_con = 1  ; // Остановить контроллер CAN1.
        CSR2_TOE = 0 ; // Pin - "не CAN", а общего назначения

#ifdef   _CAN_SHARED  //  CAN-используется и другими программами, по-этому
                     //  msg1...msg12 не переинициализируем.
        BVALR2_BVAL1  = 0 ;//выключить 1-й объект сообщения
        BVALR2_BVAL2  = 0 ;//выключить 2-й объект сообщения //vmz1
        BVALR2_BVAL3  = 0 ;//выключить 3-й объект сообщения //vmz1
        BVALR2_BVAL4  = 0 ;//выключить 1-й объект сообщения
        BVALR2_BVAL5  = 0 ;//выключить 2-й объект сообщения //vmz1
        BVALR2_BVAL6  = 0 ;//выключить 3-й объект сообщения //vmz1
        BVALR2_BVAL13 = 0 ;//выключить 13-й объект сообщения
        BVALR2_BVAL14 = 0 ;//выключить 14-й объект сообщения
#else
           //  CAN-используется только этой программой.
        BVALR2 = 0 ; //все объекты сообщений отключены
#endif

// ****************************************************************************
          //настройка MO1 - прием
            // формируем свой ID.
        lax = SetOwn_ID( port, can_setting(port).addr ) ;
        lax1 = (lax & 0xFF000000) >> 8;
        lax2 = (lax & 0x00FF0000) << 8;
        lax3 = (lax & 0x0000FF00) >> 8;
        lax4 = (lax & 0x000000FF) << 8;
        lax = lax1 + lax2 + lax3 + lax4;

        can2_msg1id = lax ;
        can2_msg2id = lax ; //vmz1
        can2_msg3id = lax ; //vmz1

        lax = SetOwn_ID( port, can_setting(port).addr_p ) ;
        lax1 = (lax & 0xFF000000) >> 8;
        lax2 = (lax & 0x00FF0000) << 8;
        lax3 = (lax & 0x0000FF00) >> 8;
        lax4 = (lax & 0x000000FF) << 8;
        lax = lax1 + lax2 + lax3 + lax4;

        can2_msg4id = lax ;
        can2_msg5id = lax ; //vmz1
        can2_msg6id = lax ; //vmz1
      //---------
        IDER2  = 0 ; //все объекты - СТАНДАРТНЫЙ ФРЕЙМ
        TRTRR2 = 0 ; //все объекты - DATA FRAME (не REMOTE FRAME)
        RFWTR2 = 0 ; //немедленная передача фрейма данных после установки
        TIER2  = 0x0000Ul ;

#ifdef _CAN_SLAVE_IRQ_CAN2
        //только для АТК - для Объектов сообщения - 9 и 10 - ПРИЕМ
        RIER2 = 0x0600Ul ;//"1" для 9 и 10 //7E - 0000 0000 0111 1110
       // RIER2 = 0x007EUl ; // 0000 0000 0111 1110
        //при необходимости определить _CAN_SLAVE_IRQ_CAN2 и _CAN2_IRQ_PRIORITY в "extrn.h"
        ICR15 = _CAN2_IRQ_PRIORITY ; //30;
#else
        RIER2 = 0x0000Ul ;
        ICR15 = 31;
#endif

// ****************************************************************************
/*      маски: маскируются нулями. */
/*      маски: стандартная - выключена, расширенная - выключена; */

        AMSR2  = 0xEAABFFFFUl; //vmz1 для всех объектов принимать маску AMR1,
                               //кроме 1(15),2,3-го объекта сообщений (AMR0)
        AMRX02 = 0x00000000Ul; // "0" - нет маски
        AMRX12 = 0x00000000Ul; // "0" - нет маски

/*      маски: локальная. */

        BVALR2_BVAL1 = 1 ;//включить 1-й (15-й) объект сообщения
        BVALR2_BVAL2 = 1 ;//включить 2-й объект сообщения vmz1
        BVALR2_BVAL3 = 1 ;//включить 3-й объект сообщения vmz1
        BVALR2_BVAL4 = 1 ;//включить 1-й (15-й) объект сообщения
        BVALR2_BVAL5 = 1 ;//включить 2-й объект сообщения vmz1
        BVALR2_BVAL6 = 1 ;//включить 3-й объект сообщения vmz1

      //---------

       //настройка MO14 - передача
        can2_msg14id = 2 ;  //  чтобы у 14-го и 13-го не было одинаковых 'id'.
        BVALR2_BVAL14 = 1 ;//включить 14-й объект сообщения

       //настройка MO13 - передача, если занят MO14
        can2_msg13id = 3 ;  //  чтобы у 14-го и 13-го не было одинаковых 'id'.
        BVALR2_BVAL13 = 1 ;//включить 13-й объект сообщения

            //  формируем свою маску.
        lax = SetOwn_Mask( port ) ;
        lax1 = (lax & 0xFF000000) >> 8;
        lax2 = (lax & 0x00FF0000) << 8;
        lax3 = (lax & 0x0000FF00) >> 8;
        lax4 = (lax & 0x000000FF) << 8;
        lax = lax1 + lax2 + lax3 + lax4;

        AMRX02 = ~lax ; // маска для 1-го, 2-го и 3-го объектов vmz1

          // задание типовых скоростей.
      if ( can_setting(port).config._.bt_125k == 1 )
      {
        BTR2 =  (w)bt_125k.bt0 | ((w)bt_125k.bt1 << 8);
      }
      else if ( can_setting(port).config._.bt_250k == 1 )
      {
        BTR2 =  (w)bt_250k.bt0 | ((w)bt_250k.bt1 << 8);
      }
      else if ( can_setting(port).config._.bt_1M == 1 )
      {
        BTR2 =  (w)bt_1M.bt0 | ((w)bt_1M.bt1 << 8);
      }
      else // если не задана типовая скорость - задаем скорость пользователя.
      {
        BTR2 =  (w)can_setting(port).btime0 | ((w)can_setting(port).btime1 << 8);
        //задать при необходимости скорость пользователя, отличную от 100,
        //например, - Скорость пользователя 800 КБит, а не 100 КБит
        //BTR2 =  (w)bt_800k.bt0 | ((w)bt_800k.bt1 << 8);

      }

        //Запретить модернизацию регистров синхронизации и запустить контроллер.
      CSR2_TOE = 1 ; // Pin - для передачи по CAN

        //Запретить модернизацию регистров синхронизации и запустить контроллер.
      if ( can_setting(port).config._.vkl == 1 )
      {
        can_reInit(port) = 0 ;
        can2_con = 0 ; // Включить контроллер CAN.
      }
      else
      {
        can_reInit(port) = 1 ;
        can2_con = 0x01 ;
      }
      }
    }

//      Конец инициализации для CAN;

      //can_dd[port].Error   = 0 ;
      can_dd[port].Avar    = 0 ;
      can_dd[port].Error_send = 0 ;
      can_dd[port].Error_receive = 0 ;
      can_dd[port].Can_stop= 0 ;

        return 0 ;
}
//-------------------------------------------------

word    can_test ( byte port )
{
  if (port==0)
  {
    //    для CAN 0
    // Выключить контроллер CAN и программы.
  if ( tst_can_stop(port) == 1 )
    {    // для возможности работы с CAN из монитора без рабочей программы.
      if ( can_reInit(port) == 0 )
      {
        can_reInit(port) = 1 ; // Для автоматического срабатывания переинициализации.
        can0_con = 1;// Остановить контроллер CAN.
        BVALR0_BVAL1  = 0 ;//выключить 1-й объект сообщения
        BVALR0_BVAL2  = 0 ;//выключить 2-й объект сообщения vmz
        BVALR0_BVAL3  = 0 ;//выключить 3-й объект сообщения vmz
        BVALR0_BVAL4  = 0 ;//выключить 1-й объект сообщения
        BVALR0_BVAL5  = 0 ;//выключить 2-й объект сообщения vmz
        BVALR0_BVAL6  = 0 ;//выключить 3-й объект сообщения vmz
        BVALR0_BVAL13 = 0 ;//выключить 13-й объект сообщения
        BVALR0_BVAL14 = 0 ;//выключить 14-й объект сообщения
      }
      return 1 ;
    }

    // Переинициализация по команде с пульта после смены уставок CAN.
  if ( can_reInit(port) == 1 )
    {
      can_init(port);
      can_reInit(port) = 0 ;
      return 1 ;
    }
   //ДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДД

                // Ошибки - CAN еще не отключился от шины.
            if ((CSR0 & _NS_status) == 0x0100 || (CSR0 & _NS_status) == 0x0200)
              {
                can_dd[port].Avar++ ;
              }

                // CAN отключился от шины - BOff
            if ((CSR0 & _NS_status) == 0x0300 )
              {
//196           can_con &= Res_InitCan;
                 //  одного can_con для перезапуска CAN после i-того отключения
                 //  (коротили шину) не хватало, по-этому поставили
                 //  полную переинициализацию.
                 //  can_con = 0; // Включить контроллер CAN.
                can_init(port);

                mSet_ServiceMsg( _Srv_ResCan ) ;

                  // После Аварии CAN возврат в рабочую программу
                return 2 ;
              }

          // CAN не выставил предупреждение об ошибках
        // Проверка наличия потерянных сообщений. MsgLst = can_msgx_con.15,7,8.
      //----------
            // Проверка: не истекло ли время таймаута на передачу.
//196   if ((can_msg14con1 & _Tst_TxRqst) == _TxRqst )
        if (TREQR0_TREQ14)
//        if (!TCR0_TC14) или так
        {
          if ( (u)((w)(timer1-can_dd[port].time_out_send14)) > _TimeOut_send )
          {
//196       can_msg14con1 = Res_TxRqst;//сброс передачи.
            TCANR0_TCAN14 = 1;//сброс запроса передачи.
            can_dd[port].Error_send++ ;
          }
        }
//        else
//        {
//         TCR0_TC14 = 0 ;
//        }
            // Проверка: не истекло ли время таймаута на передачу.
//196   if ((can_msg13con1 & _Tst_TxRqst) == _TxRqst )
        if (TREQR0_TREQ13)
//        if (!TCR0_TC13) или так
        {
          if ( (u)((w)(timer1-can_dd[port].time_out_send13)) > _TimeOut_send )
          {
//196       can_msg13con1 = Res_TxRqst;//сброс передачи.
            TCANR0_TCAN13 = 1;//сброс запроса передачи.
            can_dd[port].Error_send++ ;
          }
        }
//        else
//        {
//         TCR0_TC13 = 0 ;
//        }
  }
  else
  {
    if ( port == 1 )
    {
    //    для CAN 1
    // Выключить контроллер CAN и программы.
  if ( tst_can_stop(port) == 1 )
    {    // для возможности работы с CAN из монитора без рабочей программы.
      if ( can_reInit(port) == 0 )
      {
        can_reInit(port) = 1 ; // Для автоматического срабатывания переинициализации.
        can1_con = 1;// Остановить контроллер CAN1.
        BVALR1_BVAL1  = 0 ;//выключить 1-й объект сообщения CAN1
        BVALR1_BVAL2  = 0 ;//выключить 2-й объект сообщения vmz1
        BVALR1_BVAL3  = 0 ;//выключить 3-й объект сообщения vmz1
        BVALR1_BVAL4  = 0 ;//выключить 1-й объект сообщения CAN1
        BVALR1_BVAL5  = 0 ;//выключить 2-й объект сообщения vmz1
        BVALR1_BVAL6  = 0 ;//выключить 3-й объект сообщения vmz1
        BVALR1_BVAL13 = 0 ;//выключить 13-й объект сообщения CAN1
        BVALR1_BVAL14 = 0 ;//выключить 14-й объект сообщения CAN1
      }
      return 1 ;
    }

    // Переинициализация по команде с пульта после смены уставок CAN.
  if ( can_reInit(port) == 1 )
    {
      can_init(port);
      can_reInit(port) = 0 ;
      return 1 ;
    }
   //ДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДД

                // Ошибки - CAN еще не отключился от шины.
            if ((CSR1 & _NS_status) == 0x0100 || (CSR1 & _NS_status) == 0x0200)
              {
                can_dd[port].Avar++ ;
              }

                // CAN отключился от шины - BOff
            if ((CSR1 & _NS_status) == 0x0300 )
              {
//196           can_con &= Res_InitCan;
                 //  одного can_con для перезапуска CAN после i-того отключения
                 //  (коротили шину) не хватало, по-этому поставили
                 //  полную переинициализацию.
                 //  can_con = 0; // Включить контроллер CAN.
                can_init(port);

                mSet_ServiceMsg( _Srv_ResCan ) ;

                  // После Аварии CAN возврат в рабочую программу
                return 2 ;
              }

          // CAN не выставил предупреждение об ошибках
        // Проверка наличия потерянных сообщений. MsgLst = can_msgx_con.15,7,8.
      //----------
            // Проверка: не истекло ли время таймаута на передачу.
//196   if ((can_msg14con1 & _Tst_TxRqst) == _TxRqst )
        if (TREQR1_TREQ14)
//        if (!TCR1_TC14) или так
        {
          if ( (u)((w)(timer1-can_dd[port].time_out_send14)) > _TimeOut_send )
          {
//196       can_msg14con1 = Res_TxRqst;//сброс передачи.
            TCANR1_TCAN14 = 1;//сброс запроса передачи.
            can_dd[port].Error_send++ ;
          }
        }
//        else
//        {
//         TCR0_TC14 = 0 ;
//        }
            // Проверка: не истекло ли время таймаута на передачу.
//196   if ((can_msg13con1 & _Tst_TxRqst) == _TxRqst )
        if (TREQR1_TREQ13)
//        if (!TCR1_TC13) или так
        {
          if ( (u)((w)(timer1-can_dd[port].time_out_send13)) > _TimeOut_send )
          {
//196       can_msg13con1 = Res_TxRqst;//сброс передачи.
            TCANR1_TCAN13 = 1;//сброс запроса передачи.
            can_dd[port].Error_send++ ;
          }
        }
//        else
//        {
//         TCR0_TC13 = 0 ;
//        }
    } else {
      // CAN 2
    // Выключить контроллер CAN и программы.
  if ( tst_can_stop(port) == 1 )
    {    // для возможности работы с CAN из монитора без рабочей программы.
      if ( can_reInit(port) == 0 )
      {
        can_reInit(port) = 1 ; // Для автоматического срабатывания переинициализации.
        can2_con = 1;// Остановить контроллер CAN1.
        BVALR2_BVAL1  = 0 ;//выключить 1-й объект сообщения CAN1
        BVALR2_BVAL2  = 0 ;//выключить 2-й объект сообщения vmz1
        BVALR2_BVAL3  = 0 ;//выключить 3-й объект сообщения vmz1
        BVALR2_BVAL4  = 0 ;//выключить 1-й объект сообщения CAN1
        BVALR2_BVAL5  = 0 ;//выключить 2-й объект сообщения vmz1
        BVALR2_BVAL6  = 0 ;//выключить 3-й объект сообщения vmz1
        BVALR2_BVAL13 = 0 ;//выключить 13-й объект сообщения CAN1
        BVALR2_BVAL14 = 0 ;//выключить 14-й объект сообщения CAN1
      }
      return 1 ;
    }

    // Переинициализация по команде с пульта после смены уставок CAN.
  if ( can_reInit(port) == 1 )
    {
      can_init(port);
      can_reInit(port) = 0 ;
      return 1 ;
    }
   //ДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДД

                // Ошибки - CAN еще не отключился от шины.
            if ((CSR2 & _NS_status) == 0x0100 || (CSR2 & _NS_status) == 0x0200)
              {
                can_dd[port].Avar++ ;
              }

                // CAN отключился от шины - BOff
            if ((CSR2 & _NS_status) == 0x0300 )
              {
//196           can_con &= Res_InitCan;
                 //  одного can_con для перезапуска CAN после i-того отключения
                 //  (коротили шину) не хватало, по-этому поставили
                 //  полную переинициализацию.
                 //  can_con = 0; // Включить контроллер CAN.
                can_init(port);

                mSet_ServiceMsg( _Srv_ResCan ) ;

                  // После Аварии CAN возврат в рабочую программу
                return 2 ;
              }

          // CAN не выставил предупреждение об ошибках
        // Проверка наличия потерянных сообщений. MsgLst = can_msgx_con.15,7,8.
      //----------
            // Проверка: не истекло ли время таймаута на передачу.
//196   if ((can_msg14con1 & _Tst_TxRqst) == _TxRqst )
        if (TREQR2_TREQ14)
//        if (!TCR1_TC14) или так
        {
          if ( (u)((w)(timer1-can_dd[port].time_out_send14)) > _TimeOut_send )
          {
//196       can_msg14con1 = Res_TxRqst;//сброс передачи.
            TCANR2_TCAN14 = 1;//сброс запроса передачи.
            can_dd[port].Error_send++ ;
          }
        }
//        else
//        {
//         TCR0_TC14 = 0 ;
//        }
            // Проверка: не истекло ли время таймаута на передачу.
//196   if ((can_msg13con1 & _Tst_TxRqst) == _TxRqst )
        if (TREQR2_TREQ13)
//        if (!TCR1_TC13) или так
        {
          if ( (u)((w)(timer1-can_dd[port].time_out_send13)) > _TimeOut_send )
          {
//196       can_msg13con1 = Res_TxRqst;//сброс передачи.
            TCANR2_TCAN13 = 1;//сброс запроса передачи.
            can_dd[port].Error_send++ ;
          }
        }
//        else
//        {
//         TCR0_TC13 = 0 ;
//        }
    }
  }

  return 0 ;
}
//ДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДД

word canSend( byte port , struct canMSG_Fuj *ptr )
{
    lword lax, lax1, lax2, lax3, lax4 ;


      lax = ptr->id ;
        lax1 = (lax & 0xFF000000) >> 8;
        lax2 = (lax & 0x00FF0000) << 8;
        lax3 = (lax & 0x0000FF00) >> 8;
        lax4 = (lax & 0x000000FF) << 8;
        lax = lax1 + lax2 + lax3 + lax4;

          //  У более чем одного передающего объекта не могут лежать
          // одинаковые адреса передачи даже если передает только один т.к.:
          // если передает старший по номеру объект, после его передачи будут
          // просканированы все объекты сооб. от младшего к старшему
          // и первый у кого будет найден переданный адрес будет ошибочно
          // принят как передающий и у него будет сброшен запрос передачи
          // (хотя он и не был взведен), а настоящий передающий объект
          // останется взведенным и будет передавать бесконечно.
          //
      if ( port==0 )
      {
        //для CAN 0
               // Проверка: не занят ли 14-й канал передачи.
//196   if ( ((can_msg14con1 & _Tst_TxRqst) != _TxRqst ) &&
//196                                       ( can_msg13id != ptr->id ))
                                // при проверке срезаем лишние кроме 11-ти старших разрядов
        if ( (!TREQR0_TREQ14) && ((IDRX0(13)&_ID11) != lax) )//IDRX14 ))
                                       //(IDRX0(13) != ptr->id) - проверить
        {
        //у MO14 нет запроса на передачу И ID у MO13 не тот, что требуется сейчас

            Load_ptr(port,14,ptr);
            IDRX0(14) = lax;
             //пытаюсь отправить
            TREQR0_TREQ14 = 1 ;

          can_dd[port].time_out_send14 = timer1 ;
        }    // Проверка: не занят ли 13-й канал передачи.
        else if ( (!TREQR0_TREQ13) &&  ((IDRX0(14)&_ID11) != lax) )
        {
        //у MO13 нет запроса на передачу И ID у MO14 не тот, что требуется сейчас
            Load_ptr(port,13,ptr);
            IDRX0(13) = lax;
             //пытаюсь отправить
            TREQR0_TREQ13 = 1 ;
          can_dd[port].time_out_send13 = timer1 ;
        }
        else
        {
          //09.04.06 00:38can_dd[port].Error_send++ ;
               //------------
          return 1 ;
        }
  return 0 ;
      }
      else
      {
        if ( port == 1 )
        {
        //для CAN 1
               // Проверка: не занят ли 14-й канал передачи.
        if ( (!TREQR1_TREQ14) &&  ((IDRX1(13)&_ID11) != lax) )//IDRX14 ))
        {
        //у MO14 нет запроса на передачу И ID у MO13 не тот, что требуется сейчас

            Load_ptr(port,14,ptr);
            //IDRX0(14) = lax;
            IDRX1(14) = lax;
//            BVALR0_BVAL14 = 1 ;
       //   can_msg14con0 = Res_IntPnd;  без прерываний
             //пытаюсь отправить
//196     can_msg14con1 = Set_NewDat & Res_CpuUpd & Set_TxRqst;
          TREQR1_TREQ14 = 1 ;

          //can_msg14con1 = Set_TxRqst;//пытаюсь отправить
          can_dd[port].time_out_send14 = timer1 ;
        }    // Проверка: не занят ли 13-й канал передачи.
//196   else if ( ((can_msg13con1 & _Tst_TxRqst) != _TxRqst ) &&
//196                                       ( can_msg14id != ptr->id ))
        else if ( (!TREQR1_TREQ13) &&  ((IDRX1(14)&_ID11) != lax) )
                                       //(IDRX0(14) != ptr->id) - проверить
        {
        //у MO13 нет запроса на передачу И ID у MO14 не тот, что требуется сейчас
//            BVALR0_BVAL13 = 0 ;
            Load_ptr(port,13,ptr);
//            IDRX1(13) = lax;
            IDRX1(13) = lax;
//            BVALR1_BVAL13 = 1 ;

             //пытаюсь отправить
//196     can_msg13con1 = Set_NewDat & Res_CpuUpd & Set_TxRqst;
          TREQR1_TREQ13 = 1 ;
          can_dd[port].time_out_send13 = timer1 ;
        }
        else
        {
          //09.04.06 00:38can_dd[port].Error_send++ ;
               //------------
          return 1 ;
        }
  return 0 ;
        } else {
          // CAN 2
               // Проверка: не занят ли 14-й канал передачи.
        if ( (!TREQR2_TREQ14) &&  ((IDRX2(13)&_ID11) != lax) )//IDRX14 ))
        {
        //у MO14 нет запроса на передачу И ID у MO13 не тот, что требуется сейчас

            Load_ptr(port,14,ptr);
            //IDRX0(14) = lax;
            IDRX2(14) = lax;
//            BVALR0_BVAL14 = 1 ;
       //   can_msg14con0 = Res_IntPnd;  без прерываний
             //пытаюсь отправить
//196     can_msg14con1 = Set_NewDat & Res_CpuUpd & Set_TxRqst;
          TREQR2_TREQ14 = 1 ;

          //can_msg14con1 = Set_TxRqst;//пытаюсь отправить
          can_dd[port].time_out_send14 = timer1 ;
        }    // Проверка: не занят ли 13-й канал передачи.
//196   else if ( ((can_msg13con1 & _Tst_TxRqst) != _TxRqst ) &&
//196                                       ( can_msg14id != ptr->id ))
        else if ( (!TREQR2_TREQ13) &&  ((IDRX2(14)&_ID11) != lax) )
                                       //(IDRX0(14) != ptr->id) - проверить
        {
        //у MO13 нет запроса на передачу И ID у MO14 не тот, что требуется сейчас
//            BVALR0_BVAL13 = 0 ;
            Load_ptr(port,13,ptr);
//            IDRX1(13) = lax;
            IDRX2(13) = lax;
//            BVALR1_BVAL13 = 1 ;

             //пытаюсь отправить
//196     can_msg13con1 = Set_NewDat & Res_CpuUpd & Set_TxRqst;
          TREQR2_TREQ13 = 1 ;
          can_dd[port].time_out_send13 = timer1 ;
        }
        else
        {
          //09.04.06 00:38can_dd[port].Error_send++ ;
               //------------
          return 1 ;
        }
  return 0 ;
        }
      }


}

//ДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДД

word canReceive( byte port , struct canMSG_Fuj *ptr )
{
    lword lax, lax1, lax2, lax3, lax4 ;
   if ( port==0 )
   {
    //для CAN 0
    if (RCR0_RC1) //Есть операция с МО1(MO15) - был прием
    {
       // считывание 15-го объекта сообщения.
povtor:
       // считывание 1(15)-го объекта сообщения.
      Save_ptr(port,1,ptr) ;
      if (ROVRR0_ROVR1)
      {
       //если есть переполнение может быть наложение "старых"
       //и "новых" данных - необходимо перечитать данные
       ROVRR0_ROVR1 = 0 ;
       can_dd[port].Error_receive++ ;
       goto povtor ;
      }
       //переполнения не было - данные действительны
       RCR0_RC1 = 0 ;
      goto ret ;
    }
//vmz beg
    if (RCR0_RC2) //Есть операция с МО2
    {
povtor2:
       // считывание 2-го объекта сообщения.
      Save_ptr(port,2,ptr) ;
      if (ROVRR0_ROVR2)
      {
       //если есть переполнение может быть наложение "старых"
       //и "новых" данных - необходимо перечитать данные
       ROVRR0_ROVR2 = 0 ;
       can_dd[port].Error_receive++ ;
       goto povtor2 ;
      }
       //переполнения не было - данные действительны
       RCR0_RC2 = 0 ;
      goto ret ;
    }
//----------------------------------
    if (RCR0_RC3) //Есть операция с МО3
    {
povtor3:
       // считывание 3-го объекта сообщения.
      Save_ptr(port,3,ptr) ;
      if (ROVRR0_ROVR3)
      {
       //если есть переполнение может быть наложение "старых"
       //и "новых" данных - необходимо перечитать данные
       ROVRR0_ROVR3 = 0 ;
       can_dd[port].Error_receive++ ;
       goto povtor3 ;
      }
       //переполнения не было - данные действительны
       RCR0_RC3 = 0 ;
      goto ret ;
    }
//----------------------------------
    if (RCR0_RC4) //Есть операция с МО3
    {
povtor04:
       // считывание 3-го объекта сообщения.
      Save_ptr(port,4,ptr) ;
      if (ROVRR0_ROVR4)
      {
       //если есть переполнение может быть наложение "старых"
       //и "новых" данных - необходимо перечитать данные
       ROVRR0_ROVR4 = 0 ;
       can_dd[port].Error_receive++ ;
       goto povtor04 ;
      }
       //переполнения не было - данные действительны
       RCR0_RC4 = 0 ;
      goto ret ;
    }
//----------------------------------
    if (RCR0_RC5) //Есть операция с МО3
    {
povtor05:
       // считывание 3-го объекта сообщения.
      Save_ptr(port,5,ptr) ;
      if (ROVRR0_ROVR5)
      {
       //если есть переполнение может быть наложение "старых"
       //и "новых" данных - необходимо перечитать данные
       ROVRR0_ROVR5 = 0 ;
       can_dd[port].Error_receive++ ;
       goto povtor05 ;
      }
       //переполнения не было - данные действительны
       RCR0_RC5 = 0 ;
      goto ret ;
    }
//----------------------------------
    if (RCR0_RC6) //Есть операция с МО3
    {
povtor06:
       // считывание 3-го объекта сообщения.
      Save_ptr(port,6,ptr) ;
      if (ROVRR0_ROVR6)
      {
       //если есть переполнение может быть наложение "старых"
       //и "новых" данных - необходимо перечитать данные
       ROVRR0_ROVR6 = 0 ;
       can_dd[port].Error_receive++ ;
       goto povtor06 ;
      }
       //переполнения не было - данные действительны
       RCR0_RC6 = 0 ;
      goto ret ;
    }
  return 0 ;
   }
   else
   {
    if ( port == 1 )
    {
    //для CAN 1
//196 if (can_int==0x02) //Есть операция с МО15
    if (RCR1_RC1) //Есть операция с МО1(MO15) - был прием
    {
       // считывание 15-го объекта сообщения.
//196 *ptr = *(struct canMSG_Fuj*)&can_msg15id ;
povtor1:
       // считывание 1(15)-го объекта сообщения.
      Save_ptr(port,1,ptr) ;
      if (ROVRR1_ROVR1)
      {
       //если есть переполнение может быть наложение "старых"
       //и "новых" данных - необходимо перечитать данные
       ROVRR1_ROVR1 = 0 ;
       can_dd[port].Error_receive++ ;
       goto povtor1 ;
      }
       //переполнения не было - данные действительны
       RCR1_RC1 = 0 ;
      goto ret ;
    }
//vmz1 beg
    if (RCR1_RC2) //Есть операция с МО2
    {
povtor4:
       // считывание 2-го объекта сообщения.
      Save_ptr(port,2,ptr) ;
      if (ROVRR1_ROVR2)
      {
       //если есть переполнение может быть наложение "старых"
       //и "новых" данных - необходимо перечитать данные
       ROVRR1_ROVR2 = 0 ;
       can_dd[port].Error_receive++ ;
       goto povtor4 ;
      }
       //переполнения не было - данные действительны
       RCR1_RC2 = 0 ;
      goto ret ;
    }
//----------------------------------
    if (RCR1_RC3) //Есть операция с МО3
    {
povtor5:
       // считывание 3-го объекта сообщения.
      Save_ptr(port,3,ptr) ;
      if (ROVRR1_ROVR3)
      {
       //если есть переполнение может быть наложение "старых"
       //и "новых" данных - необходимо перечитать данные
       ROVRR1_ROVR3 = 0 ;
       can_dd[port].Error_receive++ ;
       goto povtor5 ;
      }
       //переполнения не было - данные действительны
       RCR1_RC3 = 0 ;
      goto ret ;
    }
//----------------------------------
    if (RCR1_RC4) //Есть операция с МО3
    {
povtor14:
       // считывание 3-го объекта сообщения.
      Save_ptr(port,4,ptr) ;
      if (ROVRR1_ROVR4)
      {
       //если есть переполнение может быть наложение "старых"
       //и "новых" данных - необходимо перечитать данные
       ROVRR1_ROVR4 = 0 ;
       can_dd[port].Error_receive++ ;
       goto povtor14 ;
      }
       //переполнения не было - данные действительны
       RCR1_RC4 = 0 ;
      goto ret ;
    }
//----------------------------------
    if (RCR1_RC5) //Есть операция с МО3
    {
povtor15:
       // считывание 3-го объекта сообщения.
      Save_ptr(port,5,ptr) ;
      if (ROVRR1_ROVR5)
      {
       //если есть переполнение может быть наложение "старых"
       //и "новых" данных - необходимо перечитать данные
       ROVRR1_ROVR5 = 0 ;
       can_dd[port].Error_receive++ ;
       goto povtor15 ;
      }
       //переполнения не было - данные действительны
       RCR1_RC5 = 0 ;
      goto ret ;
    }
//----------------------------------
    if (RCR1_RC6) //Есть операция с МО3
    {
povtor16:
       // считывание 3-го объекта сообщения.
      Save_ptr(port,6,ptr) ;
      if (ROVRR1_ROVR6)
      {
       //если есть переполнение может быть наложение "старых"
       //и "новых" данных - необходимо перечитать данные
       ROVRR1_ROVR6 = 0 ;
       can_dd[port].Error_receive++ ;
       goto povtor16 ;
      }
       //переполнения не было - данные действительны
       RCR1_RC6 = 0 ;
      goto ret ;
    }
  return 0 ;
    } else {
      // CAN 2
    if (RCR2_RC1) //Есть операция с МО1(MO15) - был прием
    {
       // считывание 15-го объекта сообщения.
//196 *ptr = *(struct canMSG_Fuj*)&can_msg15id ;
povtor6:
       // считывание 1(15)-го объекта сообщения.
      Save_ptr(port,1,ptr) ;
      if (ROVRR2_ROVR1)
      {
       //если есть переполнение может быть наложение "старых"
       //и "новых" данных - необходимо перечитать данные
       ROVRR2_ROVR1 = 0 ;
       can_dd[port].Error_receive++ ;
       goto povtor6 ;
      }
       //переполнения не было - данные действительны
       RCR2_RC1 = 0 ;
      goto ret ;
    }
//vmz1 beg
    if (RCR2_RC2) //Есть операция с МО2
    {
povtor7:
       // считывание 2-го объекта сообщения.
      Save_ptr(port,2,ptr) ;
      if (ROVRR2_ROVR2)
      {
       //если есть переполнение может быть наложение "старых"
       //и "новых" данных - необходимо перечитать данные
       ROVRR2_ROVR2 = 0 ;
       can_dd[port].Error_receive++ ;
       goto povtor7 ;
      }
       //переполнения не было - данные действительны
       RCR2_RC2 = 0 ;
      goto ret ;
    }
//----------------------------------
    if (RCR2_RC3) //Есть операция с МО3
    {
povtor8:
       // считывание 3-го объекта сообщения.
      Save_ptr(port,3,ptr) ;
      if (ROVRR2_ROVR3)
      {
       //если есть переполнение может быть наложение "старых"
       //и "новых" данных - необходимо перечитать данные
       ROVRR2_ROVR3 = 0 ;
       can_dd[port].Error_receive++ ;
       goto povtor8 ;
      }
       //переполнения не было - данные действительны
       RCR2_RC3 = 0 ;
      goto ret ;
    }
//----------------------------------
    if (RCR2_RC4) //Есть операция с МО3
    {
povtor24:
       // считывание 3-го объекта сообщения.
      Save_ptr(port,4,ptr) ;
      if (ROVRR2_ROVR4)
      {
       //если есть переполнение может быть наложение "старых"
       //и "новых" данных - необходимо перечитать данные
       ROVRR2_ROVR4 = 0 ;
       can_dd[port].Error_receive++ ;
       goto povtor24 ;
      }
       //переполнения не было - данные действительны
       RCR2_RC4 = 0 ;
      goto ret ;
    }
//----------------------------------
    if (RCR2_RC5) //Есть операция с МО3
    {
povtor25:
       // считывание 3-го объекта сообщения.
      Save_ptr(port,5,ptr) ;
      if (ROVRR2_ROVR5)
      {
       //если есть переполнение может быть наложение "старых"
       //и "новых" данных - необходимо перечитать данные
       ROVRR2_ROVR5 = 0 ;
       can_dd[port].Error_receive++ ;
       goto povtor25 ;
      }
       //переполнения не было - данные действительны
       RCR2_RC5 = 0 ;
      goto ret ;
    }
//----------------------------------
    if (RCR2_RC6) //Есть операция с МО3
    {
povtor26:
       // считывание 3-го объекта сообщения.
      Save_ptr(port,6,ptr) ;
      if (ROVRR2_ROVR6)
      {
       //если есть переполнение может быть наложение "старых"
       //и "новых" данных - необходимо перечитать данные
       ROVRR2_ROVR6 = 0 ;
       can_dd[port].Error_receive++ ;
       goto povtor26 ;
      }
       //переполнения не было - данные действительны
       RCR2_RC6 = 0 ;
      goto ret ;
    }
  return 0 ;
    }
   }

ret:
//10.04.03 11:15#ifdef   _CAN_MASTER   // для чистого slave переворачивание не имеет смысла
  //if ( can_setting(port).config._.master== 1 )
  //{
    lax = ptr->id ;
        lax1 = (lax & 0xFF000000) >> 8;
        lax2 = (lax & 0x00FF0000) << 8;
        lax3 = (lax & 0x0000FF00) >> 8;
        lax4 = (lax & 0x000000FF) << 8;
        lax = lax1 + lax2 + lax3 + lax4;
//      lax = ptr->id ;
          //asm  xchb lax   ,lax+3 ;
          //asm  xchb lax+1 ,lax+2 ;
//        lax = buff.lax ;
    ptr->id = lax;
  //}
//10.04.03 11:16#endif

  return 1 ; // приняты данные для 'slave'.

}

//-----------------------------------------------
word Load_ptr(byte port, int buf,struct canMSG_Fuj *ptr)
// Переложить из структуры в регистры объекта сообщения
// id, dlen, data[8]
{
  register byte i ;
  if ( port==0 )
  {
   //для CAN 0
   IDRX0(buf) = ptr->id ;
   DLCR0(buf) = ptr->cfg.dlen ;
   for ( i=0; i < 8; i += 2  )
    {
//vmz24102011 ???     DTR0_WORD(buf,i/2) = (w)(ptr->data[i]) + ((w)(ptr->data[i+1]) << 8) ;
     DTR0_WORD(buf,i/2) = (w)(ptr->data[i]) | ((w)(ptr->data[i+1]) << 8) ;
     // *(char*)&(DTR0_BYTE(buf,i)) = ptr->data[i] ; по-байтно не работает.
    }
   return 0 ;
  }
  else
  {
    if ( port == 1 )
    {
   //для CAN 1
   IDRX1(buf) = ptr->id ;
   DLCR1(buf) = ptr->cfg.dlen ;
   for ( i=0; i < 8; i += 2  )
    {
     DTR1_WORD(buf,i/2) = (w)(ptr->data[i]) | ((w)(ptr->data[i+1]) << 8) ; //???
    }
   return 0 ;
    } else {
      // CAN2
   IDRX2(buf) = ptr->id ;
   DLCR2(buf) = ptr->cfg.dlen ;
   for ( i=0; i < 8; i += 2  )
    {
     DTR2_WORD(buf,i/2) = (w)(ptr->data[i]) | ((w)(ptr->data[i+1]) << 8) ; //???
    }
   return 0 ;
    }
  }

}
//-----------------------------------------------
word Save_ptr(byte port, int buf,struct canMSG_Fuj *ptr)
// Переложить из регистра объекта сообщения в структуру
// id, dlen, data[8]
{
  register byte i ;

  if ( port==0 )
  {
   //для CAN 0
   ptr->id = IDRX0(buf) & _ID11 ; // срезаем лишние кроме 11-ти старших разрядов,
   ptr->cfg.dlen = DLCR0(buf) ;  // т.к. CAN-контроллер иногда заглючивает и
                                //  помещает в них мусор, а затем у мастера
                               // срабатывает защита по несовпадению id.
               for ( i=0; i < 8; i=i+2 )
   //for ( i=0; i < 8; i++ )
    {
      //ptr->data[i]   = DTR0_WORD(buf,i) ;
      //ptr->data[i+1] = DTR0_WORD(buf,i) >> 8 ;
     //ptr->data[i] = DTR0_BYTE(buf,i) ;
      ptr->data[i] = DTR0_BYTE(buf,i+1) ;
      ptr->data[i+1] = DTR0_BYTE(buf,i) ;
    }
  return 0;
  }
  else
  {
    if ( port == 1 )
    {
   //для CAN 1
   ptr->id = IDRX1(buf) & _ID11 ;
   ptr->cfg.dlen = DLCR1(buf) ;
   //            for ( i=0; i < 8; i=i+2 )
   for ( i=0; i < 8; i=i+2 )
    {
      ptr->data[i] = DTR1_BYTE(buf,i+1) ;
      ptr->data[i+1] = DTR1_BYTE(buf,i) ;
    }
  return 0;
    } else {
      // CAN 2
   ptr->id = IDRX2(buf) & _ID11 ;
   ptr->cfg.dlen = DLCR2(buf) ;
   //            for ( i=0; i < 8; i=i+2 )
   for ( i=0; i < 8; i=i+2 )
    {
      ptr->data[i] = DTR2_BYTE(buf,i+1) ;
      ptr->data[i+1] = DTR2_BYTE(buf,i) ;
    }
  return 0;
    }
  }

}

//++++++++++++++++++++++++++++++++

//-----------------------------------------

#ifdef _Micro_Master

//
//Программа инициализации дополнительных (не для основного протокола) объектов
//MO1-MO12 для реализации дополнительного CAN-протокола типа конкретного протокола для АПР2.
//
        // MO4-MO12 - для ДОПОЛНИТЕЛЬНОГО протокола
        // MO1, MO2, MO3, MO13, MO14 - для ОСНОВНОГО протокола


//"Ошибка инициализации CAN" - сообщение формируется только в этом месте.

// ВОЗВРАЩАЕМЫЙ КОД ОШИБКИ:
//Возвращает содержимое error_init_CAN.

//"0" - инициализация произведена без ошибок.
//"1" - инициализация произведена, но есть предупреждение "Ошибка инициализации CAN", -
//(в структуре задан стандартный идентификатор, но похож на расширенный - ненулевые незначащие разряды).

// > "1" - инициализация объекта не выполнена, - "Ошибка инициализации CAN".

//   "2" - уже существует Объект Сообщений с данным идентификатором.
//   "3" - ошибочный номер Объекта Сообщений (должен быть 1-:-12)
//   "4" - несоответствие структуры smsg->cfg.dir и команды "w"
//   "5" - несоответствие структуры smsg->cfg.dir и команды "r", "i", "I"
//   "6" - несуществующий код команды, - должна быть команда "w", "r", "i", "I"

//word  xInit_msgP( word cmd, byte port, byte n_obj, struct canMSG_Fuj *ptr )
word  xInit_msg( word cmd, byte port, byte n_obj, lword MO_id )
{

register union
{
  lword lax ;
  word  w[2] ;
  byte  b[4] ;
} buff ;

register byte ah ;
register byte ax ;

byte error_init_CAN ;

/* cmd   - код команды: W,w - посылать дынные ;
                        R,r - читать присланные данные ;
   port  -  номер CAN-порта. для 196 - игнорируется
   n_obj -  номер объекта сообщения, через который выполнить команду.

   ptr     -  должна быть подготовлена,
   ptr->id       -  идентификатор, с которым послать или запросить данные,
   ptr->cfg.xtd  - стандартный(0)/расширенный идентификатор(1),
   ptr->cfg.dir  - приемник(0)/передатчик(1),
   ptr->cfg.dlen - длина передаваемых данных,
   ptr->data[i]  - передаваемые/принятые данные.



struct canMSG_196 {
        lword  id ;
        struct
        {
          unsigned int rezerv :2 ;
          unsigned int xtd    :1 ;
          unsigned int dir    :1 ;
          unsigned int dlen   :4 ;
        } cfg ;
        byte data[8];
} ;
*/

  //smsg->cfg.xtd = 0 ; // на будущее для расширенного фрейма.

  error_init_CAN = 0 ;

  //смещения в адресном пространстве CAN-ячеек 196
  //smes_b  = (n_obj-1)*16 ;//для байт
  //smes_lw = (n_obj-1)*4 ;//для 4-х байт слов


  //Проверка корректности номера Объекта Сообщения
  if ( (n_obj < 7) || (n_obj > 12) )
   {
     // ошибочный номер Объекта Сообщений (должен быть 4-:-12)
     mSet_ServiceMsg2( _Srv2_NotInitOkCan ) ; /* "Ошибка инициализации CAN" */
     error_init_CAN = 3 ;
     return error_init_CAN ;
   }

    //lax = ptr->id ;
    //asm_xchb( lax   ,lax+3 );
    //asm_xchb( lax+1 ,lax+2 );

    buff.lax = MO_id ;
    if  ( buff.lax != 0 )
     {
      //TestCAN4 = buff.lax ;

      buff.lax = buff.lax << 5 ;
      ah        = buff.b[1] ;
      buff.b[1] = buff.b[2] ;
      buff.b[2] = ah ;
      ah        = buff.b[0] ;
      buff.b[0] = buff.b[3] ;
      buff.b[3] = ah ;

      //TestCAN4 = buff.lax ;
     }

    //vmz24102011
//    ah        = buff.b[3] ;
//    buff.b[3] = buff.b[0] ;
//    buff.b[0] = ah ;
//    ah        = buff.b[2] ;
//    buff.b[2] = buff.b[1] ;
//    buff.b[1] = ah ;

/*
    buff.lax = buff.lax << 5 ;
    ah        = buff.b[1] ;
    buff.b[1] = buff.b[2] ;
    buff.b[2] = ah ;
    ah        = buff.b[0] ;
    buff.b[0] = buff.b[3] ;
    buff.b[3] = ah ;
*/

   //Проверка корректности задания идентификатора Объекта Сообщения.
   //Поиск идентичного заданному идентификатора для всех активных дополнительных
   //МО исключая заданный.
   for ( ax = 7 ; ax <= 12 ; ax++ )
   {
    //CAN_init_Err1 = 0x15 ;

    //if ( (*((b*)&can_msg1con0+ax*0x10) & 0x3f) == 0x80 )

    //if ( (*(w*)((w)&BVALR0(число)+smes_port[port])  & Res_Bit[ax]) != 0 )
    //vmz211011 if ( (*(w*)((w)&BVALR0+smes_port[port])  & Res_Bit[ax]) != 0 )
//vmz24102011 НЕПРАВИЛЬНО !!!    if ( (*(w*)(&BVALR0+smes_port[port])  & Res_Bit[ax]) != 0 )
    if ( (*(w*)((lw)&BVALR0+smes_port[port])  & Res_Bit[ax]) != 0 )
    //if ( (*(&BVALR0(адр слова)+smes_port[port]/2)  & Res_Bit[ax]) != 0 )
     {
    //CAN_init_Err1 = 0x16 ;
      //если объект включен, - проверить

      //if ( smsg->cfg.xtd )
      // {
      //  //для расширенного идентификатора
      //  if ( lax == (*((lw*)&can_msg1id+ax*4)) && ((w)(n_obj-1) != ax))
      //   {
      //    //Уже существует Объект Сообщений с данным идентификатором (расширенным)
      //    mSet_ServiceMsg( _Srv_NotInitOkCan ) ; /* "Ошибка инициализации CAN" */
      //    error_init_CAN = 2 ;
      //    return error_init_CAN ;
      //   }
      // }
      //else
       {
        //для стандартного идентификатора
        //не могут быть одинаковые ID (только, если один приемника
        //а другой передатчик)

        //if ( (lax & 0x0000fffful) ==
        //           ((*((lw*)&can_msg1id+ax*4)) & 0x0000fffful )
        //                   && ((w)(n_obj-1) != ax))

        //vmz211011 if ( (*(w*)((w)&IDRX0(ax)+smesB_port[port]) & _ID11 == buff.lax & _ID11 )
        if ( (*(w*)((lw)&IDRX0(ax)+smesB_port[port]) & _ID11 == buff.lax & _ID11 )
                && ((w)(n_obj) != ax) )
         {
    //CAN_init_Err1 = 0x17 ;
          //Уже существует Объект Сообщений с данным идентификатором (стандартным)
//          if ( ((w*)(&RFWTR0+smesB_port[port]) & Res_Bit[ax])
//           == ((w*)(&RFWTR0+smesB_port[port]) & Res_Bit[n_obj]) )
//          {
           //объект, имеющий этот же ID имеет и одинаковый режим
           //0 - передача(фрейма данных или запроса удаленного фрейма)
           //1 - передача ответа на запрос
           //(одинаковый ID для разных режимов допустим)

//vmz211011 if ( (*(w*)((w)&TRTRR0+smesB_port[port]) & Res_Bit[ax])
//            == (*(w*)((w)&TRTRR0+smesB_port[port]) & Res_Bit[n_obj]) )
          if ( (*(w*)((lw)&TRTRR0+smesB_port[port]) & Res_Bit[ax])
            == (*(w*)((lw)&TRTRR0+smesB_port[port]) & Res_Bit[n_obj]) )
           {
    //CAN_init_Err1 = 0x18 ;
            //объект, имеющий этот же ID имеет и одинаковый режим
            //0 - передача фрейма данных
            //1 - передача запроса удаленного фрейма
            //(одинаковый ID для разных режимов допустим)
            mSet_ServiceMsg2( _Srv2_NotInitOkCan ) ; /* "Ошибка инициализации CAN" */
            error_init_CAN = 2 ;
            return error_init_CAN ;
           }
         }
        }
     }
   }

/*      MsgVal = 0 - нет доступа к объекту сообщения;
        TXIE   = 0 - нет разрешения прерывания по передаче;
        RXIE   = 0 - нет разрешения прерывания по приему;
        IntPnd = 0 - нет отложенного прерывания у данного объекта сообщения;

        RmtPnd = 0 - не было удаленного запроса для объекта сообщения;
        TX_REQ = 0 - не задана передача объекту;
        MsgLst = 0 - нет потерянных принимаемых сообщений;
        ( CPUUpd ) - ( передающему объекту разрешена передача );
        NewDat = 0 - не записывалась никакая информация в сегмент данных;
*/

/*      DLC     = 0 - код длины данных;
        DIR     = 0 - направление ПРИЕМ;
        Xtd     = 0 - стандартный идентификатор;
        Rezerv  = 0 - резервные разряды;
*/
      //деактивация МО
      //*((b*)&can_msg1con0+smes_b) = 0x55  ;
      //*((b*)&can_msg1con1+smes_b) = 0x55  ;
      //BVALR0 = BVALR0 & (~Res_Bit[n_obj]) ;
//vmz211011     *(w*)((w)&BVALR0+smes_port[port]) = *(w*)((w)&BVALR0+smes_port[port])
//                                      & (~Res_Bit[n_obj]) ;
     *(w*)((lw)&BVALR0+smes_port[port]) = *(w*)((lw)&BVALR0+smes_port[port])
                                      & (~Res_Bit[n_obj]) ;

      //запись идентификатора
      //*((lw*)&can_msg1id+smes_lw) = lax ;


  switch ( cmd )
  {
    //case 'W' :    //передатчик
    case 's' :    //передатчик - посылка фрейма данных

        //объект - DATA FRAME (не REMOTE FRAME)
        //TRTRR0 = TRTRR0  & (~Res_Bit[n_object]) ; //объект - DATA FRAME (не REMOTE FRAME)
//vmz211011       *(w*)((w)&TRTRR0+smesB_port[port]) = *(w*)((w)&TRTRR0+smesB_port[port])
//                                          & (~Res_Bit[n_obj]) ;
       *(w*)((lw)&TRTRR0+smesB_port[port]) = *(w*)((lw)&TRTRR0+smesB_port[port])
                                          & (~Res_Bit[n_obj]) ;
        //Загрузить ID и DATA[8]
        //проверить Load_ptr(port,n_obj,ptr) ;//?
        //если передаю не ptr, а ID и "убираю" Load_ptr(port,n_obj,ptr), -
        //Загрузить ID
//vmz211011        *(w*)((w)&IDRX0(n_obj)+smesB_port[port]) = buff.lax;

        //vmz25102011 *(w*)((lw)&IDRX0(n_obj)+smesB_port[port]) = buff.lax; //VMZ25102011 - ЗАПИСЬ ДОЛЖНА БЫТЬ СЛОВАМИ
        *(w*)((lw)&IDRX0(n_obj)+smesB_port[port]) = buff.w[0]; //VMZ25102011 - ЗАПИСЬ ДОЛЖНА БЫТЬ СЛОВАМИ
        *(w*)((lw)&IDRX0(n_obj)+smesB_port[port]+2) = buff.w[1]; //VMZ25102011 - ЗАПИСЬ ДОЛЖНА БЫТЬ СЛОВАМИ

/*
   IDRX0(buf) = ptr->id ;
   DLCR0(buf) = ptr->cfg.dlen ;
   for ( i=0; i < 8; i += 2  )
    {
     DTR0_WORD(buf,i/2) = (w)(ptr->data[i]) | ((w)(ptr->data[i+1]) << 8) ;
     // *(char*)&(DTR0_BYTE(buf,i)) = ptr->data[i] ; по-байтно не работает.
    }
*/

        break ;

    case 'w' :    //передатчик - подготовка данных на запрос удаленного фрейма

        //TRTRR0 = TRTRR0 | Res_Bit[n_object] ; //объект - REMOTE FRAME
//vmz211011       *(w*)((w)&TRTRR0+smesB_port[port]) = *(w*)((w)&TRTRR0+smesB_port[port])
//                                          | Res_Bit[n_obj] ;
       *(w*)((lw)&TRTRR0+smesB_port[port]) = *(w*)((lw)&TRTRR0+smesB_port[port])
                                          | Res_Bit[n_obj] ;
        //Загрузить ID и DATA[8]
        //проверить xWrite_msgP(port,n_obj,ptr) ; //?может не выполниться

        //Загрузить ID
//vmz211011        *(w*)((w)&IDRX0(n_obj)+smesB_port[port]) = buff.lax;
        *(w*)((lw)&IDRX0(n_obj)+smesB_port[port]) = buff.lax;

    //            П Е Р Е Д А Ч А

        break ;

    //case 'R' :    //приемник
    case 'r' :    //приемник - прием фрейма данных
    case 'i' :    //приемник - прием ответа на запрос удаленного фрейма

    //            П Р И Е М
         //объект - DATA FRAME (не REMOTE FRAME)
        //TRTRR0 = TRTRR0  & (~Res_Bit[n_object]) ;
//vmz211011       *(w*)((w)&TRTRR0+smesB_port[port]) = *(w*)((w)&TRTRR0+smesB_port[port])
//                                          & (~Res_Bit[n_obj]) ;
       *(w*)((lw)&TRTRR0+smesB_port[port]) = *(w*)((lw)&TRTRR0+smesB_port[port])
                                          & (~Res_Bit[n_obj]) ;
        //Загрузить ID и DATA[8]
        //проверить Load_ptr(port,n_obj,ptr) ;//?
        //Загрузить ID
//vmz211011        *(w*)((w)&IDRX0(n_obj)+smesB_port[port]) = buff.lax;
        //*(w*)((lw)&IDRX0(n_obj)+smesB_port[port]) = buff.lax;
        *(w*)((lw)&IDRX0(n_obj)+smesB_port[port]) = buff.w[0]; //VMZ25102011 - ЗАПИСЬ ДОЛЖНА БЫТЬ СЛОВАМИ
        *(w*)((lw)&IDRX0(n_obj)+smesB_port[port]+2) = buff.w[1]; //VMZ25102011 - ЗАПИСЬ ДОЛЖНА БЫТЬ СЛОВАМИ

        break ;

    default:

      //Неверно указан код команды, - должна быть команда "w", "r", "i", "I"
      mSet_ServiceMsg2( _Srv2_NotInitOkCan ) ; /* "Ошибка инициализации CAN" */
      error_init_CAN = 6 ;
      return error_init_CAN ;
  }

        //*((b*)&can_msg1con0+smes_b) = Set_RXIE ;
        //*((b*)&can_msg1con0+smes_b) = Set_MsgVal ;

      //активация объекта сообщения
      //BVALR0 = BVALR0 | Res_Bit[n_obj] ;
//vmz211011     *(w*)((w)&BVALR0+smes_port[port]) = *(w*)((w)&BVALR0+smes_port[port])
//                                      | Res_Bit[n_obj] ;
//     *(w*)(&BVALR0+smes_port[port]) = *(w*)(&BVALR0+smes_port[port])
//                                      | Res_Bit[n_obj] ;

     //*(w*)(&TestCAN1+2) = *(w*)(&TestCAN1+2) | Res_Bit[n_obj] ;
     //*(w*)(&TestCAN1) = *(w*)(&TestCAN1) | Res_Bit[n_obj] ;

      //BVALR2 = BVALR2 | Res_Bit[n_obj] ;
     *(w*)((lw)&BVALR0+smes_port[port]) = *(w*)((lw)&BVALR0+smes_port[port])
                                      | Res_Bit[n_obj] ;

     //*(w*)(&TestCAN1+2) = *(w*)(&TestCAN1+2) | Res_Bit[n_obj] ;
     //*(w*)(&TestCAN1) = *(w*)(&TestCAN1) | Res_Bit[n_obj] ;

      //TestCAN3 = smes_port[port] ;
      //TestCAN4 = (lw)&BVALR0+smes_port[port] ; правильно
      //(w)TestCAN5 = (w)&BVALR0+(w)smes_port[port] ;   неправильно
      //TestCAN5 = port ;
      //CAN_init_Err1 = 0x22 ;

      mClr_ServiceMsg2( _Srv2_NotInitOkCan ) ; /*Сброс сообщения "Ошибка инициализации CAN" */

      return error_init_CAN ;
}

//---------------------------

//---------------------------
//
//  Набор функций для реализации CAN-протокола типа протокола для АПР2.
//
//----------
//   cmd   - код команды: W,w - послать дынные ;
//                        R,r - прочитать присланные данные ;
//                        I,i - запросить данные.
//   port  -  номер CAN-порта.
//   n_obj  -  номер объекта сообщения, через который выполнить команду.
//   id    -  идентификатор, с которым послать или запросить данные.
//   *dscr -  перечень номеров посылаемых/принимаемых переменных из var_tab[].
//

//**************** П Е Р Е Д А Ч А *******************************
//****************************************************************
// Послать сообщение через Порт - port;  МО - n_obj; ID, dlen, data - smsg
word  xSend_msg( byte port, byte n_obj, struct canMSG_Fuj *ptr )
{

  register union
  {
    lword lax ;
    byte  b[4] ;
  } buff ;

  register byte ah ;//?

  //word Zapros ;

      buff.lax = ptr->id ;
      //?
//vmz24102011
//         ah        = buff.b[3] ;
//         buff.b[3] = buff.b[0] ;
//         buff.b[0] = ah ;
//         ah        = buff.b[2] ;
//         buff.b[2] = buff.b[1] ;
//         buff.b[1] = ah ;

    buff.lax = buff.lax << 5 ;
    ah        = buff.b[1] ;
    buff.b[1] = buff.b[2] ;
    buff.b[2] = ah ;
    ah        = buff.b[0] ;
    buff.b[0] = buff.b[3] ;
    buff.b[3] = ah ;
//         ah        = buff.b[3] ;
//         buff.b[3] = buff.b[2] ;
//         buff.b[2] = ah ;
//         ah        = buff.b[1] ;
//         buff.b[1] = buff.b[0] ;
//         buff.b[0] = ah ;
      //?

      if ( port==0 )
       {
        //для CAN 0
          // Проверка: не занят ли n_obj-й канал передачи.
        //if ( (TREQR0 && Res_TREQR[n_obj]) == 0  )
        if ( (TREQR0 & Res_Bit[n_obj]) == 0  )

         /*Zapros = ( TREQR0 >> (n_obj-1) ) && 0x0001 ;
         if ( !Zapros )*/
                                       //(IDRX0(13) != ptr->id) - проверить
         {
          //у MO[n_obj] нет запроса на передачу
          // Передача состоялась (или еще ни разу не осуществлялась)
          // Данные отосланы

          Load_ptr(port,n_obj,ptr);

          IDRX0(n_obj) = buff.lax;
          //IDRX0(n_obj) = ptr->id;

          //отправить - взвести признак передачи
          //TREQR0 = TREQR0 || Res_TREQR[n_obj] ;
          TREQR0 = TREQR0 | Res_Bit[n_obj] ;
          return 0 ;
         }
        else
         {
          //Прошлая передача еще не завершилась, -
          //новая передача не может осуществится
          //can_dd[port].Error_send++ ;
          return 1 ;
         }
       }
      //vmz - 21102011 else
      else if ( port==1 )
       {
        //для CAN 1
          // Проверка: не занят ли n_obj-й канал передачи.
        if ( (TREQR1 & Res_Bit[n_obj]) == 0  )

         /*Zapros = ( TREQR0 >> (n_obj-1) ) && 0x0001 ;
         if ( !Zapros )*/
                                       //(IDRX0(13) != ptr->id) - проверить
         {
          //у MO[n_obj] нет запроса на передачу
          // Передача состоялась (или еще ни разу не осуществлялась)
          // Данные отосланы

          Load_ptr(port,n_obj,ptr);

          IDRX1(n_obj) = buff.lax;
          //IDRX1(n_obj) = ptr->id;

          //отправить - взвести признак передачи
          TREQR1 = TREQR1 | Res_Bit[n_obj] ;
          return 0 ;
         }
        else
         {
          //Прошлая передача еще не завершилась, -
          //новая передача не может осуществится
          //can_dd[port].Error_send++ ;
          return 1 ;
         }
       }
//vmz 21102011 - добавляю второй порт CAN2
      else
       {
        //для CAN 2
          // Проверка: не занят ли n_obj-й канал передачи.
        if ( (TREQR2 & Res_Bit[n_obj]) == 0  )

         /*Zapros = ( TREQR0 >> (n_obj-1) ) && 0x0001 ;
         if ( !Zapros )*/
                                       //(IDRX0(13) != ptr->id) - проверить
         {
          //у MO[n_obj] нет запроса на передачу
          // Передача состоялась (или еще ни разу не осуществлялась)
          // Данные отосланы

          Load_ptr(port,n_obj,ptr);

          IDRX2(n_obj) = buff.lax;
          //IDRX1(n_obj) = ptr->id;

          //отправить - взвести признак передачи
          TREQR2 = TREQR2 | Res_Bit[n_obj] ;
          return 0 ;
         }
        else
         {
          //Прошлая передача еще не завершилась, -
          //новая передача не может осуществится
          //can_dd[port].Error_send++ ;
          return 1 ;
         }
       }
}
//------------------------------------------------------------------------
// Послать сообщение через Порт - port;  МО - n_obj; ID, dlen, data - smsg
word  xSend_msgP( byte port, byte n_obj, struct canMSG_Fuj *ptr )
{
  register union
  {
    lword lax ;
    byte  b[4] ;
  } buff ;

  register byte ah ;

  //word Zapros ;

      buff.lax = ptr->id ;
      //?
         ah        = buff.b[3] ;
         buff.b[3] = buff.b[0] ;
         buff.b[0] = ah ;
         ah        = buff.b[2] ;
         buff.b[2] = buff.b[1] ;
         buff.b[1] = ah ;
      //?

          // Проверка: не занят ли n_obj-й канал передачи.
        //if ( (TREQR0 && Res_TREQR[n_obj]) == 0  )
//vmz211011        if ( (*(w*)((w)&TREQR0+smes_port[port]) & Res_Bit[n_obj]) == 0  )
        if ( (*(w*)((lw)&TREQR0+smes_port[port]) & Res_Bit[n_obj]) == 0  )

         /*Zapros = ( TREQR0 >> (n_obj-1) ) && 0x0001 ;
         if ( !Zapros )*/
                                       //(IDRX0(13) != ptr->id) - проверить
         {
          //у MO[n_obj] нет запроса на передачу
          // Передача состоялась (или еще ни разу не осуществлялась)
          // Данные отосланы

          Load_ptr(port,n_obj,ptr);

          //IDRX0(n_obj) = buff.lax;
//vmz211011          *(w*)((w)&IDRX0(n_obj)+smesB_port[port]) = buff.lax;
          *(w*)((lw)&IDRX0(n_obj)+smesB_port[port]) = buff.lax;
          //IDRX0(n_obj) = ptr->id;

          //отправить - взвести признак передачи
          //TREQR0 = TREQR0 || Res_TREQR[n_obj] ;
          //TREQR0 = TREQR0 || Res_Bit[n_obj] ;
//vmz211011          *(w*)((w)&TREQR0+smes_port[port]) = *(w*)((w)&TREQR0+smes_port[port])
//                                            | Res_Bit[n_obj] ;
          *(w*)((lw)&TREQR0+smes_port[port]) = *(w*)((lw)&TREQR0+smes_port[port])
                                            | Res_Bit[n_obj] ;
          return 0 ;
         }
        else
         {
          //Прошлая передача еще не завершилась, -
          //новая передача не может осуществится
          //can_dd[port].Error_send++ ;
          return 1 ;
         }
}

//**************** П Р И Е М *************************************
//****************************************************************
// Принять сообщение через Порт - port;  МО - n_obj; ID, dlen, data - smsg
word   xRead_msg( byte port, byte n_obj, struct canMSG_Fuj *ptr )
{
  register union
  {
    lword lax ;
    byte  b[4] ;
  } buff ;

  //register byte ah ;

// Обнулять ли после приема длину принятых данных
   if ( port==0 )
   {
    //для CAN 0
    //if (RCR0 && Res_RCR[n_obj]) //Есть операция с МО_n_obj - был прием
    if (RCR0 & Res_Bit[n_obj]) //Есть операция с МО_n_obj - был прием
     {
povtor:
       // считывание n_obj-го объекта сообщения.
      Save_ptr(port,n_obj,ptr) ;
      //if (ROVRR0 && Res_ROVRR[n_obj])
      if (ROVRR0 & Res_Bit[n_obj])
       {
        //если есть переполнение может быть наложение "старых"
        //и "новых" данных - необходимо перечитать данные
        //ROVRR0 = ROVRR0 && (~ROVRR[n_obj]) ;
        ROVRR0 = ROVRR0 & (~Res_Bit[n_obj]) ;
        can_dd[port].Error_receive++ ;
        goto povtor ;
       }
      //переполнения не было - данные действительны
      //RCR0 = RCR0 &&  Res_RCR[n_obj] ;
      RCR0 = RCR0 & (~Res_Bit[n_obj]) ;
      goto ret ;
      //return 1 ;
     }
    else
     {
      // Отсутствуют новые данные в объекте n_obj
      return 0 ;
     }
   }
//vmz   else
  else if  ( port==1 )   //добавляю порт CAN2
   {
    //для CAN 1
    if (RCR1 & Res_Bit[n_obj]) //Есть операция с МО_n_obj - был прием
     {
       // считывание n_obj-го объекта сообщения.
povtor1:
       // считывание n_obj-го объекта сообщения.
      Save_ptr(port,n_obj,ptr) ;
      if (ROVRR1 & Res_Bit[n_obj])
       {
        //если есть переполнение может быть наложение "старых"
        //и "новых" данных - необходимо перечитать данные
        ROVRR1 = ROVRR1 & (~Res_Bit[n_obj]) ;
        can_dd[port].Error_receive++ ;
        goto povtor1 ;
       }
      //переполнения не было - данные действительны
      RCR1 = RCR1 & (~Res_Bit[n_obj]) ;
      goto ret ;
      //return 1 ;
     }
    else
     {
      // Отсутствуют новые данные в объекте n_obj
      return 0 ;
     }
   }
  else   //vmz добавляю порт CAN2 vmz 21102011
   {
    //для CAN 2
    if (RCR2 & Res_Bit[n_obj]) //Есть операция с МО_n_obj - был прием
     {
       // считывание n_obj-го объекта сообщения.
povtor2:
       // считывание n_obj-го объекта сообщения.
      Save_ptr(port,n_obj,ptr) ;
      if (ROVRR2 & Res_Bit[n_obj])
       {
        //если есть переполнение может быть наложение "старых"
        //и "новых" данных - необходимо перечитать данные
        ROVRR2 = ROVRR2 & (~Res_Bit[n_obj]) ;
        can_dd[port].Error_receive++ ;
        goto povtor2 ;
       }
      //переполнения не было - данные действительны
      RCR2 = RCR2 & (~Res_Bit[n_obj]) ;
      goto ret ;
      //return 1 ;
     }
    else
     {
      // Отсутствуют новые данные в объекте n_obj
      return 0 ;
     }
   }


ret:
//10.04.03 11:15#ifdef   _CAN_MASTER   // для чистого slave переворачивание не имеет смысла
  //if ( can_setting(port).config._.master== 1 )
  //{
    buff.lax = ptr->id ;
/*
//      lax = ptr->id ;
          //asm  xchb lax   ,lax+3 ;
          //asm  xchb lax+1 ,lax+2 ;
       ah        = buff.b[3] ;
       buff.b[3] = buff.b[0] ;
       buff.b[0] = ah ;
       ah        = buff.b[2] ;
       buff.b[2] = buff.b[1] ;
       buff.b[1] = ah ;
//        lax = buff.lax ;
*/
    ptr->id = buff.lax;
  //}
//10.04.03 11:16#endif

  return 1 ; // приняты данные для 'slave'.

}
//------------------------------------------------------------------------
// Принять сообщение через Порт - port;  МО - n_obj; ID, dlen, data - smsg
word   xRead_msgP( byte port, byte n_obj, struct canMSG_Fuj *ptr )
{
  register union
  {
    lword lax ;
    byte  b[4] ;
  } buff ;

  register byte ah ;

// Обнулять ли после приема длину принятых данных

    //для CAN 0
    //if (RCR0 && Res_RCR[n_obj]) //Есть операция с МО_n_obj - был прием
    //if (RCR0 && Res_Bit[n_obj]) //Есть операция с МО_n_obj - был прием
//vmz211011    if ( *(w*)((w)&RCR0+smes_port[port]) & Res_Bit[n_obj]) //Есть операция с МО_n_obj - был прием
    if ( *(w*)((lw)&RCR0+smes_port[port]) & Res_Bit[n_obj]) //Есть операция с МО_n_obj - был прием
     {
       // считывание n_obj-го объекта сообщения.
povtor:
       // считывание n_obj-го объекта сообщения.
      Save_ptr(port,n_obj,ptr) ;
      //if (ROVRR0 && Res_ROVRR[n_obj])
      //if (ROVRR0 && Res_Bit[n_obj])
//vmz211011      if (*(w*)((w)&ROVRR0+smes_port[port]) & Res_Bit[n_obj])
      if (*(w*)((lw)&ROVRR0+smes_port[port]) & Res_Bit[n_obj])
       {
        //если есть переполнение может быть наложение "старых"
        //и "новых" данных - необходимо перечитать данные
        //ROVRR0 = ROVRR0 && (~ROVRR[n_obj]) ;
        //ROVRR0 = ROVRR0 && (~Res_Bit[n_obj]) ;
//vmz211011        *(w*)((w)&ROVRR0+smes_port[port]) = *(w*)((w)&ROVRR0+smes_port[port])
//                                          & (~Res_Bit[n_obj]) ;
        *(w*)((lw)&ROVRR0+smes_port[port]) = *(w*)((lw)&ROVRR0+smes_port[port])
                                          & (~Res_Bit[n_obj]) ;
        can_dd[port].Error_receive++ ;
        goto povtor ;
       }
      //переполнения не было - данные действительны
      //RCR0 = RCR0 &&  Res_RCR[n_obj] ;
      //RCR0 = RCR0 &&  Res_Bit[n_obj] ;
//vmz211011      *(w*)((w)&RCR0+smes_port[port]) = *(w*)((w)&RCR0+smes_port[port])
//                                      & (~Res_Bit[n_obj]) ;
      *(w*)((lw)&RCR0+smes_port[port]) = *(w*)((lw)&RCR0+smes_port[port])
                                      & (~Res_Bit[n_obj]) ;
      goto ret ;
      //return 1 ;
     }
    else
     {
      // Отсутствуют новые данные в объекте n_obj
      return 0 ;
     }
ret:
//10.04.03 11:15#ifdef   _CAN_MASTER   // для чистого slave переворачивание не имеет смысла
  //if ( can_setting(port).config._.master== 1 )
  //{
    buff.lax = ptr->id ;
//      lax = ptr->id ;
          //asm  xchb lax   ,lax+3 ;
          //asm  xchb lax+1 ,lax+2 ;
       ah        = buff.b[3] ;
       buff.b[3] = buff.b[0] ;
       buff.b[0] = ah ;
       ah        = buff.b[2] ;
       buff.b[2] = buff.b[1] ;
       buff.b[1] = ah ;
//        lax = buff.lax ;
    ptr->id = buff.lax;
  //}
//10.04.03 11:16#endif

  return 1 ; // приняты данные для 'slave'.

}

// Запросить сообщение через Порт - port;  МО - n_obj; ID, dlen, data - smsg
//**************** П О С Ы Л   З А П Р О С А *********************
//****************************************************************
// Послать запрос через Порт - port;  МО - n_obj; ID, dlen, data - ptr
word xInquire_msg( byte port, byte n_obj, struct canMSG_Fuj *ptr )
{
  return xSend_msgP(port,n_obj,ptr ) ;

   // Передача состоялась (или еще ни разу не осуществлялась)
   // Данные отосланы
   //return 1 ;

   //Прошлый запрос еще не завершился, -
   //новый запрос не может осуществится
   //return 0 ;
}

//**************** ПОДГОТОВКА К ПЕРЕДАЧЕ *************************
//********* Передатчик готовит данные на случай запроса **********

// Подготовить сообщение через Порт - port;  МО - n_obj; ID, dlen, data - smsg
word xWrite_msgP( byte port, byte n_obj, struct canMSG_Fuj *ptr )
{
  register union
  {
    lword lax ;
    byte  b[4] ;
  } buff ;

  register byte ah ;

  buff.lax = ptr->id ;

  ah        = buff.b[3] ;
  buff.b[3] = buff.b[0] ;
  buff.b[0] = ah ;
  ah        = buff.b[2] ;
  buff.b[2] = buff.b[1] ;
  buff.b[1] = ah ;

//vmz211011 if ( (*(w*)((w)&TREQR0+smes_port[port]) & Res_Bit[n_obj]) == 0  )
 if ( (*(w*)((lw)&TREQR0+smes_port[port]) & Res_Bit[n_obj]) == 0  )

 //если это только для ответа на запрос удаленного фрейма
  {
   //можно обновить данные
   Load_ptr(port, n_obj, ptr) ;
   //IDRX0(n_obj) = buff.lax;
//vmz211011   *(w*)((w)&IDRX0(n_obj)+smesB_port[port]) = buff.lax;
   *(w*)((lw)&IDRX0(n_obj)+smesB_port[port]) = buff.lax;
   return 1 ;
  }
 else
  {
   //выставлен запрос передачи, - нельзя обновить данные
   //(если во время обновления произойдет передача, - могут быть
   //искаженные данные)
   return 0 ;
  }
}

//---------------------------------------------------------------------------
#endif
//---------------------------------------------------------------------------

__interrupt  void CAN0_RX_Interrupt ( void )
{
  if ( can_setting(_CAN0_Port).config._.mcovkl == 0 )
  {
      canSlaveDrive(_CAN0_Port);
  }
#ifdef _CANOPEN
  else
  {
     ISR_CAN(_CAN0_Port);
  }
#endif
}

__interrupt  void CAN1_RX_Interrupt ( void )
{
  canSlaveDrive(_CAN1_Port);
}

#ifndef _CAN_SLAVE_IRQ_CAN2

__interrupt  void CAN2_RX_Interrupt ( void )
{
  canSlaveDrive(_CAN2_Port);
}

#else

   12-03-2014 - перенес в ATK Encoder.c  VMZ

#endif
