
//         ПРОГРАММА ТЕСТИРОВАНИЯ ВЫХОДНЫХ ДИСКРЕТНЫХ СИГНАЛОВ .
//------------------------------------------------------------------
/*   Режим доступен из "Останова".
 *   Функции:
 * - выбор порта выходных сигналов из таблицы путем перебора ;
 * - индикация последнего записанного в порт значения в двоичном
 *  поразрядном виде;
 * - модификация посредством клавиатуры поразрядно в двоичном виде значения
 *  перед записью его в порт;
 * - запись в порт модифицированного значения.
 *   Клавиши:
 * - "+" или "-" в режиме выбора порта - выбор порта ;
 * - "Enter" в режиме выбора порта - переход к индикации и модификации
 *  содержимого порта;
 * - "+" или "-" в режиме индикации - перевод курсора к очередному старшему
 *  либо младшему разряду порта соответсвенно ;
 * - "F" или "f" в режиме индикации - инвертирование разряда, на котором
 * установлен курсор, без его записи в порт;
 * - "Enter" в режиме индикации - запись модифицированного значения
 *  содержимого порта в порт;
 * - "Esc" в режиме выбора порта - возврат в диспетчер ;
 * - "Esc" в режиме индикации - переход к режиму выбора порта.
 */


void TstOutputPort_Drive ( void )
{
   register byte  bh , cl ;

      if ( M_FirstCall == 1 )  /*  Идентификация первого входа для задания  */
        {                      /* начального условия ...                    */
          M_FirstCall = 0 ;
          Label = 101 ;
          m_index = 0 ;
          output_s ( _Output_Tst ) ;
          return ;
        }

  switch ( Label )
    {
      default: Label = 101 ;
      case 101:   // Ожидание завершения предыдущего вывода.
              if ( TestCompleted_Output() )
                {
                  output_c ( '\n' ) ;
                  output_c ( '\r' ) ;
                  output_s ( Nstout[ m_index ].txt ) ;
                  Label = 105 ;
                  break ;
                }
      case 105:while ( TestData_for_Input() )
                {
                  mInput_c ( bh ) ;
                  if ( bh == Return )
                    {
                      Pult_Prog_Addr = _MainPultProg,  M_FirstCall = 1 ;
                      return ;   // добавить еще какую-то иниц.
                    }
                  else if ( bh == Up ) /* Выбрать номер порта.*/
                    {
                      if ( ++m_index >= _Nout ) m_index = 0 ;
                      Label = 101 ;
                    }
                  else if ( bh == Down ) /* Выбрать номер порта.*/
                    {
                      if ( m_index-- == 0 ) m_index = _Nout - 1 ;
                      Label = 101 ;
                    }    /* переход к следующей настройке */
                  else if ( bh == Enter )  Label = Nstout[ m_index ].label ;
                }
              break ;
            //-------------------

      case 20:
              output_c ( '\n' ) ;
              output_c ( '\r' ) ;
              output_c ( _Output_Tst_c ) ;
              bh = m_buff[0] = *Nstout[ m_index ].Px ;

                /*   Преобразование содержимого копии порта в двоичный
                 * символьный вид.
                 */
              for ( cl = 0 ; cl <= 7 ; cl++ )
                {
                  if ( (sb)bh < 0 ) output_c ( '1' ) ;
                  else              output_c ( '0' ) ;
                  bh <<= 1 ;
                }
              output_c ( _Output_Tst_m ) ;
              output_c ( '\b' ) ;
              output_c ( '\b' ) ;
              m_ext = 0 ;
              Label = 30 ;
              break ;
            //-------------------

      case 30:
              while ( TestData_for_Input() )
                {
                  mInput_c ( bh ) ;
                  if ( bh == Return )  Label = 101 ;
                  else if ( bh == Up ) /* Выбрать номер бита.*/
                    {
                      if ( m_ext < 7 )
                        {
                          m_ext++ ;
                          output_c ( '\b' ) ; // сместиться на позицию влево.
                        }
                    }
                  else if ( bh == Down ) /* Выбрать номер бита.*/
                    {
                      if ( m_ext != 0 )
                        {
                          m_ext-- ;
                          output_c ( '\xff' ) ; // сместиться на позицию вправо.
                        }
                    }      /* Проинвертировать выбранный бит.*/
                  else if ( bh == Enter )
                    {
                      bh = 0x01 << m_ext ;
                      m_buff[0] ^= bh ;
                      if ( ( m_buff[0] & bh ) == 0 )  output_c ( '0' ) ;
                      else                            output_c ( '1' ) ;
                      output_c ( '\b' ) ;
                          /* Вывод в порт скорректированной копии данных. */
                      *Nstout[ m_index ].Px  = m_buff[0] ;
                    }
                }
              break ;
            //-------------------

      }

  Restart_Output ()  ;

  return ;
}

