#ifndef _pdf_drv_c
#define _pdf_drv_c

/*-----------------06.12.02 13:37-------------------
Для того, чтобы использовать DMA для ПДФ необходимо:
 1. Определить, что будет исползоваться в качастве входа ПДФ.
 Приоритет прерывания источника DMA, необходимо сделать самым
 низким и програму обработки прерывания делать не надо.
 2. Источник DMA задается регистром DMACA.
 3. Адрес источника и приемника необходимо задавать в неиспользуемой
 области, чтобы не портить работу программы.
 4. Счетчик DMA вычитающий. Для работы DMA необходимо чтобы в нем было
 начальное число. Находится счетчик в младших 16-ти разрядах регистра
 DMACA.
 5.Если возникнут ошибки при измерениях (стабильные) необходимо изменить
 значение регистра HRCL (задается приоритет прерываний, ниже которого прерывания
 не будут ставиться в очередь), однако изменять его необходимо осторожно, так как
 прерывания с низким приоритетом могут пропускаться. Прерывание, по котрому будут
 считываться значения счетчика должны иметь более высокий приритет, чем стоит в
 регистре HRCL, т.к. тогда могут быть ошибки в два или три раза из-за пропуска
 считаваний.
 6. После каждого считывания в регистрах DMA необходимо востанавливать значение
 счетчика и адрес приемника и источника(чтобы они не заползли в рабочую зону).
--------------------------------------------------*/
//#define  mPDF_timer_clr() DMASA0 = 0xf0000u;\
  //                        DMADA0 = 0xf0000u;\
    //                      DMACA0 |=0x0000ffff
void pdf_drv_init( word num )
{
  //num = num ;

      // в prt_cpu.c // PK0 - INT0 используется для ПДФ (FX0+FX1), он же идет на DREQ0.
                     // PL3 - ПДФ FX0 или EPA компаратор синхронизации.
                     // PB1 - используется для ПДФ FX1.
                     // Для FR50        : INT1  - ПДФ: оборотный FZ.
                     // Для FR50N и RCP : ALARM - ПДФ: оборотный FZ.
         //   Для определения направления прерываемся по переднему(заднему)
         // фронту F00, а читаем F90.
  DMACR  = 0;

  //????-ПРОВЕРИТЬ ПЕРЕЗАГРУЗКУ СЧЕТЧИКА

  DMACB0 = 0x00800000u;
  DMASA0 = 0xf0000u;//Где-то в области ПЗУ на F-bus, которого у нас нет
  DMADA0 = 0xf0000u;

//----------------------------------------------------
  ENIR_EN0 = 0;
  ICR00 = 31;
  ELVR_LAB0 = 3;
  EIRR_ER0 = 0;
  ENIR_EN0 = 1;
  HRCL = 0;
//----------------------------------------------------

  DMACR  = 0x80;

  DMACA0 = 0x9411ffffu;
  //Настройка ЕРА для выделения знака скорости.
   //По переднему фронту.

  ICS23_EG11 = 0;
  ICS23_EG10 = 1;

  pdf_fz_init (num) ; // инициализация оборотного ПДФ .

  pdf_drv_data[num].Tpdf_time = timer1 ;
  pdf_drv_data[num].Tpdf      = _PDF_base_time * 5 ;
  pdf_drv_data[num].Scht_T    =  0 ;
  pdf_drv_data[num].sign      =  0 ;

   //Разрешение прерывания.
  pdf_ei (num) ;

  return ;
}
//-------------------

// Функция разрешения прерывания для определения знака ПДФ .
void pdf_ei ( word num )
{
  num = num ;
  ICS23_ICP3 = 0 ;        // сбрасываем запрос по ЕПА .
  ICS23_ICE3 = 1 ;        // разрешаем прерывания ЕПА .
  ICR28 = _PDF_PRIORITY ; // приоритет прерывания .
  return ;
}
//-------------------

// Функция запрета прерывания для определения знака ПДФ .
void pdf_di ( word num )
{
  num = num ;
  ICS23_ICP3 = 0 ;        // сбрасываем запрос по ЕПА .
  ICS23_ICE3 = 0 ;        // запрещаем прерывания ЕПА .
//ICR28 = _PDF_PRIORITY ; // приоритет прерывания .
  return ;
}
//-------------------

// Функция инициализации оборотного ПДФ .
void pdf_fz_init ( word num )
{
  num = num ;
  //PDF[num].fz = 0 ;     // инициализация счетчика оборотов в PDF.C .
#ifndef _NO_INT1
  DDRK_DDK1 = 0;          // INT1-вход
  ENIR_EN1 = 0;           // флаг устанавливается, но запроса нет
  ELVR_LAB1 = 3;          // флаг устанавливается при заднем фронте
  EIRR_ER1 = 0;           // Сброс бита запроса прерывания
#else
  // Для _RCP и _FR50N_ вход ПДФ FZ может заводится только на аналоговый компаратор ALARM .
#endif

  // Прерывания по этому входу не разрешаем , и приоритет не задаем , т.к.
  // при даже при скорости 1500 об/мин , в 1 мс будет 1500/60000=0.025 оборот .
  // 0.025*360=9грд . Если такая точность удовлетворительна , то подсчет
  // оборотов можно производить в фоне .

  return ;
}
//-------------------

// Функция подсчета оборотов ПДФ и определения угла поворота ( вызывать в фоне
// или в прерывании - определить выше в инициализации pdf_fz_init () ) :
void pdf_fz ( word num )
{
  //num = num ;
#ifndef _NO_INT1
  if ( EIRR_ER1 == 1 )
   {
     if ( (sb)pdf_drv_data[num].sign > 0 ) PDF[num].fz++ ;
     else                                  PDF[num].fz-- ;
     EIRR_ER1 = 0 ;         // сбрасываем запрос прерывания .
   }
#else
  num = num ;
  // Для _RCP и _FR50N_ вход ПДФ FZ может заводится только на аналоговый компаратор ALARM .
#endif
  // Определение угла поворота в градусах пока не продумывал ...
  return ;
}
//-------------------

      //  чтение текущего значения счетчика импульсов,
     // счетчик считает непрерывно, не сбрасывается.
word pdf_drv_read( word num )
{
  register word ax ;
  num = num ;
  ax = DMACA0 ; // сам счетчик 32-х разрядный.

 //  После каждого считывания в регистрах DMA необходимо востанавливать значение
 // счетчика и адрес приемника и источника(чтобы они не заползли в рабочую зону).
  DMASA0 = 0xf0000u;
  DMADA0 = 0xf0000u;
  //DMACA0 |=0x0000ffff

  return (~ax) ;  // счетчик на вычитание => превращаем его на сложение.
}
//-------------------

//   Прерывания для определения направления вращения
//   и периода импулсов.
__interrupt void pdf0_Interrupt   (void)
{
  word count , ax ;
  pP( 1 ) ;
//  ICS23_ICP3 = 0 ;  // Сброс запроса прерывания перенесён в конец функции .

 ax =  pdf_epa_time - pdf_drv_data[0].Tpdf_time ; // расчет периода импульсов ПДФ .
 pdf_drv_data[0].Tpdf_time = pdf_epa_time ; // время предыдущего прихода импульса F00 .
 //---
#ifdef _T_PDF
 // Усредненный период для скорости вычисляется только в случае, когда период между предыдущим
//и текущим импульсом меньше 50ms.
 if ( PDF[0].flg._.t_ogr_pdf != 1 )
  {
    pdf_drv_data[0].Tpdf += ax ;  // сумма периодов импульсов ПДФ .
    pdf_drv_data[0].Scht_T++ ;    // счетчик периодов импульсов ПДФ .
  }

  PDF[0].flg._.t_ogr_pdf = 0 ; // сброс флага .

 if ( (w)PDF[0].Fpdf > (c)( 20 * _PDF_Kmul ) ) // При количестве пар импульсов ( F00 и F90 )
   {                                           // больше 20 определять знак уже не надо :
    ICS23_ICP3 = 0 ;  // Сброс запроса прерывания.
    return ;
   }
#endif
  //---
     //   Для определения направления прерываемся по переднему
     // фронту F00 (вход EPA3) , а читаем F90 (вход PDRB_PDB1) .
     //   Базовое время ПДФ (10-2=8мс) делим на интервал между импульсами F00 .
     // Чем чаще идут импульсы , тем больше повторов знака должно накопиться .
     // Полученное при делении число пропорционально максимальному количеству
     // повторов знака скорости .
  //---
  // Базовое время - 8мс делим на время между F00 .
  count = ( (c)( _PDF_base_time * 0.8 ) ) / (u)ax ;
  //---
  if ( PDRB_PDB1 == 1 ) // направление Назад :
   {
     count = ~count /*+ 1*/ ; // при направлении Назад инвертируем счетчик и
     // не прибавляем 1 , чтобы +0 соответствовало -1 ( Принцип : -2 -1 | 0 1 ).
     //--- Защита от переполнений :
     if      ( (sw)count < -7 ) count = -7 ;
     else if ( (sw)count > -1 ) count = -1 ;
     //---
     ax = (sw)(sb)pdf_drv_data[0].sign ;
     ax-- ;
     if ( (sw)ax < (sw)count )  pdf_drv_data[0].sign = (sb)count ;
     else                       pdf_drv_data[0].sign = (sb)ax ;
   }
  else                 // направление Вперед :
   {
     //--- Защита от переполнений :
     if      ( (sw)count > 6 ) count = 6 ;
     //---
     ax = (sw)(sb)pdf_drv_data[0].sign ;
     ax++ ;
     if ( (sw)ax > (sw)count )  pdf_drv_data[0].sign = (sb)count ;
     else                       pdf_drv_data[0].sign = (sb)ax ;
   }
  // Сбрасываем запрос прерывания в конце , чтобы не схватить старые данные с
  // прошедшего фронта .
  ICS23_ICP3 = 0 ;  // Сброс запроса прерывания.
  pP( 0 ) ;
  return ;
}
#endif
