
//#include "include.h"

/*  ѕрограмма инициализации послед.порта, его прерывани€ и буферов дл€ прерывани€.  */

void  Init_timer ( void )
{
  TCCS0_STOP=1;    /* ƒл€ инициализации останавливаем счетчик*/

//  6: TCCS0_IVF  = 0;    /* очищаем флаг запроса */
//  5: TCCS0_IVFE = 1;    /* разрешение прерывани€ */
//  4: TCCS0_STOP = 1;    /* ƒл€ инициализации останавливаем счетчик*/

//  3: TCCS0_MODE = 0;    /* инициализаци€ по сбросу или биту CLR */
//  2: TCCS0_CLR  = 1;    /* устанавливаем счетчик в 0X0000  */
//  1: TCCS0_CLK1 = 0;    /* ƒискрета - 1 мкс (R-bus clk)/16 */
//  0: TCCS0_CLK0 = 1;

    timer1 = 0;
    timer2 = 0;
    TCCS0 = 0x35;  //0011 0101 т.к. R-bus clk = 16 ћ√ц.
    TCCS1 = 0x15;  //0011 0101 т.к. R-bus clk = 16 ћ√ц.

  ICR32 = 19; //ѕриоритет прерывани€ по таймеру0

  TCCS0_STOP=0;    /* ¬ключаем счетчик*/
  TCCS1_STOP=0;    /* ¬ключаем счетчик*/

  //ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ »нижиализажип вбее ваймеаов ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ
    timer1 = 0,  Timer1_Ovr = 0,  Timer1_fSec = 0 ;

  return   ;
}
/*ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ-  */

__interrupt void Timer_Interrupt (void)
{
  asm_ei();
  TCCS0_IVF = 0;   /* очищаем флаг запроса */
  //++PDRM_PDM1 ;
  ++Timer1_Ovr;
  //Ovr_Time_Schet(&msg_reg.time);

      /*--------------------------------------------------------------------------
       *    »спользуетс€ дл€ вывода информации на дисплей в режиме "бегущей строки".
       *  »нформаци€ дл€ вывода беретс€ из того же буфера вывода, что и преры-
       *  ванием по TXD, по-этому эти два прерывани€ одновременно не совместимы.
       *  ѕри переходе от вывода по TXD к выводу по прерывани€м по переполнению
       *  Timer1, необходимо:
       *    int_mask1 &=  ~TXD_IntEnable ; - запретить прерывание по TXD ;
       *    Mon.Pult = 1 ;   - установить признак работы с пультом "бегуща€ строка",
       *      что используетс€ дл€ обхода записи "затравки" в TXD из рабочих программ.
       *
       *  ѕри переходе от вывода по Timer1 к TXD, необходимо:
       *    Mon.Pult = 0 ;   - сбросить признак работы с пультом "бегуща€ строка",
       *       что разрешит запись "затравки" в TXD из рабочих программ дл€ запуска
       *       прерываний по TXD ;
       *    int_mask1 |= TXD_IntEnable  ;   - разрешить прерывание по TXD.
       */
       if ( Mon.UartCAN_Connect == 0 )
       {
         if ( Mon.Pult == 1 )
          {
            if ( --Count_SymbolPauza == 0 )  // отсчет паузы между символами
              {
                Count_SymbolPauza = _SymbolPauza ;
                if ( mTestYesData_in_Buff_TXD() )
                  {
                    mSymbol_from_Buff_TXD( SODR0 ) ;
          }   }   }
       }
	return;
}

