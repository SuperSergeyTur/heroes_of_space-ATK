//#include "include.h"


void  Start_RXD_TXD ( void )
{
  Reg_ServiceMsg   = 0 ;

  Label          = 0x0u    ;

  M_FirstCall    = 1 ;
  Pult_Prog_Addr = 0 ;
  Klav_Buff = 0 ;
  m_old = 0 ;

  Count_SymbolPauza = _SymbolPauza ;

    Mon.Pult  = 1  ;
//    Mon.Parolle = 0  ;
    Mon.EnableSrvMsg = 1 ;
//    Mon.Otkl_InOut = 0 ;

    Mon.i2c_busy = 0 ;
    Mon.RXBuffOverflow = 0 ;

  OutTxBuffCount = 0x0u   ;
  InTxBuffCount  = 0x01u  ;
  OutRxBuffCount = 0x0u   ;
  InRxBuffCount  = 0x01u  ;

  Mon.UartCAN_Connect = 0 ;
  Mon.RX_Data_ok = 0 ;

  //------------- HARDWARE INSTALL----------------------------
//UTIMC0_UCC1 = 1;UTIMR0 = 7;

 UTIMC0_UCC1 = 0;UTIMR0 = 25;//51;
                                    /* 19200 Baud(UTIMR0 = (Ф/(32*bps))-1
                                    где Ф - R-bus clock(определяется в startup.asm
                                        bps - необходимая скорость соединения.
                                    формула справедлива для TIMC0_UCC1 = 0
                                    при TIMC0_UCC1 = 1 справедлива следующая
                                    формула:   UTIMR0 = (Ф/(32*bps))-1.5

                                          */

 /*SCR0_CL  = 1;  // 8 Databits
   SCR0_SBL = 0;  // 1 Stopbit
   SCR0_PEN = 0;  // no parity
   SCR0_RXE = 1;  // Receive enable
   SCR0_TXE = 1;  // Transmit enable*/

   SCR0 = 0x13; //00010011

 /*SMR0_MD0 = 0;  // async normal mode
   SMR0_MD1 = 0;
   reserved = 1;
   reserved = 1;
   SMR0_CS0 = 0;  //select U-timer
   reserved = 0;
   reserved = 0;
   reserved = 1;*/

   SMR0 = 0x31;//00110001

 /*SSR0_RIE = 1;  // RX Interrupt enable
   SSR0_TIE = 1;  // TX Interrupt enable*/
   SSR0 = 0x03;//00000011

   ICR37 = 22; // Приоритет прерывания по RX UART0
   ICR38 = 23; // Приоритет прерывания по TX UART0

   UTIMC0_UTST = 1;  /* Start U-Timer */

   asm_ei() ; //qwer

}

  void  Speed_Pult ( void )
{
    if ( Mon.Pult != 1 )
      {
        SSR0_TIE = 0 ;
        Mon.Pult = 1 ;  /* устанавливать после запрета прерывания TXD  */
      }
    else
      {
        Mon.Pult = 0 ;  /* устанавливать до разрешения прерывания  TXD  */
        SSR0_TIE = 1 ;
      }
    Pult_Prog_Addr = _MainPultProg ; /*_MainPultProg  ; */
    return ;
}

      /*   "TXE_BIT" - в режиме TXD признак того, что из буфера вывода все выбрано,
       * прерывания прекратились и сами по себе не возобновятся, даже если в буфере
       * вывода появятся данные => прерывание нужно вызвать искусственно.
       *   Если установлен бит "Mon.Pult" - признак медленного вывода через ЕПА,
       * то вышесказанное неверно и "искусственных" записей в  порт делать не надо.
       */
void   mRestart_Output( void )
{        /* если порт свободен и есть данные на вывод ...  */
    if ( ( SODR0_FREE == 1  ) && ( mTestYesData_in_Buff_TXD() ) )
    {     /*  и пульт не в режиме медленного вывода то запускаем прерывания: */
         /* разрешаем прерыв., а т.к. TDRE всегда взведен, то прерыв. сразу сработает. */
      if ( Mon.Pult == 0 && Mon.UartCAN_Connect == 0 ) SSR0_TIE = 1 ;
    }
  return ;
}
/*ДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДД-  */

/*   П/п обработки прерываний от последовательного порта по приему.
 *  Принятые байты заносятся в буфер 'RxBuff[]' (массив типа 'unsigned char')
 * в ячейку на которую указывает указатель "InRxBuffCount". После записи
 * очередного символа этот указатель увеличивается на единицу, таким образом
 * он всегда указывает на ячейку в которую будет записан следующий байт
 * (т.е. на пустую). Если указатель дошел до конца буфера , то он возвра-
 * щается снова к его началу и так по кругу. Для того чтобы не надо было
 * контролировать достижение
 * указателем конца буфера размер буфера "RxBuffSize+1" принимается равным 2,4,
 * 8,16,32,64,128,256. В этом случае величина указателя не выходит за сетку
 * 1,2,3,4,5,6,7,8-ми младших битов. Поэтому перемещение указателя к следующей
 * позиции осуществляется так:
 *      InRxBuffCount = ( InRxBuffCount + 1 ) & RxBuffSize ;
 * увеличивается на единицу и на него накладывается маска обрезающая ненужные
 * старшие биты. Таким вот образом имитируется 1,2,3,4,5,6,7,8-ми битовое поле
 * сетки указателя и он, дойдя до конца буфера, в результате "переполнения" своей
 * сетки сам возвращается к началу буфера.
 *  Считывание данных из буфера рабочей программой производится посредством
 * указателя "OutRxBuffCount". Организация этого указателя абсолютно идентична
 * вышеописанной. Он всегда указывает на ячейку из которой ранее было произведено
 * считывание (т.е.пустую). По-этому перед считыванием его следует увеличить на
 * единицу операцией :
 *     "OutRxBuffCount = ( OutRxBuffCount + 1 ) & RxBuffSize ;" ,
 * а после этого прочитать байт из буфера. Указатель "OutRxBuffCount" всегда
 * "отстает" от "InRxBuffCount". Перед считыванием данных из буфера следует
 * убедиться , что они там есть. Для этого необходимо проверить не сравняется
 * ли указатель считывания с указателем записи если первый увеличить на единицу.
 * Если оказывается что они в результате этого станут равными - значит буфер пуст.
 *   Аналогично перед записью данных в буфер в прерывании следует убедиться, что в буфере
 * еще оталось место. Для этого необходимо проверить не сравняется ли указатель
 * записи с указателем считывания если первый увеличить на единицу.
 * Если оказывается что они в результате этого станут равными - значит в буфере
 * места нет и принятый байт записывать некуда, при этом устанавливается
 * признак переполнения "Mon.RXBuffOverflow = 1" и принятый байт теряется.
 */
/*    При считывании "sp_stat" сбрасывается все биты кроме TXE, сколько бы
 * Вы его не считывали.
 *    "TXE" сбрасывается только после записи в порт "TX" одного и более
 * символа, т.е. тогда, когда !сдвиговый регистр! на передачу перестает быть
 * пустым.
 *    А устанавливается "TXE" тогда, когда пуст !сдвиговый регистр! на
 * передачу, т.е. он из себя все выпихнул и поле этого в него ничего не
 * провалилось из его аппаратного буфера порта "TX" => пусты и сдвиговый
 * регистр и его буфер.
 *    При пустых сдвиговом регистре и его буфере в порт TX можно записывать
 * подряд без малейшей задержки два символа. Если записать больше, то
 * все остальные кроме первого будут потеряны.
 *
 *  В связи с вышесказанным в "pts-RXD" можно считывать при приеме пословно,
 * т.к. "sbuf_rx" и "sp_stat" расположены рядом и не бояться, что будет
 * закрыта от "TXD" его личная информация, кроме бита "TI", который при
 * работе в режиме прерываний и не нужен.
 */
__interrupt void RXD_Interrupt (void)
{
  static char al ;

    asm_ei() ;

    if ( SSR0_FRE == 1 || SSR0_ORE == 1 || SSR0_PE == 1 )
    {
      SCR0_REC = 0 ;
      al = SIDR0 ; /* чтобы сбросить лишний запрос */
    }
    else
    {
      //if ( Mon.UartCAN_Connect == 0 ) mSymbol_in_Buff_RXD( SIDR0 ) ;
      //else al = SIDR0 ;
      mSymbol_in_Buff_RXD( SIDR0 ) ;
      Mon.RX_Data_ok = 1 ;
    }
    return ;
}
/*---------------------------------------------------*/
/*   Прерывание от последовательного порта по передаче генерируется тогда,
 *  когда из сдвигового регистра начал передаваться последний бит передавае-
 * мого байта.
 *   П/п обработки прерываний от последовательного порта по передаче.
 *  Передаваемый байт заносится предварительно рабочей программой в буфер
 * 'TxBuff[]' (массив типа 'byte')
 * в ячейку на которую указывает указатель "InTxBuffCount". После записи
 * очередного символа этот указатель должен увеличиваться на единицу, таким образом
 * он всегда указывает на ячейку в которую следует заносить следующий байт
 * (т.е. на пустую). Если указатель дошел до конца буфера , то его возвра-
 * щают снова к его началу и так по кругу. Для того чтобы не надо было
 * контролировать достижение
 * указателем конца буфера, размер буфера "TxBuffSize+1" принимается равным 2,4,
 * 8,16,32,64,128,256. В этом случае величина указателя не выходит за сетку
 * 1,2,3,4,5,6,7,8-ми младших битов. Поэтому перемещение указателя к следующей
 * позиции осуществляется так:
 *     "InTxBuffCount = ( InTxBuffCount + 1 ) & TxBuffSize ;"  -  указатель
 * увеличивается на единицу и на него накладывается маска обрезающая ненужные
 * старшие биты. Таким вот образом имитируется 1,2,3,4,5,6,7,8-ми битовое поле
 * сетки указателя и он, дойдя до конца буфера, в результате "переполнения"
 * своей сетки сам возвращается к началу буфера.
 *  Считывание данных из буфера подпрограммой прерывания производится посредством
 * указателя "OutTxBuffCount". Организация этого указателя абсолютно идентична
 * вышеописанной. Он всегда указывает на ячейку из которой ранее было произведено
 * считывание (т.е.пустую). По-этому перед считыванием его следует увеличить на
 * единицу операцией :
 *      OutTxBuffCount = ( OutTxBuffCount + 1 ) & TxBuffSize ;
 * а после этого прочитать байт из буфера и записать его в буфер порта
 * "sbuf_tx" (если он, конечно, свободен).
 * Указатель "OutTxBuffCount" всегда "отстает" от "InTxBuffCount".
 * Перед считыванием в прерывании данных из буфера следует
 * убедиться , что они там есть. Для этого необходимо проверить не сравняется
 * ли указатель считывания с указателем записи, если первый увеличить на единицу.
 * Если оказывается что они в результате этого станут равными - значит буфер пуст.
 *   Аналогично перед записью данных в буфер в рабочей программе следует
 * убедиться, что в буфере еще осталось место. Для этого необходимо проверить
 * не сравняется ли указатель записи с указателем считывания если первый
 * увеличить на единицу. Если оказывается, что они в результате этого станут
 * равными - значит в буфере места нет и принятый байт записывать некуда, при
 * этом следует либо подождать пока место появится, либо проигнорировать это
 * обстоятельство.
 *  Примечание: порт 'TXD' имеет буфер, что позволяет загружать в порт сразу
 * по два байта и, в результате, передавать их друг после друга без малейшей
 * задержки, непрерывной чередой. Это классно, это огромное достоинство. Но
 * это может стать не посилам медленно принимающей стороне и она не будет
 * успевать вынимать принимаемые байты из своего порта и, в результате, терять
 * их. На этот случай предусмотрена возможность запрета записи в буфер порта
 * второго байта, что приведет к появлению некоторой задержки между передачами
 * отдельных байт, равной минимум времени обработки самого прерывания от 'TXD',
 * и это облегчит условия работы принимающей стороны. Запрет осуществляется
 * установкой в единицу признака " Mon.TXD_PoOdnomuBytu ".
 */

__interrupt void TXD_Interrupt (void)
{
  asm_ei() ;

     /*    Пуст и буфер и сдвигающий регистр => запись в порт первого символа
      * (если таковые в буфере есть), который сразу провалится в сдвигающий
      * регистр. */
  // ++PDRM_PDM1 ;
    if ( mTestYesData_in_Buff_TXD() && Mon.UartCAN_Connect == 0 )
    {
      mSymbol_from_Buff_TXD( SODR0 ) ;
      SODR0_FREE = 0 ;
    }
    else
    {
      SSR0_TIE = 0 ;  // запрещаем прерывания TXD, т.к. бит запроса
      SODR0_FREE = 1 ; // прерыв. при отсутствии данных ничем не сбрасыв-ся.
    }
  return   ;
}
//Программа изменения скорсти UART
void Set_Uart_Speed (word baud)
{
 /* lword lax;
  word ax;
  // Baud(UTIMR0 = (Ф/(32*bps))-1
  //  где Ф - R-bus clock(определяется в startup.asm
  //      bps - необходимая скорость соединения.
  //  формула справедлива для TIMC0_UCC1 = 0

  lax = baud * 32;
  ax = (R_BUS_CLOK / lax) -1 ;
  fr1 = ax;
 // UTIMR0 = ax;
 */
    switch (baud)
    {
        default:
        case 19200:
                UTIMC0_UCC1 = 0;UTIMR0 = 25;
                break;
        case 38400:
                UTIMC0_UCC1 = 0;UTIMR0 = 12;
                break;
        case 56000:
                UTIMC0_UCC1 = 0;UTIMR0 = 8;
                break;
        case 57600:
                UTIMC0_UCC1 = 1;UTIMR0 = 7;
                break;
   }

}
