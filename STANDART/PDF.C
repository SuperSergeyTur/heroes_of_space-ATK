
#include "pdf_drv.c"


      //  Настройки для ПДФов.

void pdf_init ( void )
{
  word ax ;
  for ( ax = 0 ; ax < _PDF_Num ; ax++ )   pdf ( 0 , ax ) ;

  return ;
}

void pdf_input ( void )
{
  word ax ;
  static word PDF_time ;

#ifdef _T_PDF
  word bx ;
  //---
  for ( ax = 0 ; ax < _PDF_Num ; ax++ )
  {
  //если период импульсов по ПДФ не садился на ограничение по максимому,
  //ограничением является значение "_PDF_base_time * 5" = 50ms.
  if ( PDF[ax].flg._.t_ogr_pdf == 0 )
   {
    asm_di();
    bx = timer1 - pdf_drv_data[ax].Tpdf_time ;
    if ( (u)((w)bx) > (_PDF_base_time * 5) )
      {
       PDF[ax].flg._.t_ogr_pdf = 1 ;
       if ( pdf_interrupt(ax) == 1 )  PDF[ax].N_Tpdf = 0 ; // если прерывания разрешены
      }
    asm_ei();
   }
  }
#endif

  ax = timer1 - PDF_time;
  if ( (u)((w)ax) <  _PDF_base_time )  return ;
  PDF_time = timer1;

  for ( ax = 0 ; ax < _PDF_Num ; ax++ )   pdf ( 1 , ax ) ;

  return ;
}

//   Скорость по ПДФ можно рассчитывать по частоте импульсов или по периоду импульсов , например ,
// рассчет дискрет 10 импульсов за базовое время 10 мс :
// 1. По частоте : 10 имп * _PDF_Kmul = 40 ( 590 проц.) или 20 ( 360 проц.)
// 2. По периоду : _PDF_base_time / 10 имп = 10000 мкс / 10 имп = 1000 мкс = 1000 дискрет timer1 .
//
// |------|------------|-------------|------------|
// | имп  | Дискреты   |  Дискреты   | Дискреты   |
// | за   | по частоте |  по частоте | по периоду |
// | 10мс | 590 проц.  |  360 проц.  |            |
// |------|------------|-------------|------------|
// |  10  |    40      |    20       |    1000    |
// |  30  |    120     |    60       |    333     |
// |  50  |    200     |    100      |    200     |
// | 100  |    400     |    200      |    100     |
// |------|------------|-------------|------------|
//
//   Как видно из таблицы , при небольших скоростях и , соответственно , небольших количествах
// импульсов бОльшее количество дискрет , а значит , и бОльшую точность дает рассчет по периоду .
// По достижению порога ( сейчас принят 40 имп за 10 мс и для 590 и для 360 ) переходим с рассчета
// по периоду на теперь уж более точный рассчет по частоте и наоборот ( с гистерезисом ) .

//   Расчет скорости по частоте производится по формуле: N = F * Km , где F - частота импульсов ,
// Km - масштабирующий коэффициент . Или N = ((PDF_out * 65536)/dT) * Km , где PDF_out - кол-во
// учетверенных ( или удвоенных ) импульсов , dT - время подсчета импульсов .

//   Расчет скорости по периоду производится по формуле:
// PDF_out = ((dT * 65536)/T) * _PDF_Kmul * Km , где T - период импульсов .

//   Величина масштабирующего коэффициента Km выбирается такой , чтобы при номинальной
// скорости двигателя величина PDF_out равнялась 3200 дискрет. Домножение на 65536
// делается для того, чтобы не потерять дробные величины (в результате получается
// число импульсов не за 1 дискрету таймера, а за 65536 дискрет что, в принципе,
// не имеет значения, так как полученная величина все равно пропорциональна
// скорости). Масштабирующий коэффициент сдвинут  влево на 10.

word pdf ( word code , word num )
{
 register word ax , bx , cx ;
 register lword lax;
 register struct PDF_data *ptr ;
 ptr = &PDF[num] ;
 // время п/п для 497-го составляет 42-43мкс, а без вычисл. оборотов 25мкс.

 switch ( code )
 {
   case 0 :    // настройка EPA - передаем его условный номер.

     pdf_drv_init( num ) ; // 05.10.2012 11:35 - инициализация ПДФ перенесена вверх , до чтения ПДФ .
     //---
     ptr->out_ob = 0 ;
     ptr->out_m  = 0 ;
     ptr->out_g  = 0 ;
     ptr->time   = timer1 ;
     ptr->count  = pdf_drv_read( num ) ;
     ptr->Fpdf   = 0 ;
     ptr->N_Fpdf = 0 ;
     ptr->N_Tpdf = 0 ;
     ptr->flg.all= 0 ;
     ptr->fz = 0 ;
   break;

   default:;

    asm_di() ;
     bx = timer1 - ptr->time ;
     ptr->time = timer1 ;
     //---
     ax = pdf_drv_read( num ) ;
    asm_ei() ;
     //---                   //  вычисляем разницу между
     cx = ax - ptr->count ;  // прошлым значением счетчика и текущим.
     ptr->count = ax ;

     //ptr->TMR_copy = ax ; // для проверки .
     //---
        //  Вычисляем кол-во имп. за единицу времени:
       // приводим к кол-ву имп. за базовое время 10мсек,
       // т.е. если функцию вызывать даже каждые 3.3мсек
       // она всеравно будет расчитывать имп. как для 10мсек,
       // только данные будет обновлять чаще - каждые 3.3мсек
       // этим добиваемся стабильного масштабирования независимо
       // от периода опроса.
     lax = (lw)(w)cx * (lw)(w)_PDF_base_time ;
     ax = lax / bx;  // вычисляем модуль неотмасштабированной скорости .
     //---

     ptr->Fpdf = ax ;

     // Если количество пар импульсов ( F00 и F90 ) за базовое время
     // ( _PDF_base_time ) больше 20 - при алгоритме по частоте или
     // 50 - при алгоритме по периоду ( с учетом учетверения или удвоения ) ,
     // то флаг запроса прерывания не выставляется , а знак скорости
     // остаётся прежним , чтобы не загружать процессор вычислениями .
       // Возможно , для ПДФ с большим количеством импульсов на оборот
       // количество импульсов за базовое время нужно будет увеличить вдвое .
   #ifdef _T_PDF
     if ( (w)ax > (c)( 50 * _PDF_Kmul ) )
   #else
     if ( (w)ax > (c)( 20 * _PDF_Kmul ) )
   #endif
      {
        if ( pdf_interrupt(num) == 1 ) pdf_di(num) ; // если разрешены, запретить .
      }      // С таким алгоритмом определения знака скорости , при обрыве
     else    // одного провода F00 или F90 на большой скорости , амплитуда
      {      // обратной связи уменьшится вдвое , а знак не поменяется .
        if ( pdf_interrupt(num) == 0 ) pdf_ei(num) ; // если запрещены, разрешить .
      }
     //---

     // Масштабирование сигнала по ПДФ происходит с использованием двух
     // уставок "ПДФ0-имп/об." и  "N-ном (Об/мин)" и вычисляется по формуле:
     //   Km = Skor_Nom * 60000000 / ( "ПДФ0-имп/об." * "N-ном (Об/мин)" ),
     //   где 60000000 - 60сек в дискретах timer1 ( 1дискрета - 1мкс ) .
     lax = (lw)60000000 / (lw)(w)_r.PDF[num].imp  ;
     lax *= (lw)(w)_Skor_Nom ;
     lax = (lw)lax / (lw)(w)_sr.NOM.N.fe ;

     if ( (sb)pdf_drv_sign(num) < 0 ) ax = ~ax + 1 ;

     //Само масштабирование сигнала по частоте
     // N = F * Km / ( _PDF_base_time * _PDF_Kmul ) ;
     // где F - неотмасштабированная скорость по частоте импульсов
     ptr->N_Fpdf = ( (slw)lax * (slw)(sw)ax ) / (slw)( _PDF_base_time * _PDF_Kmul ) ;

         // Переводим импульсы в обороты:
         //  (N * (1сек/10мсек) * 60)/(_PDF_Kmul * Npdf),
        // где (N * (1сек/10мсек) * 60) кол-во имп. за 1мин.
        //   _Sec(1) - из-за округления дает точность 98%
        //  через *4 уменьшаем погрешность в 4 раза.
     bx = ((w)65535 / (_PDF_base_time*4/_Sec(1*4))) * (60 / _PDF_Kmul) ;
     ptr->out_ob = (slw)(sw)ax * (slw)(sw)bx / (slw)(sw)_r.PDF[num].imp ;

  #ifdef _T_PDF
     //  При запрете прерываний устанавливаем ограничения, чтобы при включении
     //прерываний не получился большой период.
     if ( pdf_interrupt(num) == 0 && ptr->flg._.t_ogr_pdf == 0 ) ptr->flg._.t_ogr_pdf = 1 ;

     //Масштабирование скорости по периоду импульсов
     if ( pdf_drv_data[num].Scht_T != 0 ) // если насчитало хотя-бы один период или больше
       {
         asm_di() ;   // запретить прерывания.
        //Само масштабирование сигнала по периоду
        // N =  Km / T ;
        // где T - период импульсов по ПДФ
         ptr->N_Tpdf = (lw)lax * (lw)(w)pdf_drv_data[num].Scht_T / (lw)(w)pdf_drv_data[num].Tpdf ;
         if ( (sb)pdf_drv_sign(num) < 0 )  ptr->N_Tpdf  =  ~ptr->N_Tpdf + 1 ;

         pdf_drv_data[num].Scht_T = 0 ,  pdf_drv_data[num].Tpdf = 0 ;

         asm_ei() ;   // разрешить прерывания.
         //if ( (sb)pdf_drv_sign(num) < 0 )  ptr->ptr->N_Tpdf  =  ~ptr->ptr->N_Tpdf + 1 ;
       }

     // порог переключения с частоты на период и наоборот ( мб сделать уставку для перехода ) .
     // переключение на ОС по периоду при небольших скоростях            // Для одинаковой точности при переходе :
     if      ( (w)ptr->Fpdf < (c)(  80 ) )  ptr->flg._.pdf_zona_T = 1 ;  // 05.09.2019 - было 40  * _PDF_Kmul, Шестаков пересчитал число ипульсов после удвоения/учетверения .
     else if ( (w)ptr->Fpdf > (c)( 100 ) )  ptr->flg._.pdf_zona_T = 0 ;  // 05.09.2019 - было 45  * _PDF_Kmul, Шестаков пересчитал число ипульсов после удвоения/учетверения .

     if  ( ptr->flg._.pdf_zona_T == 1 )       ptr->out_m = ptr->N_Tpdf ; // скорость по периоду .
     else
  #endif
                                              ptr->out_m = ptr->N_Fpdf ; // скорость по частоте .
     //---
     ptr->flg._.new_izm_pdf = 1 ; // взвод флага готового измерения ПДФ .

  break;
 }
   //------

 return 1 ;
}
