// ѕрограмма нахождени€ квадратного корн€ из длинного беззнакового
// слова. ¬ыходное значение тоже длинное слово, первый байт которого
// дробный.  орень вычисл€етс€ из таблицы, состо€щей из 256 значений.
// Ќомер необходимого значени€ в таблице получаетс€ путем нормализации
// (сдвига влево до первой единицы в старшем разр€де) исходного числа
// из нормализованного значени€ ( число сдвигов должно быть об€зательно
// четным) беретс€ старший байт, данные операции аналогичны делению исходного
// числа на 4 до одного байта.  »з полученного результата и будем по таблице
// брать корень. „исло сдвигов делим на 2 (вз€ли корень из 4)  и полученное
// значение сдвигаем влево на это число.
lword Sqr ( lword Znach )
{
  // ѕередаем исходное значение
  laq = Znach ;
  // ≈сли число и так меньше байта, то и сдвигать его не стоит.
  if ( laq <= 255 )
  {
     dq = laq;
     aq = 0;
  }
  else
  {
    for(bq = 0; (slw)laq > 0; ++bq)  // нормализируем исходное значение
    {
      laq <<=1;
    }
    aq = bq/2 ;
    // ≈сли сдвинули нечетное число раз, то один раз возвращаем
    if (  (bq & 0x01) == 1)
    {
      laq >>=1;
    }
    // “.к. мы сдвигали влево, то половину проделаных сдвигов
    // вычитаем из 12 (число пар сдвигов числа FFFFдо байта)
    aq =12 - aq;
    dq = laq >> 24;
  }
  // Ѕерем корень из полученного числа
  dq = _sqrt_tab[dq];
  // ƒомножаем на 2^aq
  laq = (lw)dq << aq;

  return laq;

}
