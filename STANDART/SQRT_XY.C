
/*    Подпрограмма извлечения корня квадратного.
 *    Диапазон допустимых входных значений "0 ... 16384h".
 *    Выходная величина двухбайтная:
 *  - старший байт - целая часть;
 *  - младший байт - дробная часть (в формате "xxh/256").
 *    Число, из которого следует извлечь корень, передается как параметр.
 *  Результат извлечения корня будет находиться в возвращенном функцией числе.
 */

#define _SQRT_MAX  0x4000

word sqrt_xy ( word x_sqrt )
{
      register word  tst ;
      register word  ax, bx, cx ;
      ax = 0x0 , bx = x_sqrt , cx = _SQRT_MAX ;
      if ( bx > _SQRT_MAX ) bx = _SQRT_MAX ;

loop: ax += cx  ;

      if( ax > bx )    ax -= cx  ;
      else   bx -= ax, ax += cx  ;

      bx <<= 1  ;
      tst = cx & 0x0001 ;// запоминаем младший бит, который вытеснится из 'cx'.
      cx >>= 1  ;

      if( tst == 0 ) goto loop ;

    return ax ;
}
//------------------------------------

/*    Подпрограмма извлечения корня квадратного.
 *    Диапазон допустимых входных значений "0 ... 16384*256*256".
 *    Выходная величина двухбайтная:
 *  - младший байт - дробная часть (в формате "xxh/256").
 *  - старшие байты - целая часть;
 *    Число, из которого следует извлечь корень, передается как параметр.
 *  Результат извлечения корня будет находиться в возвращенном функцией числе.

 *  Время выполнения для процессора MB497:
 *  - для чисел до 0х0000.4000  - 80мкс
 *  - для чисел до 0х4000.0000  - 84мкс
 *  - для чисел до 0хffff.ffff  - 90мкс
 */

lword lsqrt_xy ( lword x_sqrt )
{
      register byte  tst, ah ;
      register word  ax, bx, cx ;

      //--------

      // 'dx' - делитель компенсирующий предварительное деление операнда.
      if ( x_sqrt > (lw)_SQRT_MAX )
      {    // '>>= 8' - чтобы влезть в сетку 'sqrt_xy()'.
        x_sqrt >>= 8, ah = 4 ;
        if ( x_sqrt > (lw)_SQRT_MAX )
        {
          x_sqrt >>= 8, ah = 8 ;
          if ( x_sqrt > (lw)_SQRT_MAX ) x_sqrt >>= 2, ah = 9 ;
        }
      }
      else  ah = 0 ;

      //--------  повторяет функцию 'sqrt_xy()'.
      ax = 0x0 , bx = x_sqrt , cx = _SQRT_MAX ;
      //if ( bx > _SQRT_MAX ) bx = _SQRT_MAX ;

loop: ax += cx  ;

      if( ax > bx )    ax -= cx  ;
      else   bx -= ax, ax += cx  ;

      bx <<= 1  ;
      tst = cx & 0x0001 ;// запоминаем младший бит, который вытеснится из 'cx'.
      cx >>= 1  ;

      if( tst == 0 ) goto loop ;
      //--------

    // '<< dx'- компенсирует предварительное деление операнда '>>8'
                  //  перед извлечением корня.
    return (lw)ax << ah ;
}







