/*    Программа  "Задатчик Интенсивности Универсальный".
 *
 *   Программа использующая ЗИ должна при вызове ЗИ передать ему в качестве
 * параметра адрес своего блока данных для обработки ЗИ.
 * Задатчик Интенсивности  содержит четыре темпа :
 *      - темп разгона двигателя вперед ( в "+" )    ;
 *      - темп торможения двигателя вперед ( в "+" ) ;
 *      - темп разгона двигателя назад ( в "-" )     ;
 *      - темп торможения двигателя назад ( в "-" )  ;
 */

void Zad_Intens ( struct ZI *zip )
{
//    Т.к. эта функция вызывается как из фона так и
//  из прерываний то, по-скольку компилятор не позволяет описать функцию
//  как реентерабельную, для сохранения временных переменных в стеке их
//  следует описать как автоматические, а не как регистровые (т.к.
//  автоматические переменные компилятор распологает в стеке).
  /*register*/   word ax ;
  /*register*/   word bx ;
  /*register*/   word cx ;

//  asm_push(  ax   );  //  Сохраняем, чтобы эта функция могла вызываться
//  asm_push(  bx   );  // из прерывания, прерывая себя же вызванную в фоне.
//  asm_push(  cx   );

  do { ax = Timer1_Ovr , bx = timer1 ; } while ( ax != Timer1_Ovr ) ;
  ax <<= 8 ;      //  Из четырехбайтного полного значения времени
  ax  += (bx>>8); // для работы берутся средние два байта прини-
                    // мающие значения в диапазоне 0.25мсек-12.0сек.

  if ( (u)(w)*zip->temp_p_razg == 0 || (u)(w)*zip->temp_p_torm == 0 )
    {  //если уставки темпов ЗИ равны нулям - ЗИ отключается.
      zip->out = zip->in ;
      zip->time = ax ;  // запись момента текущей отработки ЗИ.
      goto konz ;
    }

  if ( (sw)zip->in != (sw)zip->out )
    {
     bx = (w)( ax - zip->time ) ;

     // если вход и выход ЗИ положительны
     if ( (sw)zip->in >= 0 && (sw)zip->out >= 0 )
       {
        // если вход болше выхода ЗИ используется темп разгона в "+".
        if ( (sw)zip->in > (sw)zip->out )
          {
            // В этом таймере в 1д - 0.256мс .
            // Для случая с ЗИ на 1ном (3200д) за 1мин (60000мс и 10д) рассчитываем :
            //
            //               60000мс
            //               --------
            //   10д * х      3200д
            //   -------- = ---------- , откуда х = 1875 . При 400д было 15000 .
            //     256       0.256мс
            //
            cx  = (w)( (lw)(w)*zip->temp_p_razg * (lw)(w)(15000 >> _Skor_Shift) >> 8 ) ;
            if ( bx < cx )  goto konz ;
            zip->out++ ;
            if ( (sw)zip->out > (sw)zip->in ) zip->out = zip->in ;
          }
        // если вход меньше выхода ЗИ используется темп торможения в "+".
        else
          {
            cx  = (w)( (lw)(w)*zip->temp_p_torm * (lw)(w)(15000 >> _Skor_Shift) >> 8 ) ;
            if ( bx < cx )  goto konz ;
            zip->out-- ;
            if ( (sw)zip->out < (sw)zip->in ) zip->out = zip->in ;
          }
       }

     // иначе если вход и выход ЗИ отрицательны
     else if ( (sw)zip->in < 0 && (sw)zip->out <= 0 )
       {
        // если вход меньше выхода ЗИ (по знаку) используется темп разгона в "-".
        if ( (sw)zip->in < (sw)zip->out )
          {
            cx  = (w)( (lw)(w)*zip->temp_m_razg * (lw)(w)(15000 >> _Skor_Shift) >> 8 ) ;
            if ( bx < cx )  goto konz ;
            zip->out-- ;
            if ( (sw)zip->out < (sw)zip->in ) zip->out = zip->in ;
          }
       // если вход болше выхода ЗИ (по знаку) используется темп торможения в "-".
        else
          {
            cx  = (w)( (lw)(w)*zip->temp_m_torm * (lw)(w)(15000 >> _Skor_Shift) >> 8 ) ;
            if ( bx < cx )  goto konz ;
            zip->out++ ;
            if ( (sw)zip->out > (sw)zip->in ) zip->out = zip->in ;
           }
       }

     // если вход отрицательный а выход положительный
                          //  используется темп торможения в "+".
     else if ( (sw)zip->in < 0 && (sw)zip->out > 0 )
          {
            cx  = (w)( (lw)(w)*zip->temp_p_torm * (lw)(w)(15000 >> _Skor_Shift) >> 8 ) ;
            if ( bx < cx )  goto konz ;
            zip->out-- ;
            if ( (sw)zip->out < 0 ) zip->out = 0 ;
          }
     // если вход положительный а выход отрицательный
                          //  используется темп торможения в "-".
     else if ( (sw)zip->in >= 0 && (sw)zip->out < 0 )
          {
            cx  = (w)( (lw)(w)*zip->temp_m_torm * (lw)(w)(15000 >> _Skor_Shift) >> 8 ) ;
            if ( bx < cx )  goto konz ;
            zip->out++ ;
            if ( (sw)zip->out > 0 ) zip->out = 0 ;
          }
     }
  zip->time = ax ;  // запись момента текущей отработки ЗИ.

konz:

//  asm_pop(  cx   );
//  asm_pop(  bx   );
//  asm_pop(  ax   );

  return ;
}

  // ---------- Программа записи в переменные ЗИ значения ах -----------
  // ------ ( запись КОНЕЧНЫХ ЗНАЧЕНИЙ без переходных процессов ) ------

void Set_ZI ( struct ZI *zip , word ax )
{
  zip->in = ax ;
  zip->in_2 = 0 ;

  zip->out_lin = ax ;
  zip->out_2 = 0 ;
  zip->out = ax ;

  zip->drob_lin = 0 ;
  zip->drob_2 = 0 ;
  zip->drob = 0 ;

  return ;
}

  //--------------------------------------------------------------------


